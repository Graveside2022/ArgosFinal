[
	{
		"filePath": "/home/pi/projects/ArgosFinal/app.d.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/eslint.config.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/playwright.config.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/postcss.config.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/scripts/css-integrity-check.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/scripts/html-structure-validator.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/scripts/testing/test-cleanup.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/scripts/testing/test-database.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/scripts/testing/test-db-altitude.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/scripts/testing/test-hackrf-sweep.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/scripts/testing/test-kismet-api.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/scripts/testing/test-kismet-proxy.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/scripts/testing/test-sweep-manager.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/scripts/visual-regression-check.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/hooks.server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/drone/FlightPathVisualization.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/drone/MissionControl.svelte",
		"messages": [
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-return').",
				"line": 67,
				"column": 5,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [1887, 1924], "text": "" }
			}
		],
		"suppressedMessages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 68,
				"column": 23,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 68,
				"endColumn": 26,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [1947, 1950], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [1947, 1950], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				],
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .L on an `any` value.",
				"line": 68,
				"column": 28,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 68,
				"endColumn": 29,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			}
		],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 1,
		"fixableErrorCount": 0,
		"fixableWarningCount": 1,
		"source": "<script lang=\"ts\">\n  import { createEventDispatcher } from 'svelte';\n  import { \n    activeMission, \n    droneState, \n    missionProgress,\n    startMission,\n    pauseMission,\n    completeMission,\n    createMission,\n    type DroneMission,\n    type Waypoint\n  } from '$lib/stores/drone';\n  import { slide } from 'svelte/transition';\n  import type * as _L from 'leaflet';\n  interface LeafletLayer {\n    options?: {\n      className?: string;\n      draggable?: boolean;\n    };\n    getLatLng?(): { lat: number; lng: number };\n  }\n\n  interface LeafletLibrary {\n    marker(latlng: [number, number], options?: Record<string, unknown>): LeafletMarker;\n    divIcon(options: Record<string, unknown>): unknown;\n    polyline(latlngs: [number, number][], options?: Record<string, unknown>): LeafletPolyline;\n    Marker: new (...args: unknown[]) => LeafletMarker;\n  }\n\n  interface LeafletMarker extends LeafletLayer {\n    on(event: string, handler: (e: LeafletEvent) => void): void;\n    addTo(map: LeafletMap): void;\n    getLatLng(): { lat: number; lng: number };\n  }\n\n  interface LeafletPolyline extends LeafletLayer {\n    addTo(map: LeafletMap): void;\n  }\n\n  interface LeafletMap {\n    _container: HTMLElement;\n    on(event: string, handler: (e: LeafletMouseEvent) => void): void;\n    off(event: string, handler: (e: LeafletMouseEvent) => void): void;\n    eachLayer(handler: (layer: LeafletLayer) => void): void;\n    removeLayer(layer: LeafletLayer): void;\n  }\n\n  interface LeafletMouseEvent {\n    latlng: {\n      lat: number;\n      lng: number;\n    };\n  }\n\n  interface LeafletEvent {\n    target: {\n      getLatLng(): { lat: number; lng: number };\n    };\n  }\n  \n  export let map: LeafletMap;\n  \n  const dispatch = createEventDispatcher();\n  \n  function getLeafletLibrary(): LeafletLibrary {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-return\n    return (window as any).L as LeafletLibrary;\n  }\n  \n  let showMissionPlanner = false;\n  let missionName = '';\n  let missionType: DroneMission['type'] = 'survey';\n  let defaultAltitude = 50;\n  let scanInterval = 1;\n  let signalThreshold = -90;\n  let plannedWaypoints: Waypoint[] = [];\n  let drawingMode = false;\n  let selectedWaypoint: Waypoint | null = null;\n  \n  $: missionActive = $activeMission?.status === 'active';\n  $: missionPaused = $activeMission?.status === 'paused';\n  \n  function toggleMissionPlanner() {\n    showMissionPlanner = !showMissionPlanner;\n    if (showMissionPlanner && map) {\n      enableDrawingMode();\n    } else if (map) {\n      disableDrawingMode();\n    }\n  }\n  \n  function enableDrawingMode() {\n    drawingMode = true;\n    if (!map) return;\n    \n    // Change cursor\n    map._container.style.cursor = 'crosshair';\n    \n    // Add click handler\n    map.on('click', addWaypoint);\n  }\n  \n  function disableDrawingMode() {\n    drawingMode = false;\n    if (!map) return;\n    \n    map._container.style.cursor = '';\n    map.off('click', addWaypoint);\n  }\n  \n  function addWaypoint(e: LeafletMouseEvent) {\n    const waypoint: Waypoint = {\n      id: `wp-${Date.now()}`,\n      lat: e.latlng.lat,\n      lon: e.latlng.lng,\n      altitude: defaultAltitude,\n      actions: [{\n        type: 'signal_sweep',\n        parameters: { duration: scanInterval }\n      }]\n    };\n    \n    plannedWaypoints = [...plannedWaypoints, waypoint];\n    \n    // Add visual marker\n    const leaflet = getLeafletLibrary();\n    const marker = leaflet.marker([waypoint.lat, waypoint.lon], {\n      draggable: true,\n      icon: leaflet.divIcon({\n        className: 'waypoint-marker',\n        html: `\n          <div style=\"\n            background: #ff6b00;\n            color: white;\n            width: 24px;\n            height: 24px;\n            border-radius: 50%;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-size: 12px;\n            font-weight: bold;\n            border: 2px solid white;\n            box-shadow: 0 2px 4px rgba(0,0,0,0.3);\n          \">\n            ${plannedWaypoints.length}\n          </div>\n        `,\n        iconSize: [24, 24],\n        iconAnchor: [12, 12]\n      })\n    });\n    \n    marker.on('dragend', (event: LeafletEvent) => {\n      const newPos = event.target.getLatLng();\n      const index = plannedWaypoints.findIndex(wp => wp.id === waypoint.id);\n      if (index !== -1) {\n        plannedWaypoints[index] = {\n          ...plannedWaypoints[index],\n          lat: newPos.lat,\n          lon: newPos.lng\n        };\n        plannedWaypoints = [...plannedWaypoints]; // Trigger reactivity\n      }\n    });\n    \n    marker.on('click', () => {\n      selectedWaypoint = waypoint;\n    });\n    \n    marker.addTo(map);\n    \n    // Draw path\n    updateMissionPath();\n  }\n  \n  function updateMissionPath() {\n    if (!map || plannedWaypoints.length < 2) return;\n    \n    const leaflet = getLeafletLibrary();\n    const pathPoints = plannedWaypoints.map(wp => [wp.lat, wp.lon]);\n    \n    // Remove old path\n    map.eachLayer((layer: LeafletLayer) => {\n      if (layer.options?.className === 'mission-path') {\n        map.removeLayer(layer);\n      }\n    });\n    \n    // Draw new path\n    leaflet.polyline(pathPoints, {\n      color: '#ff6b00',\n      weight: 3,\n      opacity: 0.7,\n      dashArray: '10, 5',\n      className: 'mission-path'\n    }).addTo(map);\n  }\n  \n  function removeWaypoint(waypoint: Waypoint) {\n    plannedWaypoints = plannedWaypoints.filter(wp => wp.id !== waypoint.id);\n    \n    // Remove marker from map\n    if (map) {\n      map.eachLayer((layer: LeafletLayer) => {\n        const leaflet = getLeafletLibrary();\n        if (layer instanceof leaflet.Marker && layer.getLatLng) {\n          const pos = layer.getLatLng();\n          if (pos.lat === waypoint.lat && pos.lng === waypoint.lon) {\n            map.removeLayer(layer);\n          }\n        }\n      });\n    }\n    \n    updateMissionPath();\n  }\n  \n  function clearWaypoints() {\n    plannedWaypoints = [];\n    selectedWaypoint = null;\n    \n    // Remove all waypoint markers and paths\n    if (map) {\n      map.eachLayer((layer: LeafletLayer) => {\n        const leaflet = getLeafletLibrary();\n        if ((layer.options?.className === 'mission-path') ||\n            (layer instanceof leaflet.Marker && layer.options?.draggable)) {\n          map.removeLayer(layer);\n        }\n      });\n    }\n  }\n  \n  function createAndStartMission() {\n    if (!missionName || plannedWaypoints.length === 0) return;\n    \n    const mission = createMission(\n      missionName,\n      missionType,\n      plannedWaypoints,\n      undefined,\n      {\n        signalThreshold,\n        scanInterval,\n        altitudeFilter: { min: 0, max: defaultAltitude + 50 }\n      }\n    );\n    \n    startMission(mission);\n    showMissionPlanner = false;\n    disableDrawingMode();\n    clearWaypoints();\n    missionName = '';\n    \n    dispatch('missionStarted', mission);\n  }\n  \n  function handlePauseMission() {\n    pauseMission();\n    dispatch('missionPaused');\n  }\n  \n  function handleResumeMission() {\n    if ($activeMission) {\n      $activeMission.status = 'active';\n      activeMission.set($activeMission);\n      dispatch('missionResumed');\n    }\n  }\n  \n  function handleStopMission() {\n    completeMission();\n    dispatch('missionCompleted');\n  }\n  \n  function formatDuration(ms: number): string {\n    const seconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n    \n    if (hours > 0) {\n      return `${hours}h ${minutes % 60}m`;\n    } else if (minutes > 0) {\n      return `${minutes}m ${seconds % 60}s`;\n    } else {\n      return `${seconds}s`;\n    }\n  }\n</script>\n\n<div class=\"mission-control\">\n  <!-- Active Mission Status -->\n  {#if $activeMission}\n    <div class=\"active-mission\" transition:slide>\n      <div class=\"mission-header\">\n        <h3>{$activeMission.name}</h3>\n        <span class=\"mission-type\">{$activeMission.type}</span>\n        <span class=\"mission-status\" class:active={missionActive} class:paused={missionPaused}>\n          {$activeMission.status}\n        </span>\n      </div>\n      \n      <div class=\"mission-stats\">\n        <div class=\"stat\">\n          <span class=\"label\">Progress</span>\n          <div class=\"progress-bar\">\n            <div class=\"progress-fill\" style=\"width: {$missionProgress}%\"></div>\n          </div>\n          <span class=\"value\">{$missionProgress.toFixed(0)}%</span>\n        </div>\n        \n        <div class=\"stat\">\n          <span class=\"label\">Duration</span>\n          <span class=\"value\">{formatDuration($activeMission.statistics.totalDuration)}</span>\n        </div>\n        \n        <div class=\"stat\">\n          <span class=\"label\">Signals</span>\n          <span class=\"value\">{$activeMission.statistics.signalsCaptured}</span>\n        </div>\n        \n        <div class=\"stat\">\n          <span class=\"label\">Distance</span>\n          <span class=\"value\">{($activeMission.statistics.totalDistance / 1000).toFixed(1)} km</span>\n        </div>\n      </div>\n      \n      <div class=\"mission-controls\">\n        {#if missionActive}\n          <button class=\"btn-pause\" on:click={handlePauseMission}>\n            <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n              <path d=\"M6 19h4V5H6v14zm8-14v14h4V5h-4z\"/>\n            </svg>\n            Pause\n          </button>\n        {:else if missionPaused}\n          <button class=\"btn-resume\" on:click={handleResumeMission}>\n            <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n              <path d=\"M8 5v14l11-7z\"/>\n            </svg>\n            Resume\n          </button>\n        {/if}\n        \n        <button class=\"btn-stop\" on:click={handleStopMission}>\n          <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M6 6h12v12H6z\"/>\n          </svg>\n          Stop\n        </button>\n      </div>\n    </div>\n  {:else}\n    <!-- Mission Planner -->\n    <button class=\"btn-plan-mission\" on:click={toggleMissionPlanner}>\n      <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n        <path d=\"M14 2l6 6v12a2 2 0 01-2 2H6a2 2 0 01-2-2V4a2 2 0 012-2h8zm4 8h-5V5l5 5z\"/>\n      </svg>\n      Plan Mission\n    </button>\n  {/if}\n  \n  <!-- Mission Planner Panel -->\n  {#if showMissionPlanner}\n    <div class=\"mission-planner\" transition:slide>\n      <div class=\"planner-header\">\n        <h3>Mission Planner</h3>\n        <button class=\"btn-close\" on:click={toggleMissionPlanner}>×</button>\n      </div>\n      \n      <div class=\"planner-content\">\n        <div class=\"form-group\">\n          <label for=\"mission-name\">Mission Name</label>\n          <input\n            id=\"mission-name\"\n            type=\"text\"\n            bind:value={missionName}\n            placeholder=\"Enter mission name\"\n          />\n        </div>\n        \n        <div class=\"form-group\">\n          <label for=\"mission-type\">Mission Type</label>\n          <select id=\"mission-type\" bind:value={missionType}>\n            <option value=\"survey\">Area Survey</option>\n            <option value=\"patrol\">Patrol Route</option>\n            <option value=\"monitoring\">Signal Monitoring</option>\n            <option value=\"mapping\">RF Mapping</option>\n          </select>\n        </div>\n        \n        <div class=\"form-group\">\n          <label for=\"default-altitude\">Default Altitude (m)</label>\n          <input\n            id=\"default-altitude\"\n            type=\"number\"\n            bind:value={defaultAltitude}\n            min=\"10\"\n            max=\"400\"\n            step=\"10\"\n          />\n        </div>\n        \n        <div class=\"form-group\">\n          <label for=\"scan-interval\">Scan Interval (s)</label>\n          <input\n            id=\"scan-interval\"\n            type=\"number\"\n            bind:value={scanInterval}\n            min=\"0.5\"\n            max=\"10\"\n            step=\"0.5\"\n          />\n        </div>\n        \n        <div class=\"form-group\">\n          <label for=\"signal-threshold\">Signal Threshold (dBm)</label>\n          <input\n            id=\"signal-threshold\"\n            type=\"number\"\n            bind:value={signalThreshold}\n            min=\"-100\"\n            max=\"-30\"\n            step=\"5\"\n          />\n        </div>\n        \n        <div class=\"waypoints-section\">\n          <div class=\"section-header\">\n            <h4>Waypoints ({plannedWaypoints.length})</h4>\n            <button class=\"btn-clear\" on:click={clearWaypoints} disabled={plannedWaypoints.length === 0}>\n              Clear All\n            </button>\n          </div>\n          \n          {#if drawingMode}\n            <div class=\"drawing-hint\">\n              Click on the map to add waypoints\n            </div>\n          {/if}\n          \n          <div class=\"waypoints-list\">\n            {#each plannedWaypoints as waypoint, index}\n              <div class=\"waypoint-item\" class:selected={selectedWaypoint?.id === waypoint.id}>\n                <span class=\"waypoint-number\">{index + 1}</span>\n                <div class=\"waypoint-info\">\n                  <div class=\"coords\">\n                    {waypoint.lat.toFixed(6)}, {waypoint.lon.toFixed(6)}\n                  </div>\n                  <div class=\"altitude\">\n                    Alt: {waypoint.altitude}m\n                  </div>\n                </div>\n                <button class=\"btn-remove\" on:click={() => removeWaypoint(waypoint)}>\n                  ×\n                </button>\n              </div>\n            {/each}\n          </div>\n        </div>\n        \n        <div class=\"planner-actions\">\n          <button \n            class=\"btn-start-mission\" \n            on:click={createAndStartMission}\n            disabled={!missionName || plannedWaypoints.length === 0 || !$droneState.connected}\n          >\n            Start Mission\n          </button>\n        </div>\n      </div>\n    </div>\n  {/if}\n</div>\n\n<style>\n  .mission-control {\n    position: relative;\n    background: rgba(17, 24, 39, 0.95);\n    border-radius: 8px;\n    padding: 16px;\n    color: white;\n    min-width: 300px;\n  }\n  \n  .active-mission {\n    space-y: 12px;\n  }\n  \n  .mission-header {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    margin-bottom: 12px;\n  }\n  \n  .mission-header h3 {\n    margin: 0;\n    font-size: 18px;\n    flex: 1;\n  }\n  \n  .mission-type {\n    background: rgba(59, 130, 246, 0.2);\n    color: #60a5fa;\n    padding: 2px 8px;\n    border-radius: 4px;\n    font-size: 12px;\n    text-transform: uppercase;\n  }\n  \n  .mission-status {\n    padding: 2px 8px;\n    border-radius: 4px;\n    font-size: 12px;\n    text-transform: uppercase;\n    font-weight: 500;\n  }\n  \n  .mission-status.active {\n    background: rgba(34, 197, 94, 0.2);\n    color: #4ade80;\n  }\n  \n  .mission-status.paused {\n    background: rgba(251, 191, 36, 0.2);\n    color: #fbbf24;\n  }\n  \n  .mission-stats {\n    display: grid;\n    grid-template-columns: repeat(2, 1fr);\n    gap: 12px;\n    margin-bottom: 16px;\n  }\n  \n  .stat {\n    display: flex;\n    flex-direction: column;\n    gap: 4px;\n  }\n  \n  .stat .label {\n    font-size: 12px;\n    color: #9ca3af;\n  }\n  \n  .stat .value {\n    font-size: 16px;\n    font-weight: 600;\n  }\n  \n  .progress-bar {\n    width: 100%;\n    height: 4px;\n    background: rgba(255, 255, 255, 0.1);\n    border-radius: 2px;\n    overflow: hidden;\n  }\n  \n  .progress-fill {\n    height: 100%;\n    background: #22c55e;\n    transition: width 0.3s ease;\n  }\n  \n  .mission-controls {\n    display: flex;\n    gap: 8px;\n  }\n  \n  button {\n    display: flex;\n    align-items: center;\n    gap: 4px;\n    padding: 8px 16px;\n    border: none;\n    border-radius: 6px;\n    font-size: 14px;\n    font-weight: 500;\n    cursor: pointer;\n    transition: all 0.2s;\n  }\n  \n  .btn-pause {\n    background: #f59e0b;\n    color: white;\n  }\n  \n  .btn-pause:hover {\n    background: #d97706;\n  }\n  \n  .btn-resume {\n    background: #22c55e;\n    color: white;\n  }\n  \n  .btn-resume:hover {\n    background: #16a34a;\n  }\n  \n  .btn-stop {\n    background: #ef4444;\n    color: white;\n  }\n  \n  .btn-stop:hover {\n    background: #dc2626;\n  }\n  \n  .btn-plan-mission {\n    background: #3b82f6;\n    color: white;\n    width: 100%;\n    justify-content: center;\n  }\n  \n  .btn-plan-mission:hover {\n    background: #2563eb;\n  }\n  \n  .mission-planner {\n    position: absolute;\n    top: 100%;\n    left: 0;\n    right: 0;\n    margin-top: 8px;\n    background: rgba(17, 24, 39, 0.98);\n    border-radius: 8px;\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    z-index: 10;\n    max-height: 600px;\n    overflow-y: auto;\n  }\n  \n  .planner-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 16px;\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n  }\n  \n  .planner-header h3 {\n    margin: 0;\n    font-size: 18px;\n  }\n  \n  .btn-close {\n    background: none;\n    color: #9ca3af;\n    font-size: 24px;\n    width: 32px;\n    height: 32px;\n    padding: 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n  }\n  \n  .btn-close:hover {\n    color: white;\n  }\n  \n  .planner-content {\n    padding: 16px;\n  }\n  \n  .form-group {\n    margin-bottom: 16px;\n  }\n  \n  .form-group label {\n    display: block;\n    font-size: 14px;\n    color: #9ca3af;\n    margin-bottom: 4px;\n  }\n  \n  .form-group input,\n  .form-group select {\n    width: 100%;\n    padding: 8px 12px;\n    background: rgba(255, 255, 255, 0.05);\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    border-radius: 6px;\n    color: white;\n    font-size: 14px;\n  }\n  \n  .form-group input:focus,\n  .form-group select:focus {\n    outline: none;\n    border-color: #3b82f6;\n    background: rgba(255, 255, 255, 0.08);\n  }\n  \n  .waypoints-section {\n    margin-top: 24px;\n  }\n  \n  .section-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 12px;\n  }\n  \n  .section-header h4 {\n    margin: 0;\n    font-size: 16px;\n  }\n  \n  .btn-clear {\n    background: rgba(239, 68, 68, 0.2);\n    color: #f87171;\n    padding: 4px 12px;\n    font-size: 12px;\n  }\n  \n  .btn-clear:hover:not(:disabled) {\n    background: rgba(239, 68, 68, 0.3);\n  }\n  \n  .btn-clear:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n  }\n  \n  .drawing-hint {\n    background: rgba(59, 130, 246, 0.1);\n    border: 1px solid rgba(59, 130, 246, 0.3);\n    padding: 8px 12px;\n    border-radius: 6px;\n    font-size: 14px;\n    color: #93bbfc;\n    margin-bottom: 12px;\n    text-align: center;\n  }\n  \n  .waypoints-list {\n    max-height: 200px;\n    overflow-y: auto;\n  }\n  \n  .waypoint-item {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    padding: 8px;\n    background: rgba(255, 255, 255, 0.03);\n    border-radius: 6px;\n    margin-bottom: 4px;\n    transition: all 0.2s;\n  }\n  \n  .waypoint-item:hover {\n    background: rgba(255, 255, 255, 0.05);\n  }\n  \n  .waypoint-item.selected {\n    background: rgba(59, 130, 246, 0.1);\n    border: 1px solid rgba(59, 130, 246, 0.3);\n  }\n  \n  .waypoint-number {\n    background: #ff6b00;\n    color: white;\n    width: 24px;\n    height: 24px;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 12px;\n    font-weight: bold;\n  }\n  \n  .waypoint-info {\n    flex: 1;\n  }\n  \n  .coords {\n    font-size: 13px;\n    font-family: monospace;\n  }\n  \n  .altitude {\n    font-size: 12px;\n    color: #9ca3af;\n  }\n  \n  .btn-remove {\n    background: none;\n    color: #ef4444;\n    width: 24px;\n    height: 24px;\n    padding: 0;\n    font-size: 20px;\n    line-height: 1;\n  }\n  \n  .btn-remove:hover {\n    color: #dc2626;\n  }\n  \n  .planner-actions {\n    margin-top: 24px;\n    padding-top: 16px;\n    border-top: 1px solid rgba(255, 255, 255, 0.1);\n  }\n  \n  .btn-start-mission {\n    background: #22c55e;\n    color: white;\n    width: 100%;\n    justify-content: center;\n    padding: 12px;\n    font-size: 16px;\n  }\n  \n  .btn-start-mission:hover:not(:disabled) {\n    background: #16a34a;\n  }\n  \n  .btn-start-mission:disabled {\n    background: #4b5563;\n    cursor: not-allowed;\n    opacity: 0.5;\n  }\n</style>",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/hackrf/AnalysisTools.svelte",
		"messages": [
			{
				"ruleId": "@typescript-eslint/require-await",
				"severity": 2,
				"message": "Async function 'exportData' has no 'await' expression.",
				"line": 18,
				"column": 3,
				"nodeType": "FunctionDeclaration",
				"messageId": "missingAwait",
				"endLine": 18,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "removeAsync",
						"fix": { "range": [510, 516], "text": "" },
						"desc": "Remove 'async'."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "<script lang=\"ts\">\n  import { onMount, onDestroy } from 'svelte';\n  import { hackrfService } from '$lib/services/hackrf';\n  import type { SignalDetection } from '$lib/services/api/hackrf';\n  \n  let detectedSignals: SignalDetection[] = [];\n  let signalsUnsubscribe: (() => void) | undefined;\n  let isExporting = false;\n  \n  function launchOpenWebRX() {\n    window.open('http://localhost:8073', '_blank');\n  }\n  \n  function launchSpectrumAnalyzer() {\n    window.open('http://localhost:8092', '_blank');\n  }\n  \n  async function exportData(format: 'csv' | 'json') {\n    isExporting = true;\n    try {\n      void hackrfService.exportData(format);\n    } catch (error) {\n      console.error('Export failed:', error);\n    } finally {\n      isExporting = false;\n    }\n  }\n  \n  onMount(() => {\n    // Subscribe to detected signals\n    signalsUnsubscribe = hackrfService.detectedSignals.subscribe((signals: SignalDetection[]) => {\n      detectedSignals = signals.slice(-5); // Keep last 5 signals\n    });\n  });\n  \n  onDestroy(() => {\n    if (signalsUnsubscribe) signalsUnsubscribe();\n  });\n</script>\n\n<div class=\"saasfly-feature-card group rounded-2xl p-8 bg-gradient-to-br from-bg-card/80 via-bg-card/60 to-bg-card/40 border border-border-primary/40 backdrop-blur-xl shadow-lg hover:shadow-xl hover:border-purple-400/30 hover:bg-gradient-to-br hover:from-bg-card/90 hover:via-bg-card/70 hover:to-bg-card/50 transition-all duration-300\">\n  <div class=\"flex items-center mb-6\">\n    <div class=\"p-3 bg-gradient-to-br from-purple-500/20 to-purple-500/10 rounded-xl mr-4 border border-purple-400/20 group-hover:border-purple-400/40 group-hover:shadow-lg group-hover:shadow-purple-400/20 transition-all duration-300\">\n      <svg class=\"w-6 h-6 text-purple-400 group-hover:scale-110 transition-transform duration-300\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n        <path fill-rule=\"evenodd\" d=\"M3 4a1 1 0 011-1h4a1 1 0 010 2H6.414l2.293 2.293a1 1 0 01.293.707V12a1 1 0 01-.293.707l-2.293 2.293H8a1 1 0 010 2H4a1 1 0 01-1-1v-4a1 1 0 01.293-.707L5.586 9 3.293 6.707A1 1 0 013 6V4zm8-2a1 1 0 011-1h4a1 1 0 011 1v2a1 1 0 01-.293.707L14.414 7l2.293 2.293A1 1 0 0117 10v4a1 1 0 01-1 1h-4a1 1 0 010-2h1.586l-2.293-2.293A1 1 0 0111 10V8a1 1 0 01.293-.707L13.586 5H12a1 1 0 010-2z\"/>\n      </svg>\n    </div>\n    <div>\n      <h3 class=\"font-heading text-xl font-semibold external-tools-header mb-1 transition-colors duration-300\">Analysis Tools</h3>\n      <p class=\"text-sm text-text-muted group-hover:text-text-secondary transition-colors duration-300\">External monitoring tools</p>\n    </div>\n  </div>\n  \n  <div class=\"space-y-6\">\n    <!-- External Tools -->\n    <div class=\"space-y-3\">\n      <button on:click={launchOpenWebRX} class=\"saasfly-btn saasfly-btn-outline w-full group\">\n        <svg class=\"w-4 h-4 group-hover:text-neon-cyan transition-colors duration-200\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n          <path d=\"M11 3a1 1 0 100 2h2.586l-6.293 6.293a1 1 0 101.414 1.414L15 6.414V9a1 1 0 102 0V4a1 1 0 00-1-1h-5z\"/>\n          <path d=\"M5 5a2 2 0 00-2 2v8a2 2 0 002 2h8a2 2 0 002-2v-3a1 1 0 10-2 0v3H5V7h3a1 1 0 000-2H5z\"/>\n        </svg>\n        Open WebRX\n      </button>\n      \n      <button on:click={launchSpectrumAnalyzer} class=\"saasfly-btn saasfly-btn-outline w-full group\">\n        <svg class=\"w-4 h-4 group-hover:text-purple-400 transition-colors duration-200\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n          <path d=\"M2 10a8 8 0 018-8v8h8a8 8 0 11-16 0z\"/>\n          <path d=\"M12 2.252A8.014 8.014 0 0117.748 8H12V2.252z\"/>\n        </svg>\n        Spectrum Analyzer\n      </button>\n    </div>\n    \n    <!-- Detected Signals -->\n    {#if detectedSignals.length > 0}\n      <div>\n        <h4 class=\"text-sm font-medium text-text-muted mb-3 uppercase tracking-wide\">Recent Signals</h4>\n        <div class=\"space-y-2 max-h-[150px] overflow-y-auto\">\n          {#each detectedSignals as signal}\n            <div class=\"p-3 bg-bg-input/40 rounded-lg border border-border-primary/30 hover:border-purple-400/30 transition-all duration-200\">\n              <div class=\"flex justify-between items-center\">\n                <span class=\"font-mono text-sm\">{(signal.frequency / 1e6).toFixed(2)} MHz</span>\n                <span class=\"text-xs text-text-muted\">{signal.power.toFixed(1)} dBm</span>\n              </div>\n              {#if signal.modulation}\n                <span class=\"text-xs text-purple-400\">{signal.modulation}</span>\n              {/if}\n            </div>\n          {/each}\n        </div>\n      </div>\n    {/if}\n    \n    <!-- Export Options -->\n    <div>\n      <h4 class=\"text-sm font-medium text-text-muted mb-3 uppercase tracking-wide\">Export Data</h4>\n      <div class=\"grid grid-cols-2 gap-2\">\n        <button \n          on:click={() => exportData('json')}\n          disabled={isExporting}\n          class=\"saasfly-btn saasfly-btn-sm saasfly-btn-secondary\"\n          class:opacity-50={isExporting}\n        >\n          <svg class=\"w-3 h-3\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n            <path fill-rule=\"evenodd\" d=\"M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z\"/>\n          </svg>\n          JSON\n        </button>\n        <button \n          on:click={() => exportData('csv')}\n          disabled={isExporting}\n          class=\"saasfly-btn saasfly-btn-sm saasfly-btn-secondary\"\n          class:opacity-50={isExporting}\n        >\n          <svg class=\"w-3 h-3\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n            <path fill-rule=\"evenodd\" d=\"M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z\"/>\n          </svg>\n          CSV\n        </button>\n      </div>\n    </div>\n  </div>\n</div>",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/hackrf/ConnectionStatus.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/hackrf/FrequencyConfig.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/hackrf/GeometricBackground.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/hackrf/HackRFHeader.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/hackrf/MobileMenu.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/hackrf/SignalAgeVisualization.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/hackrf/SpectrumAnalysis.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/hackrf/SpectrumChart.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/hackrf/StatusDisplay.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/hackrf/StatusIndicator.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/hackrf/SweepControl.svelte",
		"messages": [
			{
				"ruleId": "@typescript-eslint/require-await",
				"severity": 2,
				"message": "Async function 'startSweep' has no 'await' expression.",
				"line": 9,
				"column": 2,
				"nodeType": "FunctionDeclaration",
				"messageId": "missingAwait",
				"endLine": 9,
				"endColumn": 27,
				"suggestions": [
					{
						"messageId": "removeAsync",
						"fix": { "range": [248, 254], "text": "" },
						"desc": "Remove 'async'."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/require-await",
				"severity": 2,
				"message": "Async function 'stopSweep' has no 'await' expression.",
				"line": 32,
				"column": 2,
				"nodeType": "FunctionDeclaration",
				"messageId": "missingAwait",
				"endLine": 32,
				"endColumn": 26,
				"suggestions": [
					{
						"messageId": "removeAsync",
						"fix": { "range": [789, 795], "text": "" },
						"desc": "Remove 'async'."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/require-await",
				"severity": 2,
				"message": "Async function 'emergencyStop' has no 'await' expression.",
				"line": 44,
				"column": 2,
				"nodeType": "FunctionDeclaration",
				"messageId": "missingAwait",
				"endLine": 44,
				"endColumn": 30,
				"suggestions": [
					{
						"messageId": "removeAsync",
						"fix": { "range": [1053, 1059], "text": "" },
						"desc": "Remove 'async'."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 3,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "<script lang=\"ts\">\n\timport { sweepStatus, cycleStatus, emergencyStopStatus, frequencyRanges } from '$lib/stores/hackrf';\n\timport { hackrfAPI } from '$lib/services/hackrf/api';\n\t\n\tlet cycleTime = 10;\n\tlet starting = false;\n\tlet stopping = false;\n\t\n\tasync function startSweep() {\n\t\tif ($frequencyRanges.length === 0) {\n\t\t\talert('Please configure at least one frequency range');\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tstarting = true;\n\t\ttry {\n\t\t\tconst frequencies = $frequencyRanges.map(range => ({\n\t\t\t\tstart: range.start,\n\t\t\t\tstop: range.stop,\n\t\t\t\tstep: range.step\n\t\t\t}));\n\t\t\t\n\t\t\tvoid hackrfAPI.startSweep(frequencies, cycleTime);\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to start sweep:', error);\n\t\t\talert('Failed to start sweep. Check console for details.');\n\t\t} finally {\n\t\t\tstarting = false;\n\t\t}\n\t}\n\t\n\tasync function stopSweep() {\n\t\tstopping = true;\n\t\ttry {\n\t\t\tvoid hackrfAPI.stopSweep();\n\t\t} catch (error) {\n\t\t\tconsole.error('Failed to stop sweep:', error);\n\t\t\talert('Failed to stop sweep. Check console for details.');\n\t\t} finally {\n\t\t\tstopping = false;\n\t\t}\n\t}\n\t\n\tasync function emergencyStop() {\n\t\ttry {\n\t\t\tvoid hackrfAPI.emergencyStop();\n\t\t} catch (error) {\n\t\t\tconsole.error('Emergency stop failed:', error);\n\t\t\talert('Emergency stop failed! Try manual shutdown.');\n\t\t}\n\t}\n\t\n\tfunction _formatTime(seconds: number): string {\n\t\tconst mins = Math.floor(seconds / 60);\n\t\tconst secs = seconds % 60;\n\t\treturn `${mins}:${secs.toString().padStart(2, '0')}`;\n\t}\n</script>\n\n<!-- Sweep Control Panel -->\n<div class=\"glass-panel rounded-xl p-6\">\n\t<h3 class=\"text-h4 font-heading font-semibold text-text-primary mb-6 flex items-center\">\n\t\t<svg class=\"w-5 h-5 mr-2 text-accent-muted\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n\t\t\t<path fill-rule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 0016 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM12 10a1 1 0 100 2 1 1 0 000-2zm7 0a1 1 0 11-2 0 1 1 0 012 0z\" clip-rule=\"evenodd\"/>\n\t\t</svg>\n\t\tSweep Control\n\t</h3>\n\t\n\t<!-- Cycle Time Configuration -->\n\t<div class=\"mb-6\">\n\t\t<label for=\"sweepCycleTime\" class=\"block font-mono text-xs text-text-muted uppercase tracking-wider mb-2\">Cycle Time (seconds)</label>\n\t\t<div class=\"flex items-center space-x-4\">\n\t\t\t<input \n\t\t\t\tid=\"sweepCycleTime\"\n\t\t\t\ttype=\"range\" \n\t\t\t\tbind:value={cycleTime}\n\t\t\t\tmin=\"1\" \n\t\t\t\tmax=\"60\" \n\t\t\t\tclass=\"flex-1 h-2 bg-bg-muted rounded-lg appearance-none cursor-pointer accent-accent-primary\"\n\t\t\t\tdisabled={$sweepStatus.active}\n\t\t\t/>\n\t\t\t<div class=\"w-20 text-center\">\n\t\t\t\t<span class=\"font-mono text-h4 text-accent-primary\">{cycleTime}s</span>\n\t\t\t</div>\n\t\t</div>\n\t\t<div class=\"flex justify-between mt-2\">\n\t\t\t<span class=\"font-mono text-caption text-text-muted\">Fast</span>\n\t\t\t<span class=\"font-mono text-caption text-text-muted\">Slow</span>\n\t\t</div>\n\t</div>\n\t\n\t<!-- Status Information -->\n\t<div class=\"grid grid-cols-2 gap-4 mb-6\">\n\t\t<div class=\"glass-panel-light rounded-lg p-4\">\n\t\t\t<span class=\"font-mono text-xs text-text-muted uppercase tracking-wider\">Status</span>\n\t\t\t<p class=\"font-mono text-body {$sweepStatus.active ? 'text-neon-green' : 'text-text-secondary'} mt-1\">\n\t\t\t\t{$sweepStatus.active ? 'Sweeping' : 'Idle'}\n\t\t\t</p>\n\t\t</div>\n\t\t<div class=\"glass-panel-light rounded-lg p-4\">\n\t\t\t<span class=\"font-mono text-xs text-text-muted uppercase tracking-wider\">Progress</span>\n\t\t\t<p class=\"font-mono text-body text-text-primary mt-1\">\n\t\t\t\t{#if $cycleStatus.currentCycle && $cycleStatus.totalCycles}\n\t\t\t\t\t{$cycleStatus.currentCycle} / {$cycleStatus.totalCycles}\n\t\t\t\t{:else}\n\t\t\t\t\t--\n\t\t\t\t{/if}\n\t\t\t</p>\n\t\t</div>\n\t</div>\n\t\n\t<!-- Control Buttons -->\n\t<div class=\"flex space-x-4\">\n\t\t{#if !$sweepStatus.active}\n\t\t\t<button \n\t\t\t\ton:click={startSweep}\n\t\t\t\tdisabled={starting || $frequencyRanges.length === 0}\n\t\t\t\tclass=\"flex-1 saasfly-button-primary disabled:opacity-50 disabled:cursor-not-allowed\"\n\t\t\t>\n\t\t\t\t{#if starting}\n\t\t\t\t\t<svg class=\"w-5 h-5 mr-2 animate-spin\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n\t\t\t\t\t\t<path fill-rule=\"evenodd\" d=\"M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z\" clip-rule=\"evenodd\"/>\n\t\t\t\t\t</svg>\n\t\t\t\t\tStarting...\n\t\t\t\t{:else}\n\t\t\t\t\t<svg class=\"w-5 h-5 mr-2\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n\t\t\t\t\t\t<path fill-rule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 0016 0zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z\" clip-rule=\"evenodd\"/>\n\t\t\t\t\t</svg>\n\t\t\t\t\tStart Sweep\n\t\t\t\t{/if}\n\t\t\t</button>\n\t\t{:else}\n\t\t\t<button \n\t\t\t\ton:click={stopSweep}\n\t\t\t\tdisabled={stopping}\n\t\t\t\tclass=\"flex-1 glass-button rounded-lg hover:bg-bg-muted/40 disabled:opacity-50 disabled:cursor-not-allowed\"\n\t\t\t>\n\t\t\t\t{#if stopping}\n\t\t\t\t\t<svg class=\"w-5 h-5 mr-2 animate-spin\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n\t\t\t\t\t\t<path fill-rule=\"evenodd\" d=\"M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z\" clip-rule=\"evenodd\"/>\n\t\t\t\t\t</svg>\n\t\t\t\t\tStopping...\n\t\t\t\t{:else}\n\t\t\t\t\t<div class=\"flex items-center justify-center\">\n\t\t\t\t\t\t<svg class=\"w-5 h-5 mr-2\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n\t\t\t\t\t\t\t<path fill-rule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 0016 0zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 001-1V8a1 1 0 00-1-1H8z\" clip-rule=\"evenodd\"/>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t\tStop Sweep\n\t\t\t\t\t</div>\n\t\t\t\t{/if}\n\t\t\t</button>\n\t\t\t<button \n\t\t\t\ton:click={emergencyStop}\n\t\t\t\tclass=\"px-6 py-3 bg-red-500/20 text-red-400 border border-red-500/40 rounded-lg hover:bg-red-500/30 hover:shadow-red-glow transition-all duration-200 font-semibold\"\n\t\t\t>\n\t\t\t\t<svg class=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n\t\t\t\t\t<path fill-rule=\"evenodd\" d=\"M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-6-3a2 2 0 11-4 0 2 2 0 014 0zm-2 4a1 1 0 00-1 1v3a1 1 0 102 0v-3a1 1 0 00-1-1z\" clip-rule=\"evenodd\"/>\n\t\t\t\t</svg>\n\t\t\t</button>\n\t\t{/if}\n\t</div>\n\t\n\t<!-- Emergency Stop Warning -->\n\t{#if $emergencyStopStatus.active}\n\t\t<div class=\"mt-4 p-4 bg-red-500/20 border border-red-500/40 rounded-lg animate-pulse\">\n\t\t\t<p class=\"font-mono text-caption text-red-400 flex items-center\">\n\t\t\t\t<svg class=\"w-5 h-5 mr-2\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n\t\t\t\t\t<path fill-rule=\"evenodd\" d=\"M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z\" clip-rule=\"evenodd\"/>\n\t\t\t\t</svg>\n\t\t\t\tEmergency stop activated. Restart the application to continue.\n\t\t\t</p>\n\t\t</div>\n\t{/if}\n</div>",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/hackrf/TimeFilterDemo.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/hackrf/TimeWindowControl.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/hackrf/TimedSignalDisplay.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/kismet/AlertsPanel.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/kismet/DeviceList.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/kismet/MapView.svelte",
		"messages": [],
		"suppressedMessages": [
			{
				"ruleId": "no-console",
				"severity": 1,
				"message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
				"line": 41,
				"column": 3,
				"nodeType": "MemberExpression",
				"messageId": "limited",
				"endLine": 41,
				"endColumn": 14,
				"suggestions": [
					{
						"fix": { "range": [950, 1005], "text": "" },
						"messageId": "removeConsole",
						"data": { "propertyName": "log" },
						"desc": "Remove the console.log()."
					}
				],
				"suppressions": [{ "kind": "directive", "justification": "" }]
			}
		],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/kismet/ServiceControl.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/kismet/StatisticsPanel.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/map/MapControls.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/map/SignalDetailPanel.svelte",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 47,
				"column": 49,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 47,
				"endColumn": 77
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .lat on an `error` typed value.",
				"line": 47,
				"column": 66,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 47,
				"endColumn": 69
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 47,
				"column": 85,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 47,
				"endColumn": 113
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .lon on an `error` typed value.",
				"line": 47,
				"column": 102,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 47,
				"endColumn": 105
			}
		],
		"suppressedMessages": [],
		"errorCount": 4,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "<script lang=\"ts\">\n  import { createEventDispatcher } from 'svelte';\n  import type { SignalMarker } from '$lib/stores/map/signals';\n  import type { SignalCluster } from '$lib/services/map/signalClustering';\n  import SignalTypeIndicator from './SignalTypeIndicator.svelte';\n  import SignalStrengthMeter from './SignalStrengthMeter.svelte';\n  \n  export let cluster: SignalCluster | null = null;\n  export let isOpen = false;\n  \n  const dispatch = createEventDispatcher();\n  \n  function close() {\n    dispatch('close');\n  }\n  \n  function selectSignal(signal: SignalMarker) {\n    dispatch('selectSignal', signal);\n  }\n  \n  // Sort signals by power (strongest first)\n  $: sortedSignals = cluster ? [...cluster.signals].sort((a, b) => b.power - a.power) : [];\n  \n  // Group signals by type\n  $: signalsByType = sortedSignals.reduce((acc: Record<string, SignalMarker[]>, signal) => {\n    const type = signal.metadata.signalType || 'unknown';\n    if (!acc[type]) acc[type] = [];\n    acc[type].push(signal);\n    return acc;\n  }, {} as Record<string, SignalMarker[]>);\n</script>\n\n{#if isOpen && cluster}\n  <div class=\"fixed inset-0 bg-black/50 z-[2000] flex items-center justify-center p-4\"\n       on:click={close}\n       on:keydown={(e) => e.key === 'Escape' && close()}\n       role=\"button\"\n       tabindex=\"0\">\n    <div class=\"bg-gray-900 rounded-lg shadow-2xl max-w-4xl w-full max-h-[80vh] overflow-hidden\"\n         on:click|stopPropagation>\n      <!-- Header -->\n      <div class=\"bg-gray-800 px-6 py-4 border-b border-gray-700\">\n        <div class=\"flex items-center justify-between\">\n          <div>\n            <h2 class=\"text-xl font-bold text-white\">Cluster Details</h2>\n            <p class=\"text-sm text-gray-400 mt-1\">\n              {cluster.stats.count} signals at {cluster.position.lat.toFixed(6)}°, {cluster.position.lon.toFixed(6)}°\n            </p>\n          </div>\n          <button\n            on:click={close}\n            class=\"text-gray-400 hover:text-white transition-colors p-2\"\n            aria-label=\"Close\">\n            <svg class=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M6 18L18 6M6 6l12 12\" />\n            </svg>\n          </button>\n        </div>\n      </div>\n      \n      <!-- Content -->\n      <div class=\"overflow-y-auto max-h-[calc(80vh-100px)] p-6\">\n        <!-- Summary Stats -->\n        <div class=\"grid grid-cols-1 md:grid-cols-3 gap-4 mb-6\">\n          <div class=\"bg-gray-800 rounded-lg p-4\">\n            <div class=\"text-xs text-gray-400 mb-1\">Average Power</div>\n            <SignalStrengthMeter power={cluster.stats.avgPower} compact={false} />\n          </div>\n          <div class=\"bg-gray-800 rounded-lg p-4\">\n            <div class=\"text-xs text-gray-400 mb-1\">Power Range</div>\n            <div class=\"text-white\">\n              {cluster.stats.minPower.toFixed(0)} to {cluster.stats.maxPower.toFixed(0)} dBm\n            </div>\n          </div>\n          <div class=\"bg-gray-800 rounded-lg p-4\">\n            <div class=\"text-xs text-gray-400 mb-1\">Time Span</div>\n            <div class=\"text-white\">\n              {new Date(cluster.stats.timeRange.start).toLocaleTimeString()} - \n              {new Date(cluster.stats.timeRange.end).toLocaleTimeString()}\n            </div>\n          </div>\n        </div>\n        \n        <!-- Signals by Type -->\n        <div class=\"space-y-4\">\n          {#each Object.entries(signalsByType) as [type, signals]}\n            <div class=\"bg-gray-800 rounded-lg p-4\">\n              <div class=\"flex items-center gap-2 mb-3\">\n                <SignalTypeIndicator signalType={type} size=\"medium\" />\n                <h3 class=\"text-lg font-semibold text-white capitalize\">{type}</h3>\n                <span class=\"text-sm text-gray-400\">({signals.length} signals)</span>\n              </div>\n              \n              <div class=\"grid grid-cols-1 md:grid-cols-2 gap-3\">\n                {#each signals as signal}\n                  <button\n                    on:click={() => selectSignal(signal)}\n                    class=\"bg-gray-700 hover:bg-gray-600 rounded-lg p-3 text-left transition-colors\">\n                    <div class=\"flex items-center justify-between mb-2\">\n                      <div class=\"text-sm text-white\">\n                        {(signal.frequency / 1000).toFixed(2)} GHz\n                      </div>\n                      <SignalStrengthMeter power={signal.power} compact={true} showLabel={false} />\n                    </div>\n                    <div class=\"text-xs text-gray-400\">\n                      {new Date(signal.timestamp).toLocaleTimeString()}\n                    </div>\n                  </button>\n                {/each}\n              </div>\n            </div>\n          {/each}\n        </div>\n      </div>\n      \n      <!-- Footer -->\n      <div class=\"bg-gray-800 px-6 py-3 border-t border-gray-700\">\n        <div class=\"flex justify-end gap-3\">\n          <button\n            on:click={close}\n            class=\"px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg transition-colors\">\n            Close\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n{/if}\n\n<style>\n  /* Ensure the panel is above map controls */\n  :global(.leaflet-control) {\n    z-index: 1000 !important;\n  }\n</style>",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/map/SignalFilterControls.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/map/SignalInfoCard.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/map/SignalList.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/map/SignalStrengthMeter.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/map/SignalTypeIndicator.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/components/map/TimeFilterControls.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/config/logging.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/config/mapConfig.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/server/db/cleanupService.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 381,
				"column": 14,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 381,
				"endColumn": 33
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 381,
				"column": 35,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 381,
				"endColumn": 52
			}
		],
		"suppressedMessages": [],
		"errorCount": 2,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "/**\n * Database Cleanup Service\n * Implements automatic cleanup, data aggregation, and maintenance tasks\n */\n\nimport Database from 'better-sqlite3';\nimport { readFileSync } from 'fs';\nimport { join, dirname } from 'path';\nimport { fileURLToPath } from 'url';\nimport type { Database as DatabaseType } from 'better-sqlite3';\nimport { logInfo, logError, logWarn as _logWarn } from '$lib/utils/logger';\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\n\ninterface CleanupConfig {\n  // Retention periods in milliseconds\n  hackrfRetention: number;      // High-frequency scan data\n  wifiRetention: number;        // WiFi/Kismet data\n  defaultRetention: number;     // Other signals\n  deviceRetention: number;      // Inactive devices\n  patternRetention: number;     // Pattern expiry\n  \n  // Aggregation intervals\n  aggregateHourly: boolean;\n  aggregateDaily: boolean;\n  \n  // Cleanup limits\n  batchSize: number;            // Records to process per batch\n  maxRuntime: number;           // Max cleanup runtime in ms\n  \n  // Schedule\n  cleanupInterval: number;      // How often to run cleanup (ms)\n  aggregateInterval: number;    // How often to run aggregation (ms)\n}\n\nexport class DatabaseCleanupService {\n  private db: DatabaseType;\n  private config: CleanupConfig;\n  private cleanupTimer?: ReturnType<typeof setTimeout>;\n  private aggregateTimer?: ReturnType<typeof setTimeout>;\n  private isRunning = false;\n  private statements: Map<string, Database.Statement> = new Map();\n\n  constructor(db: DatabaseType, config?: Partial<CleanupConfig>) {\n    this.db = db;\n    this.config = {\n      // Default retention periods\n      hackrfRetention: 60 * 60 * 1000,           // 1 hour (changed from 24 hours)\n      wifiRetention: 7 * 24 * 60 * 60 * 1000,   // 7 days\n      defaultRetention: 60 * 60 * 1000,          // 1 hour (changed from 3 days)\n      deviceRetention: 7 * 24 * 60 * 60 * 1000,  // 7 days\n      patternRetention: 24 * 60 * 60 * 1000,     // 24 hours\n      \n      // Aggregation\n      aggregateHourly: true,\n      aggregateDaily: true,\n      \n      // Performance limits\n      batchSize: 1000,\n      maxRuntime: 30000, // 30 seconds\n      \n      // Schedule\n      cleanupInterval: 60 * 60 * 1000,     // Every hour\n      aggregateInterval: 10 * 60 * 1000,   // Every 10 minutes\n      \n      ...config\n    };\n    \n    this.initializeMigrations();\n    this.prepareStatements();\n  }\n\n  /**\n   * Initialize database migrations\n   */\n  private initializeMigrations() {\n    try {\n      const migrationPath = join(__dirname, 'migrations', '001_add_cleanup_features.sql');\n      const migration = readFileSync(migrationPath, 'utf-8');\n      this.db.exec(migration);\n    } catch (error) {\n      logError('Failed to apply migrations', { error }, 'cleanup-migrations-failed');\n    }\n  }\n\n  /**\n   * Prepare reusable statements\n   */\n  private prepareStatements() {\n    // Cleanup statements\n    this.statements.set('deleteOldSignals', this.db.prepare(`\n      DELETE FROM signals \n      WHERE signal_id IN (\n        SELECT signal_id FROM signals_to_delete LIMIT ?\n      )\n    `));\n\n    this.statements.set('deleteInactiveDevices', this.db.prepare(`\n      DELETE FROM devices \n      WHERE device_id IN (\n        SELECT device_id FROM devices_to_delete LIMIT ?\n      )\n    `));\n\n    this.statements.set('deleteOrphanedRelationships', this.db.prepare(`\n      DELETE FROM relationships \n      WHERE id IN (\n        SELECT id FROM relationships_to_delete LIMIT ?\n      )\n    `));\n\n    this.statements.set('deleteExpiredPatterns', this.db.prepare(`\n      DELETE FROM patterns \n      WHERE pattern_id IN (\n        SELECT pattern_id FROM expired_patterns LIMIT ?\n      )\n    `));\n\n    // Aggregation statements\n    this.statements.set('aggregateHourlySignals', this.db.prepare(`\n      INSERT OR REPLACE INTO signal_stats_hourly (\n        hour_timestamp, total_signals, unique_devices, \n        avg_power, min_power, max_power, dominant_frequency, coverage_area\n      )\n      SELECT \n        CAST(timestamp / 3600000 AS INTEGER) * 3600000 as hour_timestamp,\n        COUNT(*) as total_signals,\n        COUNT(DISTINCT device_id) as unique_devices,\n        AVG(power) as avg_power,\n        MIN(power) as min_power,\n        MAX(power) as max_power,\n        MODE() WITHIN GROUP (ORDER BY frequency) as dominant_frequency,\n        (MAX(latitude) - MIN(latitude)) * (MAX(longitude) - MIN(longitude)) * 111 * 111 as coverage_area\n      FROM signals\n      WHERE timestamp >= ? AND timestamp < ?\n      GROUP BY CAST(timestamp / 3600000 AS INTEGER) * 3600000\n    `));\n\n    this.statements.set('aggregateDailyDevices', this.db.prepare(`\n      INSERT OR REPLACE INTO device_stats_daily (\n        day_timestamp, device_id, signal_count, avg_power,\n        freq_min, freq_max, first_seen_hour, last_seen_hour,\n        active_hours, avg_lat, avg_lon, movement_distance\n      )\n      SELECT \n        CAST(timestamp / 86400000 AS INTEGER) * 86400000 as day_timestamp,\n        device_id,\n        COUNT(*) as signal_count,\n        AVG(power) as avg_power,\n        MIN(frequency) as freq_min,\n        MAX(frequency) as freq_max,\n        MIN(CAST(timestamp / 3600000 AS INTEGER)) as first_seen_hour,\n        MAX(CAST(timestamp / 3600000 AS INTEGER)) as last_seen_hour,\n        COUNT(DISTINCT CAST(timestamp / 3600000 AS INTEGER)) as active_hours,\n        AVG(latitude) as avg_lat,\n        AVG(longitude) as avg_lon,\n        0 as movement_distance -- TODO: Calculate actual movement\n      FROM signals\n      WHERE timestamp >= ? AND timestamp < ?\n      GROUP BY CAST(timestamp / 86400000 AS INTEGER) * 86400000, device_id\n    `));\n\n    this.statements.set('aggregateSpatialHeatmap', this.db.prepare(`\n      INSERT OR REPLACE INTO spatial_heatmap_hourly (\n        hour_timestamp, grid_lat, grid_lon, signal_count,\n        unique_devices, avg_power, dominant_source\n      )\n      SELECT \n        CAST(timestamp / 3600000 AS INTEGER) * 3600000 as hour_timestamp,\n        CAST(latitude * 10000 AS INTEGER) as grid_lat,\n        CAST(longitude * 10000 AS INTEGER) as grid_lon,\n        COUNT(*) as signal_count,\n        COUNT(DISTINCT device_id) as unique_devices,\n        AVG(power) as avg_power,\n        MODE() WITHIN GROUP (ORDER BY source) as dominant_source\n      FROM signals\n      WHERE timestamp >= ? AND timestamp < ?\n      GROUP BY \n        CAST(timestamp / 3600000 AS INTEGER) * 3600000,\n        CAST(latitude * 10000 AS INTEGER),\n        CAST(longitude * 10000 AS INTEGER)\n    `));\n  }\n\n  /**\n   * Start automatic cleanup and aggregation\n   */\n  start() {\n    if (this.isRunning) return;\n    \n    this.isRunning = true;\n    \n    // Run initial cleanup\n    void this.runCleanup();\n    void this.runAggregation();\n    \n    // Schedule periodic cleanup\n    this.cleanupTimer = setInterval(() => {\n      void this.runCleanup();\n    }, this.config.cleanupInterval);\n    \n    // Schedule periodic aggregation\n    this.aggregateTimer = setInterval(() => {\n      void this.runAggregation();\n    }, this.config.aggregateInterval);\n    \n    logInfo('Database cleanup service started', {}, 'cleanup-service-started');\n  }\n\n  /**\n   * Stop automatic cleanup\n   */\n  stop() {\n    this.isRunning = false;\n    \n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = undefined;\n    }\n    \n    if (this.aggregateTimer) {\n      clearInterval(this.aggregateTimer);\n      this.aggregateTimer = undefined;\n    }\n    \n    logInfo('Database cleanup service stopped', {}, 'cleanup-service-stopped');\n  }\n\n  /**\n   * Run cleanup tasks\n   */\n  runCleanup() {\n    const startTime = Date.now();\n    const stats = {\n      signals: 0,\n      devices: 0,\n      relationships: 0,\n      patterns: 0,\n      duration: 0\n    };\n\n    try {\n      // Use transaction for consistency\n      const cleanup = this.db.transaction(() => {\n        // Delete old signals\n        const signalStmt = this.statements.get('deleteOldSignals');\n        if (!signalStmt) throw new Error('deleteOldSignals statement not found');\n        let result = signalStmt.run(this.config.batchSize);\n        stats.signals = result.changes;\n        \n        // Keep deleting in batches until done or timeout\n        while (result.changes > 0 && (Date.now() - startTime) < this.config.maxRuntime) {\n          result = signalStmt.run(this.config.batchSize);\n          stats.signals += result.changes;\n        }\n        \n        // Delete inactive devices\n        const deviceStmt = this.statements.get('deleteInactiveDevices');\n        if (!deviceStmt) throw new Error('deleteInactiveDevices statement not found');\n        result = deviceStmt.run(this.config.batchSize);\n        stats.devices = result.changes;\n        \n        // Delete orphaned relationships\n        const relStmt = this.statements.get('deleteOrphanedRelationships');\n        if (!relStmt) throw new Error('deleteOrphanedRelationships statement not found');\n        result = relStmt.run(this.config.batchSize);\n        stats.relationships = result.changes;\n        \n        // Delete expired patterns\n        const patternStmt = this.statements.get('deleteExpiredPatterns');\n        if (!patternStmt) throw new Error('deleteExpiredPatterns statement not found');\n        result = patternStmt.run(this.config.batchSize);\n        stats.patterns = result.changes;\n      });\n      \n      cleanup();\n      \n      // Run VACUUM if significant data was deleted\n      if (stats.signals + stats.devices > 1000) {\n        this.db.exec('VACUUM');\n      }\n      \n      stats.duration = Date.now() - startTime;\n      logInfo('Cleanup completed', { stats }, 'cleanup-completed');\n      \n      return stats;\n    } catch (error) {\n      logError('Cleanup failed', { error }, 'cleanup-failed');\n      throw error;\n    }\n  }\n\n  /**\n   * Run aggregation tasks\n   */\n  runAggregation() {\n    const now = Date.now();\n    const currentHour = Math.floor(now / 3600000) * 3600000;\n    const currentDay = Math.floor(now / 86400000) * 86400000;\n    \n    try {\n      const aggregate = this.db.transaction(() => {\n        if (this.config.aggregateHourly) {\n          // Aggregate last complete hour\n          const lastHour = currentHour - 3600000;\n          \n          // Signal statistics\n          const hourlyStmt = this.statements.get('aggregateHourlySignals');\n          if (!hourlyStmt) throw new Error('aggregateHourlySignals statement not found');\n          hourlyStmt.run(lastHour, currentHour);\n          \n          // Spatial heatmap\n          const spatialStmt = this.statements.get('aggregateSpatialHeatmap');\n          if (!spatialStmt) throw new Error('aggregateSpatialHeatmap statement not found');\n          spatialStmt.run(lastHour, currentHour);\n        }\n        \n        if (this.config.aggregateDaily) {\n          // Aggregate last complete day\n          const lastDay = currentDay - 86400000;\n          \n          // Device statistics\n          const dailyStmt = this.statements.get('aggregateDailyDevices');\n          if (!dailyStmt) throw new Error('aggregateDailyDevices statement not found');\n          dailyStmt.run(lastDay, currentDay);\n        }\n      });\n      \n      aggregate();\n      logInfo('Aggregation completed', {}, 'aggregation-completed');\n    } catch (error) {\n      logError('Aggregation failed', { error }, 'aggregation-failed');\n    }\n  }\n\n  /**\n   * Get cleanup statistics\n   */\n  getStats() {\n    const stats = this.db.prepare(`\n      SELECT \n        (SELECT COUNT(*) FROM signals) as total_signals,\n        (SELECT COUNT(*) FROM signals_to_delete) as signals_to_delete,\n        (SELECT COUNT(*) FROM devices) as total_devices,\n        (SELECT COUNT(*) FROM devices_to_delete) as devices_to_delete,\n        (SELECT COUNT(*) FROM relationships) as total_relationships,\n        (SELECT COUNT(*) FROM relationships_to_delete) as relationships_to_delete,\n        (SELECT COUNT(*) FROM patterns) as total_patterns,\n        (SELECT COUNT(*) FROM expired_patterns) as patterns_to_delete,\n        (SELECT SUM(row_count) FROM table_sizes) as total_records\n    `).get();\n    \n    return stats;\n  }\n\n  /**\n   * Get data growth trends\n   */\n  getGrowthTrends(hours: number = 24) {\n    const trends = this.db.prepare(`\n      SELECT * FROM data_growth_hourly \n      ORDER BY hour DESC \n      LIMIT ?\n    `).all(hours);\n    \n    return trends;\n  }\n\n  /**\n   * Manual vacuum\n   */\n  vacuum() {\n    logInfo('Running VACUUM', {}, 'vacuum-start');\n    const before = this.db.prepare(\"SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size()\").get();\n    this.db.exec('VACUUM');\n    const after = this.db.prepare(\"SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size()\").get();\n    \n    const saved = (before.size - after.size) / 1024 / 1024;\n    logInfo('VACUUM completed', { spaceSavedMB: saved.toFixed(2) }, 'vacuum-completed');\n    \n    return { before: before.size, after: after.size, saved };\n  }\n\n  /**\n   * Analyze database and update statistics\n   */\n  analyze() {\n    this.db.exec('ANALYZE');\n    logInfo('Database statistics updated', {}, 'database-analyze-completed');\n  }\n\n  /**\n   * Export aggregated data for analysis\n   */\n  exportAggregatedData(startTime: number, endTime: number) {\n    const hourlyStats = this.db.prepare(`\n      SELECT * FROM signal_stats_hourly\n      WHERE hour_timestamp >= ? AND hour_timestamp <= ?\n      ORDER BY hour_timestamp\n    `).all(startTime, endTime);\n    \n    const dailyDevices = this.db.prepare(`\n      SELECT * FROM device_stats_daily\n      WHERE day_timestamp >= ? AND day_timestamp <= ?\n      ORDER BY day_timestamp, device_id\n    `).all(startTime, endTime);\n    \n    const spatialData = this.db.prepare(`\n      SELECT * FROM spatial_heatmap_hourly\n      WHERE hour_timestamp >= ? AND hour_timestamp <= ?\n      ORDER BY hour_timestamp, grid_lat, grid_lon\n    `).all(startTime, endTime);\n    \n    return {\n      hourlyStats,\n      dailyDevices,\n      spatialData\n    };\n  }\n\n  /**\n   * Cleanup old aggregated data\n   */\n  cleanupAggregatedData(daysToKeep: number = 30) {\n    const cutoff = Date.now() - (daysToKeep * 24 * 60 * 60 * 1000);\n    \n    const cleanup = this.db.transaction(() => {\n      this.db.prepare('DELETE FROM signal_stats_hourly WHERE hour_timestamp < ?').run(cutoff);\n      this.db.prepare('DELETE FROM device_stats_daily WHERE day_timestamp < ?').run(cutoff);\n      this.db.prepare('DELETE FROM network_stats_daily WHERE day_timestamp < ?').run(cutoff);\n      this.db.prepare('DELETE FROM spatial_heatmap_hourly WHERE hour_timestamp < ?').run(cutoff);\n    });\n    \n    cleanup();\n    logInfo('Cleaned up aggregated data', { daysToKeep }, 'aggregated-data-cleanup-completed');\n  }\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/server/db/database.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 236,
				"column": 11,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 236,
				"endColumn": 33
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .includes on an `error` typed value.",
				"line": 236,
				"column": 25,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 236,
				"endColumn": 33
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-return",
				"severity": 2,
				"message": "Unsafe return of a value of type `any[]`.",
				"line": 369,
				"column": 5,
				"nodeType": "ReturnStatement",
				"messageId": "unsafeReturn",
				"endLine": 375,
				"endColumn": 17
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 375,
				"column": 11,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 375,
				"endColumn": 14,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [11802, 11805], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [11802, 11805], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 443,
				"column": 17,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 443,
				"endColumn": 20,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [13897, 13900], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [13897, 13900], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe spread of an `any[]` array type.",
				"line": 454,
				"column": 21,
				"nodeType": "SpreadElement",
				"messageId": "unsafeArraySpread",
				"endLine": 454,
				"endColumn": 30
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 561,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 561,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 561,
				"column": 34,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 561,
				"endColumn": 37,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [17766, 17769], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [17766, 17769], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 562,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 562,
				"endColumn": 71
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-return",
				"severity": 2,
				"message": "Unsafe return of a value of type error.",
				"line": 634,
				"column": 37,
				"nodeType": "CallExpression",
				"messageId": "unsafeReturn",
				"endLine": 634,
				"endColumn": 52
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 634,
				"column": 37,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 634,
				"endColumn": 50
			}
		],
		"suppressedMessages": [],
		"errorCount": 8,
		"fatalErrorCount": 0,
		"warningCount": 3,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "/**\n * SQLite Database Service for RF Signal Storage\n * Provides efficient spatial queries and relationship tracking\n */\n\nimport Database from 'better-sqlite3';\nimport { readFileSync } from 'fs';\nimport { join } from 'path';\nimport type { SignalMarker } from '$lib/stores/map/signals';\nimport type { NetworkNode, NetworkEdge } from '$lib/services/map/networkAnalyzer';\nimport type { Pattern as _Pattern } from '$lib/services/map/aiPatternDetector';\nimport { DatabaseCleanupService } from './cleanupService';\nimport { runMigrations } from './migrations/runMigrations';\nimport { logError, logWarn, logInfo } from '$lib/utils/logger';\n\nexport interface DbSignal {\n  id?: number;\n  signal_id: string;\n  device_id?: string;\n  timestamp: number;\n  latitude: number;\n  longitude: number;\n  power: number;\n  frequency: number;\n  bandwidth?: number;\n  modulation?: string;\n  source: string;\n  metadata?: string;\n}\n\nexport interface DbDevice {\n  id?: number;\n  device_id: string;\n  type: string;\n  manufacturer?: string;\n  first_seen: number;\n  last_seen: number;\n  avg_power?: number;\n  freq_min?: number;\n  freq_max?: number;\n  metadata?: string;\n}\n\nexport interface DbNetwork {\n  id?: number;\n  network_id: string;\n  name?: string;\n  type: string;\n  encryption?: string;\n  channel?: number;\n  first_seen: number;\n  last_seen: number;\n  center_lat?: number;\n  center_lon?: number;\n  radius?: number;\n}\n\nexport interface DbRelationship {\n  id?: number;\n  source_device_id: string;\n  target_device_id: string;\n  network_id?: string;\n  relationship_type: string;\n  strength?: number;\n  first_seen: number;\n  last_seen: number;\n}\n\nexport interface SpatialQuery {\n  lat: number;\n  lon: number;\n  radiusMeters: number;\n}\n\nexport interface TimeQuery {\n  startTime?: number;\n  endTime?: number;\n  limit?: number;\n}\n\nclass RFDatabase {\n  private db: Database.Database;\n  private statements: Map<string, Database.Statement> = new Map();\n  private cleanupService: DatabaseCleanupService | null = null;\n\n  constructor(dbPath: string = './rf_signals.db') {\n    // Initialize database\n    this.db = new Database(dbPath);\n    this.db.pragma('journal_mode = WAL'); // Write-Ahead Logging for better concurrency\n    this.db.pragma('synchronous = NORMAL'); // Balance between safety and speed\n    \n    // Load and execute schema\n    try {\n      const schemaPath = join(process.cwd(), 'src/lib/server/db/schema.sql');\n      const schema = readFileSync(schemaPath, 'utf-8');\n      this.db.exec(schema);\n    } catch (error) {\n      logError('Failed to load schema, using embedded version', { error }, 'schema-load-failed');\n      this.initializeSchema();\n    }\n    \n    // Run migrations to update schema\n    try {\n      const migrationsPath = join(process.cwd(), 'src/lib/server/db/migrations');\n      runMigrations(this.db, migrationsPath);\n    } catch (error) {\n      logWarn('Could not run migrations', { error }, 'migrations-failed');\n    }\n    \n    // Prepare frequently used statements\n    this.prepareStatements();\n    \n    // Initialize and start cleanup service\n    this.initializeCleanupService();\n  }\n\n  private initializeSchema() {\n    // Embedded schema as fallback\n    this.db.exec(`\n      PRAGMA foreign_keys = ON;\n      \n      CREATE TABLE IF NOT EXISTS devices (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        device_id TEXT UNIQUE NOT NULL,\n        type TEXT NOT NULL,\n        manufacturer TEXT,\n        first_seen INTEGER NOT NULL,\n        last_seen INTEGER NOT NULL,\n        avg_power REAL,\n        freq_min REAL,\n        freq_max REAL,\n        metadata TEXT\n      );\n      \n      CREATE TABLE IF NOT EXISTS signals (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        signal_id TEXT UNIQUE NOT NULL,\n        device_id TEXT,\n        timestamp INTEGER NOT NULL,\n        latitude REAL NOT NULL,\n        longitude REAL NOT NULL,\n        power REAL NOT NULL,\n        frequency REAL NOT NULL,\n        bandwidth REAL,\n        modulation TEXT,\n        source TEXT NOT NULL,\n        metadata TEXT,\n        FOREIGN KEY (device_id) REFERENCES devices(device_id)\n      );\n      \n      CREATE INDEX IF NOT EXISTS idx_signals_timestamp ON signals(timestamp);\n      CREATE INDEX IF NOT EXISTS idx_signals_location ON signals(latitude, longitude);\n      CREATE INDEX IF NOT EXISTS idx_signals_spatial_grid ON signals(\n        CAST(latitude * 10000 AS INTEGER), \n        CAST(longitude * 10000 AS INTEGER)\n      );\n    `);\n  }\n\n  private prepareStatements() {\n    // Insert statements\n    this.statements.set('insertSignal', this.db.prepare(`\n      INSERT INTO signals (\n        signal_id, device_id, timestamp, latitude, longitude,\n        power, frequency, bandwidth, modulation, source, metadata\n      ) VALUES (\n        @signal_id, @device_id, @timestamp, @latitude, @longitude,\n        @power, @frequency, @bandwidth, @modulation, @source, @metadata\n      )\n    `));\n\n    this.statements.set('insertDevice', this.db.prepare(`\n      INSERT OR REPLACE INTO devices (\n        device_id, type, manufacturer, first_seen, last_seen,\n        avg_power, freq_min, freq_max, metadata\n      ) VALUES (\n        @device_id, @type, @manufacturer, @first_seen, @last_seen,\n        @avg_power, @freq_min, @freq_max, @metadata\n      )\n    `));\n\n    // Spatial queries\n    this.statements.set('findSignalsInRadius', this.db.prepare(`\n      SELECT * FROM signals\n      WHERE CAST(latitude * 10000 AS INTEGER) BETWEEN @lat_min AND @lat_max\n        AND CAST(longitude * 10000 AS INTEGER) BETWEEN @lon_min AND @lon_max\n        AND timestamp > @since\n      ORDER BY timestamp DESC\n      LIMIT @limit\n    `));\n\n    this.statements.set('findNearbyDevices', this.db.prepare(`\n      SELECT DISTINCT d.*, \n        AVG(s.latitude) as avg_lat, \n        AVG(s.longitude) as avg_lon,\n        COUNT(s.id) as signal_count\n      FROM devices d\n      JOIN signals s ON d.device_id = s.device_id\n      WHERE CAST(s.latitude * 10000 AS INTEGER) BETWEEN @lat_min AND @lat_max\n        AND CAST(s.longitude * 10000 AS INTEGER) BETWEEN @lon_min AND @lon_max\n        AND s.timestamp > @since\n      GROUP BY d.device_id\n    `));\n  }\n\n  /**\n   * Insert or update a signal\n   */\n  insertSignal(signal: SignalMarker): DbSignal {\n    const dbSignal: DbSignal = {\n      signal_id: signal.id,\n      device_id: this.generateDeviceId(signal),\n      timestamp: signal.timestamp,\n      latitude: signal.lat,\n      longitude: signal.lon,\n      power: signal.power,\n      frequency: signal.frequency,\n      source: signal.source,\n      metadata: signal.metadata ? JSON.stringify(signal.metadata) : undefined\n    };\n\n    try {\n      // First ensure device exists\n      this.ensureDeviceExists(dbSignal);\n      \n      const stmt = this.statements.get('insertSignal');\n      if (!stmt) throw new Error('Insert signal statement not found');\n      const info = stmt.run(dbSignal);\n      dbSignal.id = info.lastInsertRowid as number;\n      \n      // Update device info\n      this.updateDeviceFromSignal(dbSignal);\n      \n      return dbSignal;\n    } catch (error) {\n      if (error.message.includes('UNIQUE constraint failed')) {\n        // Signal already exists, update it\n        return this.updateSignal(dbSignal);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Batch insert signals\n   */\n  insertSignalsBatch(signals: SignalMarker[]): number {\n    const insertSignal = this.statements.get('insertSignal');\n    if (!insertSignal) throw new Error('Insert signal statement not found');\n    const insertMany = this.db.transaction((signals: DbSignal[]) => {\n      let successCount = 0;\n      for (const signal of signals) {\n        try {\n          insertSignal.run(signal);\n          successCount++;\n        } catch (err) {\n          // Log error but continue with other signals\n          const error = err as Error;\n          if (!error.message?.includes('UNIQUE constraint failed')) {\n            logError('Failed to insert signal', { signalId: signal.signal_id, error: error.message }, 'signal-insert-failed');\n          }\n        }\n      }\n      return successCount;\n    });\n\n    const dbSignals: DbSignal[] = signals.map(signal => ({\n      signal_id: signal.id,\n      device_id: this.generateDeviceId(signal),\n      timestamp: signal.timestamp,\n      latitude: signal.lat,\n      longitude: signal.lon,\n      power: signal.power,\n      frequency: signal.frequency,\n      bandwidth: signal.metadata?.bandwidth || null,\n      modulation: signal.metadata?.modulation || null,\n      source: signal.source,\n      metadata: signal.metadata ? JSON.stringify(signal.metadata) : null\n    }));\n\n    // Ensure all devices exist first\n    const ensureDevices = this.db.transaction(() => {\n      const processedDevices = new Set<string>();\n      for (const dbSignal of dbSignals) {\n        if (dbSignal.device_id && !processedDevices.has(dbSignal.device_id)) {\n          this.ensureDeviceExists(dbSignal);\n          processedDevices.add(dbSignal.device_id);\n        }\n      }\n    });\n    \n    ensureDevices();\n\n    try {\n      const successCount = insertMany(dbSignals);\n      \n      // Update devices for successfully inserted signals\n      const updateDevices = this.db.transaction(() => {\n        const processedDevices = new Set<string>();\n        for (const dbSignal of dbSignals) {\n          if (dbSignal.device_id && !processedDevices.has(dbSignal.device_id)) {\n            this.updateDeviceFromSignal(dbSignal);\n            processedDevices.add(dbSignal.device_id);\n          }\n        }\n      });\n      \n      updateDevices();\n      \n      return successCount;\n    } catch (error) {\n      logError('Batch insert transaction failed', { error }, 'batch-insert-failed');\n      throw error;\n    }\n  }\n\n  /**\n   * Find signals within radius of a point\n   */\n  findSignalsInRadius(query: SpatialQuery & TimeQuery): SignalMarker[] {\n    // Convert radius to grid units (approximately)\n    const latRange = query.radiusMeters / 111320; // meters per degree\n    const lonRange = query.radiusMeters / (111320 * Math.cos(query.lat * Math.PI / 180));\n    \n    const lat_min = Math.floor((query.lat - latRange) * 10000);\n    const lat_max = Math.ceil((query.lat + latRange) * 10000);\n    const lon_min = Math.floor((query.lon - lonRange) * 10000);\n    const lon_max = Math.ceil((query.lon + lonRange) * 10000);\n    \n    const stmt = this.statements.get('findSignalsInRadius');\n    if (!stmt) throw new Error('Find signals in radius statement not found');\n    const rows = stmt.all({\n      lat_min,\n      lat_max,\n      lon_min,\n      lon_max,\n      since: query.startTime || 0,\n      limit: query.limit || 1000\n    }) as DbSignal[];\n\n    // Convert to SignalMarker format and filter by exact distance\n    return rows\n      .map(row => this.dbSignalToMarker(row))\n      .filter(signal => {\n        const distance = this.calculateDistance(\n          signal.lat,\n          signal.lon,\n          query.lat,\n          query.lon\n        );\n        return distance <= query.radiusMeters;\n      });\n  }\n\n  /**\n   * Find devices near a location\n   */\n  findDevicesNearby(query: SpatialQuery & TimeQuery): Array<DbDevice & { avg_lat: number; avg_lon: number; signal_count: number }> {\n    const latRange = query.radiusMeters / 111320;\n    const lonRange = query.radiusMeters / (111320 * Math.cos(query.lat * Math.PI / 180));\n    \n    const lat_min = Math.floor((query.lat - latRange) * 10000);\n    const lat_max = Math.ceil((query.lat + latRange) * 10000);\n    const lon_min = Math.floor((query.lon - lonRange) * 10000);\n    const lon_max = Math.ceil((query.lon + lonRange) * 10000);\n    \n    const stmt = this.statements.get('findNearbyDevices');\n    if (!stmt) throw new Error('Find nearby devices statement not found');\n    return stmt.all({\n      lat_min,\n      lat_max,\n      lon_min,\n      lon_max,\n      since: query.startTime || Date.now() - 300000 // Default: last 5 minutes\n    }) as any[];\n  }\n\n  /**\n   * Get signal statistics for an area\n   */\n  getAreaStatistics(bounds: { minLat: number; maxLat: number; minLon: number; maxLon: number }, timeWindow: number = 3600000) {\n    const stmt = this.db.prepare(`\n      SELECT \n        COUNT(DISTINCT signal_id) as total_signals,\n        COUNT(DISTINCT device_id) as unique_devices,\n        AVG(power) as avg_power,\n        MIN(power) as min_power,\n        MAX(power) as max_power,\n        MIN(frequency) as min_freq,\n        MAX(frequency) as max_freq,\n        COUNT(DISTINCT ROUND(frequency/100)*100) as freq_bands\n      FROM signals\n      WHERE latitude BETWEEN @minLat AND @maxLat\n        AND longitude BETWEEN @minLon AND @maxLon\n        AND timestamp > @since\n    `);\n\n    return stmt.get({\n      minLat: bounds.minLat,\n      maxLat: bounds.maxLat,\n      minLon: bounds.minLon,\n      maxLon: bounds.maxLon,\n      since: Date.now() - timeWindow\n    });\n  }\n\n  /**\n   * Store network relationships\n   */\n  storeNetworkGraph(nodes: Map<string, NetworkNode>, edges: Map<string, NetworkEdge>) {\n    const insertRelationship = this.db.prepare(`\n      INSERT OR REPLACE INTO relationships (\n        source_device_id, target_device_id, network_id,\n        relationship_type, strength, first_seen, last_seen\n      ) VALUES (\n        @source_device_id, @target_device_id, @network_id,\n        @relationship_type, @strength, @first_seen, @last_seen\n      )\n    `);\n\n    const storeGraph = this.db.transaction(() => {\n      edges.forEach(edge => {\n        insertRelationship.run({\n          source_device_id: edge.source,\n          target_device_id: edge.target,\n          network_id: null, // TODO: Implement network detection\n          relationship_type: edge.type,\n          strength: edge.strength,\n          first_seen: edge.metadata.lastSeen,\n          last_seen: edge.metadata.lastSeen\n        });\n      });\n    });\n\n    storeGraph();\n  }\n\n  /**\n   * Get network relationships for visualization\n   */\n  getNetworkRelationships(deviceIds?: string[]): DbRelationship[] {\n    let query = `SELECT * FROM relationships`;\n    let params: any[] = [];\n    \n    if (deviceIds && deviceIds.length > 0) {\n      query += ` WHERE source_device_id IN (${deviceIds.map(() => '?').join(',')})\n                    OR target_device_id IN (${deviceIds.map(() => '?').join(',')})`;\n      params = [...deviceIds, ...deviceIds];\n    }\n    \n    query += ` ORDER BY last_seen DESC LIMIT 1000`;\n    \n    const stmt = this.db.prepare(query);\n    return stmt.all(...params) as DbRelationship[];\n  }\n\n  /**\n   * Helper methods\n   */\n  private generateDeviceId(signal: SignalMarker): string {\n    // Generate a device ID based on signal characteristics\n    // In real implementation, this would use MAC address or other unique identifier\n    return `${signal.metadata?.type || 'unknown'}_${Math.floor(signal.frequency)}_${Math.floor(signal.power / 10) * 10}`;\n  }\n\n  private ensureDeviceExists(signal: DbSignal) {\n    const existing = this.db.prepare('SELECT * FROM devices WHERE device_id = ?').get(signal.device_id);\n    \n    if (!existing) {\n      // Create new device\n      const deviceType = this.detectDeviceType(signal);\n      this.db.prepare(`\n        INSERT INTO devices (\n          device_id, type, first_seen, last_seen,\n          avg_power, freq_min, freq_max\n        ) VALUES (\n          @device_id, @type, @timestamp, @timestamp,\n          @power, @frequency, @frequency\n        )\n      `).run({\n        device_id: signal.device_id,\n        type: deviceType,\n        timestamp: signal.timestamp,\n        power: signal.power,\n        frequency: signal.frequency\n      });\n    }\n  }\n  \n  private detectDeviceType(signal: DbSignal): string {\n    // Simple device type detection based on frequency\n    const freq = signal.frequency;\n    if (freq >= 2400 && freq <= 2500) return 'wifi';\n    if (freq >= 5150 && freq <= 5850) return 'wifi';\n    if (freq >= 2400 && freq <= 2485) return 'bluetooth';\n    if (freq >= 800 && freq <= 900) return 'cellular';\n    if (freq >= 1800 && freq <= 1900) return 'cellular';\n    return 'unknown';\n  }\n\n  private updateDeviceFromSignal(signal: DbSignal) {\n    const stmt = this.statements.get('insertDevice');\n    if (!stmt) throw new Error('Insert device statement not found');\n    \n    const existing = this.db.prepare('SELECT * FROM devices WHERE device_id = ?').get(signal.device_id);\n    \n    if (existing) {\n      // Update existing device\n      // Use the trigger for average calculation or compute a simple running average\n      this.db.prepare(`\n        UPDATE devices SET\n          last_seen = @timestamp,\n          avg_power = (avg_power + @power) / 2,\n          freq_min = MIN(freq_min, @frequency),\n          freq_max = MAX(freq_max, @frequency)\n        WHERE device_id = @device_id\n      `).run({\n        device_id: signal.device_id,\n        timestamp: signal.timestamp,\n        power: signal.power,\n        frequency: signal.frequency\n      });\n    } else {\n      // Insert new device\n      stmt.run({\n        device_id: signal.device_id,\n        type: this.detectDeviceType(signal),\n        manufacturer: null, // TODO: OUI lookup\n        first_seen: signal.timestamp,\n        last_seen: signal.timestamp,\n        avg_power: signal.power,\n        freq_min: signal.frequency,\n        freq_max: signal.frequency,\n        metadata: signal.metadata\n      });\n    }\n  }\n\n  private updateSignal(signal: DbSignal): DbSignal {\n    this.db.prepare(`\n      UPDATE signals SET\n        timestamp = @timestamp,\n        latitude = @latitude,\n        longitude = @longitude,\n        power = @power\n      WHERE signal_id = @signal_id\n    `).run(signal);\n    \n    return signal;\n  }\n\n\n  private dbSignalToMarker(dbSignal: DbSignal): SignalMarker {\n    return {\n      id: dbSignal.signal_id,\n      lat: dbSignal.latitude,\n      lon: dbSignal.longitude,\n      power: dbSignal.power,\n      frequency: dbSignal.frequency,\n      timestamp: dbSignal.timestamp,\n      source: dbSignal.source as any,\n      metadata: dbSignal.metadata ? JSON.parse(dbSignal.metadata) : {}\n    };\n  }\n\n  private calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n    const R = 6371e3;\n    const φ1 = lat1 * Math.PI / 180;\n    const φ2 = lat2 * Math.PI / 180;\n    const Δφ = (lat2 - lat1) * Math.PI / 180;\n    const Δλ = (lon2 - lon1) * Math.PI / 180;\n\n    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +\n              Math.cos(φ1) * Math.cos(φ2) *\n              Math.sin(Δλ/2) * Math.sin(Δλ/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\n    return R * c;\n  }\n\n  /**\n   * Initialize cleanup service\n   */\n  private initializeCleanupService() {\n    try {\n      this.cleanupService = new DatabaseCleanupService(this.db, {\n        // Configure for 1-hour retention for signal data\n        hackrfRetention: 60 * 60 * 1000,           // 1 hour\n        wifiRetention: 7 * 24 * 60 * 60 * 1000,   // 7 days\n        defaultRetention: 60 * 60 * 1000,          // 1 hour\n        deviceRetention: 7 * 24 * 60 * 60 * 1000,  // 7 days\n        patternRetention: 24 * 60 * 60 * 1000,     // 24 hours\n        cleanupInterval: 60 * 60 * 1000,           // Run every hour\n        aggregateInterval: 10 * 60 * 1000,         // Aggregate every 10 minutes\n        batchSize: 500,                            // Smaller batches for Pi\n        maxRuntime: 20000                          // 20 second max runtime\n      });\n      \n      // Start automatic cleanup\n      this.cleanupService.start();\n      logInfo('Database cleanup service initialized and started', {}, 'cleanup-service-started');\n    } catch (error) {\n      logError('Failed to initialize cleanup service', { error }, 'cleanup-service-init-failed');\n    }\n  }\n\n  /**\n   * Get cleanup service for manual operations\n   */\n  getCleanupService(): DatabaseCleanupService | null {\n    return this.cleanupService;\n  }\n\n  /**\n   * Get raw database instance for advanced operations\n   */\n  get rawDb(): Database.Database {\n    return this.db;\n  }\n\n  /**\n   * Cleanup and optimization\n   */\n  vacuum() {\n    this.db.exec('VACUUM');\n  }\n\n  close() {\n    // Stop cleanup service\n    if (this.cleanupService) {\n      this.cleanupService.stop();\n    }\n    \n    this.statements.forEach(stmt => stmt.finalize());\n    this.db.close();\n  }\n}\n\n// Singleton instance\nlet dbInstance: RFDatabase | null = null;\n\nexport function getRFDatabase(): RFDatabase {\n  if (!dbInstance) {\n    dbInstance = new RFDatabase();\n  }\n  return dbInstance;\n}\n\n// Cleanup on process termination\nprocess.on('SIGTERM', () => {\n  logInfo('SIGTERM received, closing database', {}, 'sigterm-database-close');\n  if (dbInstance) {\n    dbInstance.close();\n    dbInstance = null;\n  }\n});\n\nprocess.on('SIGINT', () => {\n  logInfo('SIGINT received, closing database', {}, 'sigint-database-close');\n  if (dbInstance) {\n    dbInstance.close();\n    dbInstance = null;\n  }\n});",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/server/db/dbOptimizer.ts",
		"messages": [
			{
				"ruleId": "no-console",
				"severity": 1,
				"message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
				"line": 106,
				"column": 5,
				"nodeType": "MemberExpression",
				"messageId": "limited",
				"endLine": 106,
				"endColumn": 16,
				"suggestions": [
					{
						"fix": { "range": [3000, 3046], "text": "" },
						"messageId": "removeConsole",
						"data": { "propertyName": "log" },
						"desc": "Remove the console.log()."
					}
				]
			},
			{
				"ruleId": "no-console",
				"severity": 1,
				"message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
				"line": 113,
				"column": 5,
				"nodeType": "MemberExpression",
				"messageId": "limited",
				"endLine": 113,
				"endColumn": 16,
				"suggestions": [
					{
						"fix": { "range": [3115, 3152], "text": "" },
						"messageId": "removeConsole",
						"data": { "propertyName": "log" },
						"desc": "Remove the console.log()."
					}
				]
			},
			{
				"ruleId": "no-console",
				"severity": 1,
				"message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
				"line": 117,
				"column": 5,
				"nodeType": "MemberExpression",
				"messageId": "limited",
				"endLine": 117,
				"endColumn": 16,
				"suggestions": [
					{
						"fix": { "range": [3257, 3308], "text": "" },
						"messageId": "removeConsole",
						"data": { "propertyName": "log" },
						"desc": "Remove the console.log()."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 138,
				"column": 36,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 138,
				"endColumn": 39,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [3694, 3697], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [3694, 3697], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'e' is defined but never used.",
				"line": 144,
				"column": 16,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 144,
				"endColumn": 17
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type error typed assigned to a parameter of type `string`.",
				"line": 170,
				"column": 42,
				"nodeType": "MemberExpression",
				"messageId": "unsafeArgument",
				"endLine": 170,
				"endColumn": 58
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type error typed assigned to a parameter of type `string`.",
				"line": 170,
				"column": 60,
				"nodeType": "MemberExpression",
				"messageId": "unsafeArgument",
				"endLine": 170,
				"endColumn": 76
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-return",
				"severity": 2,
				"message": "Unsafe return of a value of type error.",
				"line": 172,
				"column": 7,
				"nodeType": "ReturnStatement",
				"messageId": "unsafeReturn",
				"endLine": 177,
				"endColumn": 9
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'indexName' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 192,
				"column": 46,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 192,
				"endColumn": 55
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'commonQueries' is assigned a value but never used. Allowed unused vars must match /^_/u.",
				"line": 194,
				"column": 11,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 194,
				"endColumn": 24
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 241,
				"column": 11,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 241,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 242,
				"column": 11,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 242,
				"endColumn": 33
			},
			{
				"ruleId": "no-console",
				"severity": 1,
				"message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
				"line": 259,
				"column": 5,
				"nodeType": "MemberExpression",
				"messageId": "limited",
				"endLine": 259,
				"endColumn": 16,
				"suggestions": [
					{
						"fix": { "range": [6863, 6909], "text": "" },
						"messageId": "removeConsole",
						"data": { "propertyName": "log" },
						"desc": "Remove the console.log()."
					}
				]
			},
			{
				"ruleId": "no-console",
				"severity": 1,
				"message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
				"line": 279,
				"column": 5,
				"nodeType": "MemberExpression",
				"messageId": "limited",
				"endLine": 279,
				"endColumn": 16,
				"suggestions": [
					{
						"fix": { "range": [7395, 7439], "text": "" },
						"messageId": "removeConsole",
						"data": { "propertyName": "log" },
						"desc": "Remove the console.log()."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 285,
				"column": 39,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 285,
				"endColumn": 42,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [7525, 7528], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [7525, 7528], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe spread of an `any[]` array type.",
				"line": 287,
				"column": 71,
				"nodeType": "SpreadElement",
				"messageId": "unsafeArraySpread",
				"endLine": 287,
				"endColumn": 80
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe spread of an `any[]` array type.",
				"line": 288,
				"column": 61,
				"nodeType": "SpreadElement",
				"messageId": "unsafeArraySpread",
				"endLine": 288,
				"endColumn": 70
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 296,
				"column": 16,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 296,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 303,
				"column": 35,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 303,
				"endColumn": 38,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [7978, 7981], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [7978, 7981], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .detail on an `any` value.",
				"line": 307,
				"column": 16,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 307,
				"endColumn": 22
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 308,
				"column": 13,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 308,
				"endColumn": 33
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .detail on an `any` value.",
				"line": 308,
				"column": 18,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 308,
				"endColumn": 24
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 309,
				"column": 13,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 309,
				"endColumn": 33
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .detail on an `any` value.",
				"line": 309,
				"column": 18,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 309,
				"endColumn": 24
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 310,
				"column": 13,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 310,
				"endColumn": 33
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .detail on an `any` value.",
				"line": 310,
				"column": 18,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 310,
				"endColumn": 24
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 311,
				"column": 13,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 311,
				"endColumn": 33
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .detail on an `any` value.",
				"line": 311,
				"column": 18,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 311,
				"endColumn": 24
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 312,
				"column": 13,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 312,
				"endColumn": 33
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .detail on an `any` value.",
				"line": 312,
				"column": 18,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 312,
				"endColumn": 24
			},
			{
				"ruleId": "no-console",
				"severity": 1,
				"message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
				"line": 380,
				"column": 5,
				"nodeType": "MemberExpression",
				"messageId": "limited",
				"endLine": 380,
				"endColumn": 16,
				"suggestions": [
					{
						"fix": { "range": [10189, 10239], "text": "" },
						"messageId": "removeConsole",
						"data": { "propertyName": "log" },
						"desc": "Remove the console.log()."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 405,
				"column": 9,
				"nodeType": "AssignmentExpression",
				"messageId": "anyAssignment",
				"endLine": 405,
				"endColumn": 38
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'e' is defined but never used.",
				"line": 406,
				"column": 16,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 406,
				"endColumn": 17
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 412,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 412,
				"endColumn": 33
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type error typed assigned to a parameter of type `number`.",
				"line": 418,
				"column": 53,
				"nodeType": "MemberExpression",
				"messageId": "unsafeArgument",
				"endLine": 418,
				"endColumn": 64
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 425,
				"column": 59,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 425,
				"endColumn": 62,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [11555, 11558], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [11555, 11558], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .row_count on an `any` value.",
				"line": 439,
				"column": 17,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 439,
				"endColumn": 26
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .index_count on an `any` value.",
				"line": 439,
				"column": 45,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 439,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .name on an `any` value.",
				"line": 443,
				"column": 35,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 443,
				"endColumn": 39
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .row_count on an `any` value.",
				"line": 443,
				"column": 53,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 443,
				"endColumn": 62
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .index_count on an `any` value.",
				"line": 443,
				"column": 86,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 443,
				"endColumn": 97
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type `any` assigned to a parameter of type `number`.",
				"line": 449,
				"column": 32,
				"nodeType": "MemberExpression",
				"messageId": "unsafeArgument",
				"endLine": 449,
				"endColumn": 67
			}
		],
		"suppressedMessages": [],
		"errorCount": 32,
		"fatalErrorCount": 0,
		"warningCount": 10,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "/**\n * Database Optimizer\n * Advanced optimization strategies for SQLite performance\n */\n\nimport type { Database as DatabaseType } from 'better-sqlite3';\n\ninterface OptimizationConfig {\n  // Performance tuning\n  cacheSize: number;        // Pages in cache (-2000 = 2MB)\n  pageSize: number;         // Database page size\n  mmapSize: number;         // Memory-mapped I/O size\n  walMode: boolean;         // Use Write-Ahead Logging\n  synchronous: 'OFF' | 'NORMAL' | 'FULL';\n  \n  // Query optimization\n  analyzeOnStart: boolean;  // Run ANALYZE on startup\n  autoIndex: boolean;       // Allow automatic indexes\n  queryPlanner: boolean;    // Enable query planner stats\n  \n  // Memory limits\n  tempStore: 'DEFAULT' | 'FILE' | 'MEMORY';\n  tempStoreDirectory?: string;\n  memoryLimit?: number;     // Soft heap limit in bytes\n}\n\ninterface QueryStats {\n  query: string;\n  count: number;\n  totalTime: number;\n  avgTime: number;\n  lastRun: number;\n}\n\nexport class DatabaseOptimizer {\n  private db: DatabaseType;\n  private config: OptimizationConfig;\n  private queryStats: Map<string, QueryStats> = new Map();\n  private optimizationTimer?: ReturnType<typeof setTimeout>;\n\n  constructor(db: DatabaseType, config?: Partial<OptimizationConfig>) {\n    this.db = db;\n    this.config = {\n      // Default optimizations for Raspberry Pi\n      cacheSize: -2000,        // 2MB cache\n      pageSize: 4096,          // 4KB pages\n      mmapSize: 30000000,      // 30MB mmap\n      walMode: true,\n      synchronous: 'NORMAL',\n      analyzeOnStart: true,\n      autoIndex: true,\n      queryPlanner: false,\n      tempStore: 'MEMORY',\n      memoryLimit: 50 * 1024 * 1024, // 50MB soft limit\n      ...config\n    };\n    \n    this.applyOptimizations();\n  }\n\n  /**\n   * Apply database optimizations\n   */\n  private applyOptimizations() {\n    // Cache configuration\n    this.db.pragma(`cache_size = ${this.config.cacheSize}`);\n    \n    // WAL mode for better concurrency\n    if (this.config.walMode) {\n      this.db.pragma('journal_mode = WAL');\n      this.db.pragma('wal_autocheckpoint = 1000'); // Checkpoint every 1000 pages\n    }\n    \n    // Synchronous mode\n    this.db.pragma(`synchronous = ${this.config.synchronous}`);\n    \n    // Memory-mapped I/O\n    if (this.config.mmapSize > 0) {\n      this.db.pragma(`mmap_size = ${this.config.mmapSize}`);\n    }\n    \n    // Temporary storage\n    this.db.pragma(`temp_store = ${this.config.tempStore}`);\n    if (this.config.tempStoreDirectory) {\n      this.db.pragma(`temp_store_directory = '${this.config.tempStoreDirectory}'`);\n    }\n    \n    // Memory limit\n    if (this.config.memoryLimit) {\n      this.db.pragma(`soft_heap_limit = ${this.config.memoryLimit}`);\n    }\n    \n    // Query planner\n    if (this.config.queryPlanner) {\n      this.db.pragma('query_only = 0');\n    }\n    \n    // Auto-index\n    this.db.pragma(`automatic_index = ${this.config.autoIndex ? 'ON' : 'OFF'}`);\n    \n    // Initial analysis\n    if (this.config.analyzeOnStart) {\n      this.analyze();\n    }\n    \n    console.log('Database optimizations applied');\n  }\n\n  /**\n   * Analyze database statistics\n   */\n  analyze() {\n    console.log('Analyzing database...');\n    const start = Date.now();\n    this.db.exec('ANALYZE');\n    const duration = Date.now() - start;\n    console.log(`Analysis completed in ${duration}ms`);\n  }\n\n  /**\n   * Get current pragma settings\n   */\n  getPragmaSettings() {\n    const pragmas = [\n      'cache_size',\n      'page_size',\n      'journal_mode',\n      'synchronous',\n      'mmap_size',\n      'temp_store',\n      'soft_heap_limit',\n      'automatic_index',\n      'wal_autocheckpoint',\n      'page_count',\n      'freelist_count'\n    ];\n    \n    const settings: Record<string, any> = {};\n    \n    for (const pragma of pragmas) {\n      try {\n        const result = this.db.pragma(pragma);\n        settings[pragma] = result;\n      } catch (e) {\n        // Some pragmas might not be available\n      }\n    }\n    \n    return settings;\n  }\n\n  /**\n   * Get index statistics and suggestions\n   */\n  getIndexAnalysis() {\n    // Get all indexes\n    const indexes = this.db.prepare(`\n      SELECT \n        name as index_name,\n        tbl_name as table_name,\n        sql\n      FROM sqlite_master \n      WHERE type = 'index' \n        AND name NOT LIKE 'sqlite_%'\n    `).all();\n    \n    // Analyze index usage (approximate based on EXPLAIN QUERY PLAN)\n    const analysis = indexes.map(index => {\n      // Check if index is used in common queries\n      const usage = this.checkIndexUsage(index.table_name, index.index_name);\n      \n      return {\n        ...index,\n        usage,\n        recommendation: usage.score < 0.1 ? 'Consider dropping' : \n                       usage.score > 0.8 ? 'Heavily used' : 'Moderate usage'\n      };\n    });\n    \n    // Suggest missing indexes\n    const suggestions = this.suggestMissingIndexes();\n    \n    return {\n      existing: analysis,\n      suggestions\n    };\n  }\n\n  /**\n   * Check index usage for a specific index\n   */\n  private checkIndexUsage(tableName: string, indexName: string) {\n    // This is a simplified check - in production, you'd analyze actual query plans\n    const commonQueries = [\n      `SELECT * FROM ${tableName} WHERE`,\n      `DELETE FROM ${tableName} WHERE`,\n      `UPDATE ${tableName} SET`\n    ];\n    \n    let usageCount = 0;\n    let totalQueries = 0;\n    \n    // Check if index columns are used in WHERE clauses\n    // This is a heuristic - actual implementation would analyze EXPLAIN QUERY PLAN\n    \n    return {\n      score: 0.5, // Default moderate usage\n      usageCount,\n      totalQueries\n    };\n  }\n\n  /**\n   * Suggest missing indexes based on query patterns\n   */\n  private suggestMissingIndexes() {\n    const suggestions = [];\n    \n    // Check for missing indexes on foreign keys\n    const foreignKeys = this.db.prepare(`\n      SELECT \n        m.name as table_name,\n        p.name as column_name,\n        p.\"table\" as referenced_table\n      FROM sqlite_master m\n      JOIN pragma_foreign_key_list(m.name) p\n      WHERE m.type = 'table'\n    `).all();\n    \n    for (const fk of foreignKeys) {\n      // Check if index exists on foreign key column\n      const indexExists = this.db.prepare(`\n        SELECT 1 FROM sqlite_master \n        WHERE type = 'index' \n          AND tbl_name = ?\n          AND sql LIKE ?\n      `).get(fk.table_name, `%${fk.column_name}%`);\n      \n      if (!indexExists) {\n        suggestions.push({\n          table: fk.table_name,\n          column: fk.column_name,\n          type: 'foreign_key',\n          sql: `CREATE INDEX idx_${fk.table_name}_${fk.column_name} ON ${fk.table_name}(${fk.column_name})`\n        });\n      }\n    }\n    \n    // Check for common query patterns without indexes\n    // This would analyze actual query history in production\n    \n    return suggestions;\n  }\n\n  /**\n   * Optimize specific table\n   */\n  optimizeTable(tableName: string) {\n    console.log(`Optimizing table: ${tableName}`);\n    \n    // Rebuild the table to defragment\n    this.db.exec(`VACUUM ${tableName}`);\n    \n    // Update statistics\n    this.db.exec(`ANALYZE ${tableName}`);\n    \n    // Check and optimize indexes\n    const indexes = this.db.prepare(`\n      SELECT name FROM sqlite_master \n      WHERE type = 'index' \n        AND tbl_name = ?\n        AND name NOT LIKE 'sqlite_%'\n    `).all(tableName);\n    \n    for (const index of indexes) {\n      this.db.exec(`REINDEX ${index.name}`);\n    }\n    \n    console.log(`Table ${tableName} optimized`);\n  }\n\n  /**\n   * Get query execution plan\n   */\n  explainQuery(query: string, params: any[] = []) {\n    try {\n      const plan = this.db.prepare(`EXPLAIN QUERY PLAN ${query}`).all(...params);\n      const stats = this.db.prepare(`EXPLAIN ${query}`).all(...params);\n      \n      return {\n        plan,\n        stats,\n        estimatedCost: this.estimateQueryCost(plan)\n      };\n    } catch (error) {\n      return { error: error.message };\n    }\n  }\n\n  /**\n   * Estimate query cost from execution plan\n   */\n  private estimateQueryCost(plan: any[]) {\n    let cost = 0;\n    \n    for (const step of plan) {\n      if (step.detail) {\n        if (step.detail.includes('SCAN TABLE')) cost += 1000;\n        if (step.detail.includes('SEARCH TABLE')) cost += 100;\n        if (step.detail.includes('USING INDEX')) cost += 10;\n        if (step.detail.includes('USING COVERING INDEX')) cost += 5;\n        if (step.detail.includes('TEMP B-TREE')) cost += 500;\n      }\n    }\n    \n    return cost;\n  }\n\n  /**\n   * Monitor query performance\n   */\n  trackQuery(query: string, duration: number) {\n    const stats = this.queryStats.get(query) || {\n      query,\n      count: 0,\n      totalTime: 0,\n      avgTime: 0,\n      lastRun: 0\n    };\n    \n    stats.count++;\n    stats.totalTime += duration;\n    stats.avgTime = stats.totalTime / stats.count;\n    stats.lastRun = Date.now();\n    \n    this.queryStats.set(query, stats);\n  }\n\n  /**\n   * Get slow queries\n   */\n  getSlowQueries(threshold: number = 100) {\n    const slowQueries = Array.from(this.queryStats.values())\n      .filter(stats => stats.avgTime > threshold)\n      .sort((a, b) => b.avgTime - a.avgTime);\n    \n    return slowQueries;\n  }\n\n  /**\n   * Optimize for specific workload\n   */\n  optimizeForWorkload(workload: 'read_heavy' | 'write_heavy' | 'mixed') {\n    switch (workload) {\n      case 'read_heavy':\n        // Optimize for reads\n        this.db.pragma('cache_size = -4000'); // 4MB cache\n        this.db.pragma('mmap_size = 268435456'); // 256MB mmap\n        this.db.pragma('synchronous = NORMAL');\n        this.db.pragma('page_size = 8192'); // Larger pages\n        break;\n        \n      case 'write_heavy':\n        // Optimize for writes\n        this.db.pragma('cache_size = -1000'); // 1MB cache\n        this.db.pragma('synchronous = OFF'); // Faster but less safe\n        this.db.pragma('journal_mode = WAL');\n        this.db.pragma('wal_autocheckpoint = 100'); // Frequent checkpoints\n        break;\n        \n      case 'mixed':\n        // Balanced optimization\n        this.db.pragma('cache_size = -2000'); // 2MB cache\n        this.db.pragma('synchronous = NORMAL');\n        this.db.pragma('journal_mode = WAL');\n        this.db.pragma('wal_autocheckpoint = 1000');\n        break;\n    }\n    \n    console.log(`Optimized for ${workload} workload`);\n  }\n\n  /**\n   * Get database health report\n   */\n  getHealthReport() {\n    const settings = this.getPragmaSettings();\n    const dbSize = this.db.prepare(\"SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size()\").get();\n    const integrity = this.db.pragma('integrity_check');\n    const quickCheck = this.db.pragma('quick_check');\n    \n    // Table statistics\n    const tables = this.db.prepare(`\n      SELECT \n        name,\n        (SELECT COUNT(*) FROM sqlite_master WHERE type='index' AND tbl_name=m.name) as index_count\n      FROM sqlite_master m\n      WHERE type = 'table' AND name NOT LIKE 'sqlite_%'\n    `).all();\n    \n    // Add row counts\n    for (const table of tables) {\n      try {\n        const count = this.db.prepare(`SELECT COUNT(*) as count FROM ${table.name}`).get();\n        table.row_count = count.count;\n      } catch (e) {\n        table.row_count = -1;\n      }\n    }\n    \n    return {\n      database_size: dbSize.size,\n      settings,\n      integrity: integrity === 'ok',\n      quick_check: quickCheck === 'ok',\n      tables,\n      slow_queries: this.getSlowQueries(),\n      recommendations: this.generateRecommendations(dbSize.size, tables)\n    };\n  }\n\n  /**\n   * Generate optimization recommendations\n   */\n  private generateRecommendations(dbSize: number, tables: any[]) {\n    const recommendations = [];\n    \n    // Database size recommendations\n    if (dbSize > 100 * 1024 * 1024) { // > 100MB\n      recommendations.push({\n        type: 'size',\n        severity: 'medium',\n        message: 'Consider implementing more aggressive data retention policies'\n      });\n    }\n    \n    // Table size recommendations\n    for (const table of tables) {\n      if (table.row_count > 100000 && table.index_count < 2) {\n        recommendations.push({\n          type: 'index',\n          severity: 'high',\n          message: `Table ${table.name} has ${table.row_count} rows but only ${table.index_count} indexes`\n        });\n      }\n    }\n    \n    // Cache size recommendation\n    const cacheSize = Math.abs(this.getPragmaSettings().cache_size);\n    if (dbSize > cacheSize * 1024 * 10) { // Cache is < 10% of DB size\n      recommendations.push({\n        type: 'cache',\n        severity: 'medium',\n        message: 'Consider increasing cache_size for better performance'\n      });\n    }\n    \n    return recommendations;\n  }\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/server/db/migrations/runMigrations.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 17,
				"column": 67,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 17,
				"endColumn": 70,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [571, 574], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [571, 574], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-return",
				"severity": 2,
				"message": "Unsafe return of a value of type `any`.",
				"line": 17,
				"column": 75,
				"nodeType": "MemberExpression",
				"messageId": "unsafeReturn",
				"endLine": 17,
				"endColumn": 87
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .filename on an `any` value.",
				"line": 17,
				"column": 79,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 17,
				"endColumn": 87
			},
			{
				"ruleId": "no-console",
				"severity": 1,
				"message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
				"line": 33,
				"column": 7,
				"nodeType": "MemberExpression",
				"messageId": "limited",
				"endLine": 33,
				"endColumn": 18,
				"suggestions": [
					{
						"fix": { "range": [1046, 1092], "text": "" },
						"messageId": "removeConsole",
						"data": { "propertyName": "log" },
						"desc": "Remove the console.log()."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 2,
		"fatalErrorCount": 0,
		"warningCount": 2,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import Database from 'better-sqlite3';\nimport { readFileSync, readdirSync } from 'fs';\nimport { join } from 'path';\n\nexport function runMigrations(db: Database.Database, migrationsPath: string) {\n  // Create migrations tracking table if not exists\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS migrations (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      filename TEXT UNIQUE NOT NULL,\n      applied_at INTEGER NOT NULL\n    )\n  `);\n\n  // Get list of applied migrations\n  const appliedMigrations = new Set(\n    db.prepare('SELECT filename FROM migrations').all().map((row: any) => row.filename)\n  );\n\n  // Get all migration files\n  const migrationFiles = readdirSync(migrationsPath)\n    .filter(file => file.endsWith('.sql'))\n    .sort(); // Ensure migrations run in order\n\n  // Apply pending migrations\n  const applyMigration = db.transaction((filename: string, sql: string) => {\n    try {\n      db.exec(sql);\n      db.prepare('INSERT INTO migrations (filename, applied_at) VALUES (?, ?)').run(\n        filename,\n        Date.now()\n      );\n      console.log(`Applied migration: ${filename}`);\n    } catch (error) {\n      console.error(`Failed to apply migration ${filename}:`, error);\n      throw error;\n    }\n  });\n\n  for (const filename of migrationFiles) {\n    if (!appliedMigrations.has(filename)) {\n      const sql = readFileSync(join(migrationsPath, filename), 'utf-8');\n      applyMigration(filename, sql);\n    }\n  }\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/server/hackrf/index.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/server/hackrf/sweepManager.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'NodeJS' is defined but never used. Allowed unused vars must match /^_/u.",
				"line": 5,
				"column": 15,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 5,
				"endColumn": 21
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 672,
				"column": 17,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 672,
				"endColumn": 42
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 672,
				"column": 27,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 672,
				"endColumn": 40
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .toString on an `any` value.",
				"line": 672,
				"column": 32,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 672,
				"endColumn": 40
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .length on an `any` value.",
				"line": 675,
				"column": 50,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 675,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 678,
				"column": 13,
				"nodeType": "AssignmentExpression",
				"messageId": "anyAssignment",
				"endLine": 678,
				"endColumn": 40
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 704,
				"column": 9,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 704,
				"endColumn": 34,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [22823, 22824], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 705,
				"column": 17,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 705,
				"endColumn": 49
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 705,
				"column": 27,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 705,
				"endColumn": 47
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 705,
				"column": 27,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 705,
				"endColumn": 40
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .toString on an `any` value.",
				"line": 705,
				"column": 32,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 705,
				"endColumn": 40
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .trim on an `any` value.",
				"line": 705,
				"column": 43,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 705,
				"endColumn": 47
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 706,
				"column": 72,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 706,
				"endColumn": 79
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 709,
				"column": 15,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 709,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .includes on an `any` value.",
				"line": 709,
				"column": 23,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 709,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 710,
				"column": 15,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 710,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .includes on an `any` value.",
				"line": 710,
				"column": 23,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 710,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 711,
				"column": 15,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 711,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .includes on an `any` value.",
				"line": 711,
				"column": 23,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 711,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 712,
				"column": 15,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 712,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .includes on an `any` value.",
				"line": 712,
				"column": 23,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 712,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 713,
				"column": 15,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 713,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .includes on an `any` value.",
				"line": 713,
				"column": 23,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 713,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 714,
				"column": 15,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 714,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .includes on an `any` value.",
				"line": 714,
				"column": 23,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 714,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 715,
				"column": 53,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 715,
				"endColumn": 60
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
				"line": 732,
				"column": 63,
				"nodeType": "Identifier",
				"messageId": "unsafeArgument",
				"endLine": 732,
				"endColumn": 70
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 733,
				"column": 59,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 733,
				"endColumn": 66
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.",
				"line": 737,
				"column": 30,
				"nodeType": "Identifier",
				"messageId": "unsafeArgument",
				"endLine": 737,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/prefer-promise-reject-errors",
				"severity": 2,
				"message": "Expected the Promise rejection reason to be an Error.",
				"line": 809,
				"column": 9,
				"nodeType": "CallExpression",
				"messageId": "rejectAnError",
				"endLine": 809,
				"endColumn": 22
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 901,
				"column": 13,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 901,
				"endColumn": 51
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 906,
				"column": 9,
				"nodeType": "Identifier",
				"messageId": "unsafeCall",
				"endLine": 906,
				"endColumn": 17
			},
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'logDebug' is not defined.",
				"line": 906,
				"column": 9,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 906,
				"endColumn": 17
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 906,
				"column": 37,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 906,
				"endColumn": 75
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 906,
				"column": 48,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 906,
				"endColumn": 72
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .frequency on an `any` value.",
				"line": 906,
				"column": 55,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 906,
				"endColumn": 64
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 906,
				"column": 77,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 906,
				"endColumn": 104
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 906,
				"column": 84,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 906,
				"endColumn": 101
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .db on an `any` value.",
				"line": 906,
				"column": 91,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 906,
				"endColumn": 93
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 915,
				"column": 9,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 915,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .frequency on an `any` value.",
				"line": 915,
				"column": 27,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 915,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 916,
				"column": 9,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 916,
				"endColumn": 25
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .db on an `any` value.",
				"line": 916,
				"column": 23,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 916,
				"endColumn": 25
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 918,
				"column": 9,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 918,
				"endColumn": 33
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .dbValues on an `any` value.",
				"line": 918,
				"column": 25,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 918,
				"endColumn": 33
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 923,
				"column": 11,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 923,
				"endColumn": 48
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .frequencyRange on an `any` value.",
				"line": 923,
				"column": 34,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 923,
				"endColumn": 48
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 924,
				"column": 11,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 924,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .binWidth on an `any` value.",
				"line": 924,
				"column": 28,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 924,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 925,
				"column": 11,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 925,
				"endColumn": 48
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .signalStrength on an `any` value.",
				"line": 925,
				"column": 34,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 925,
				"endColumn": 48
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 950,
				"column": 45,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 950,
				"endColumn": 48,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [32441, 32444], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [32441, 32444], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 1103,
				"column": 46,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 1103,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [37295, 37298], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [37295, 37298], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .frequency on an `any` value.",
				"line": 1107,
				"column": 23,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 1107,
				"endColumn": 32
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 1108,
				"column": 18,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 1108,
				"endColumn": 39
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .frequency on an `any` value.",
				"line": 1108,
				"column": 30,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 1108,
				"endColumn": 39
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 1108,
				"column": 41,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 1108,
				"endColumn": 65
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .unit on an `any` value.",
				"line": 1108,
				"column": 52,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 1108,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .value on an `any` value.",
				"line": 1109,
				"column": 23,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 1109,
				"endColumn": 28
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 1110,
				"column": 18,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 1110,
				"endColumn": 35
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .value on an `any` value.",
				"line": 1110,
				"column": 30,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 1110,
				"endColumn": 35
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 1110,
				"column": 37,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 1110,
				"endColumn": 61
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .unit on an `any` value.",
				"line": 1110,
				"column": 48,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 1110,
				"endColumn": 52
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 1165,
				"column": 9,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 1165,
				"endColumn": 42
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 1183,
				"column": 43,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 1183,
				"endColumn": 46,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [39891, 39894], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [39891, 39894], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 1292,
				"column": 21,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 1292,
				"endColumn": 24,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [43781, 43784], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [43781, 43784], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 1293,
				"column": 37,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 1293,
				"endColumn": 42
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .message on an `any` value.",
				"line": 1294,
				"column": 49,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 1294,
				"endColumn": 56
			}
		],
		"suppressedMessages": [
			{
				"ruleId": "no-constant-condition",
				"severity": 2,
				"message": "Unexpected constant condition.",
				"line": 222,
				"column": 9,
				"nodeType": "Literal",
				"messageId": "unexpected",
				"endLine": 222,
				"endColumn": 14,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			}
		],
		"errorCount": 62,
		"fatalErrorCount": 0,
		"warningCount": 6,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import type { SweepConfig, SweepStatus, SpectrumData, HackRFHealth } from './types';\nimport { EventEmitter } from 'events';\nimport { spawn, exec, type ChildProcess } from 'child_process';\nimport { logInfo, logError, logWarn } from '$lib/utils/logger';\nimport type { NodeJS } from 'node';\n\n/**\n * Manages HackRF sweep operations - direct port from SweeperService\n * Maintains exact functionality from the original implementation\n */\nexport class SweepManager extends EventEmitter {\n  // State management\n  private status: SweepStatus = { state: 'idle' };\n  private isRunning = false;\n  private isCycling = false;\n  private inFrequencyTransition = false;\n  \n  // Process management\n  private sweepProcess: ChildProcess | null = null;\n  private sweepProcessPgid: number | null = null;\n  private actualProcessPid: number | null = null;\n  private processStartTime: number | null = null;\n  private processRegistry = new Map<number, ChildProcess>();\n  private processMonitorInterval: ReturnType<typeof setInterval> | null = null;\n  private dataTimeoutTimer: ReturnType<typeof setTimeout> | null = null;\n  \n  // Frequency cycling\n  private frequencies: Array<{value: number; unit: string}> = [];\n  private currentIndex = 0;\n  private cycleTime = 10000; // Default 10 seconds\n  private cycleTimer: ReturnType<typeof setTimeout> | null = null;\n  private switchTimer: ReturnType<typeof setTimeout> | null = null;\n  private switchingTime = 3000; // Default 3 seconds\n  \n  // Timeouts\n  private processTimeout: ReturnType<typeof setTimeout> | null = null;\n  private processStartupTimeout: ReturnType<typeof setTimeout> | null = null;\n  private processTimeoutMs = 20000; // 20 seconds\n  private processStartupDetectionMs = 2500; // 2.5 seconds\n  private processHealthCheckIntervalMs = 1000;\n  private frequencySwitchTimeoutMs = 15000; // 15 seconds\n  \n  // Line buffering for stdout\n  private stdoutBuffer = '';\n  private maxBufferSize = 1024 * 1024; // 1MB max buffer\n  private bufferOverflowCount = 0;\n  \n  // Error tracking\n  private consecutiveErrors = 0;\n  private maxConsecutiveErrors = 8;\n  private frequencyErrors = new Map<number, number>();\n  private frequencyBlacklist = new Set<number>();\n  private recentFailures: number[] = [];\n  private maxFailuresPerMinute = 5;\n  \n  // Device state tracking\n  private deviceState = {\n    status: 'unknown' as 'unknown' | 'available' | 'busy' | 'stuck' | 'disconnected',\n    lastSuccessfulOperation: null as Date | null,\n    consecutiveBusyErrors: 0,\n    recoveryState: 'none' as 'none' | 'retrying' | 'escalating' | 'cooling_down'\n  };\n  \n  // Health monitoring\n  private cyclingHealth = {\n    status: 'idle' as string,\n    processHealth: 'unknown' as string,\n    processStartupPhase: 'none' as string,\n    lastSwitchTime: null as Date | null,\n    lastDataReceived: null as Date | null,\n    recovery: {\n      recoveryAttempts: 0,\n      maxRecoveryAttempts: 3,\n      lastRecoveryAttempt: null as Date | null,\n      isRecovering: false\n    }\n  };\n  \n  private healthMonitorInterval: ReturnType<typeof setInterval>;\n  private isInitialized = false;\n  \n  // SSE emitter reference\n  private sseEmitter: ((event: string, data: unknown) => void) | null = null;\n\n  constructor() {\n    super();\n    \n    // Start health monitoring with longer interval\n    this.healthMonitorInterval = setInterval(() => {\n      void this._performHealthCheck();\n    }, 30000); // Check every 30 seconds instead of 5\n    \n    // Perform startup validation\n    this._performStartupValidation();\n  }\n\n  /**\n   * Set SSE emitter for sending events to clients\n   */\n  setSseEmitter(emitter: ((event: string, data: unknown) => void) | null): void {\n    this.sseEmitter = emitter;\n  }\n\n  /**\n   * Perform startup state validation\n   */\n  private _performStartupValidation(): void {\n    logInfo('🔍 SweepManager: Performing startup state validation...');\n    \n    // Reset all state\n    this.isRunning = false;\n    this.isCycling = false;\n    this.frequencies = [];\n    this.currentIndex = 0;\n    this.sweepProcess = null;\n    this.sweepProcessPgid = null;\n    this.inFrequencyTransition = false;\n    \n    // Clear any lingering timers\n    if (this.cycleTimer) {\n      clearTimeout(this.cycleTimer);\n      this.cycleTimer = null;\n    }\n    \n    if (this.switchTimer) {\n      clearTimeout(this.switchTimer);\n      this.switchTimer = null;\n    }\n    \n    if (this.processTimeout) {\n      clearTimeout(this.processTimeout);\n      this.processTimeout = null;\n    }\n    \n    // Reset error tracking\n    this.consecutiveErrors = 0;\n    this.recentFailures = [];\n    \n    // Clear stdout buffer\n    this.stdoutBuffer = '';\n    this.bufferOverflowCount = 0;\n    \n    // Reset health status\n    this.cyclingHealth.status = 'idle';\n    this.cyclingHealth.processHealth = 'stopped';\n    this.cyclingHealth.lastDataReceived = null;\n    this.cyclingHealth.recovery.recoveryAttempts = 0;\n    this.cyclingHealth.recovery.lastRecoveryAttempt = null;\n    this.cyclingHealth.recovery.isRecovering = false;\n    \n    this.isInitialized = true;\n    logInfo('✅ SweepManager startup validation complete');\n  }\n\n  /**\n   * Perform health check\n   */\n  private async _performHealthCheck(): Promise<void> {\n    // Only perform health checks if we're actually running\n    if (!this.isRunning || !this.sweepProcess) {\n      return;\n    }\n    \n    const now = Date.now();\n    \n    // Log health check details\n    logInfo('🏥 Health check:', {\n      isRunning: this.isRunning,\n      hasSweepProcess: !!this.sweepProcess,\n      pid: this.actualProcessPid,\n      inFrequencyTransition: this.inFrequencyTransition,\n      isCycling: this.isCycling,\n      lastDataReceived: this.cyclingHealth.lastDataReceived?.toISOString(),\n      processStartTime: this.processStartTime ? new Date(this.processStartTime).toISOString() : null,\n      recoveryAttempts: this.cyclingHealth.recovery.recoveryAttempts,\n      isRecovering: this.cyclingHealth.recovery.isRecovering\n    });\n    \n    // Check system memory periodically\n    try {\n      const memInfo = await this._checkSystemMemory();\n      logInfo(`💾 Memory: ${memInfo.availablePercent}% available (${memInfo.availableMB}MB / ${memInfo.totalMB}MB)`);\n      if (memInfo.availablePercent < 10) {\n        logWarn(`⚠️ Low memory: ${memInfo.availablePercent}% available`);\n      }\n    } catch (e) {\n      logError('Failed to check memory:', e);\n    }\n    \n    // Check if we're already recovering\n    if (this.cyclingHealth.recovery.isRecovering) {\n      logInfo('⏳ Already in recovery, skipping health check');\n      return;\n    }\n    \n    // Check multiple health indicators\n    let needsRecovery = false;\n    let reason = '';\n    \n    // 1. Check if process has been running too long without data\n    if (this.cyclingHealth.lastDataReceived) {\n      const timeSinceData = now - this.cyclingHealth.lastDataReceived.getTime();\n      logInfo(`📊 Time since last data: ${Math.round(timeSinceData / 1000)}s`);\n      if (timeSinceData > 7200000) { // 2 hours without data (changed from 2 minutes for long-term monitoring)\n        needsRecovery = true;\n        reason = 'No data received for 2 hours';\n      }\n    } else if (this.processStartTime && now - this.processStartTime > 60000) {\n      // No data ever received and process has been running for 60 seconds\n      const runTime = Math.round((now - this.processStartTime) / 1000);\n      logWarn(`⏱️ Process running for ${runTime}s with no data`);\n      needsRecovery = true;\n      reason = 'No initial data received';\n    }\n    \n    // 2. Check if process is stuck (only if we're not in frequency transition)\n    // Note: For single frequency mode, we shouldn't trigger this check\n    // Disabled runtime limit for long-term monitoring sessions\n    // if (!this.inFrequencyTransition && this.isCycling && this.processStartTime && now - this.processStartTime > 180000) {\n    // Runtime limit disabled for 4+ hour monitoring sessions\n    // eslint-disable-next-line no-constant-condition\n    if (false) {\n      const runTime = Math.round((now - this.processStartTime) / 1000);\n      logWarn(`⏱️ Process running for ${runTime}s without cycling`);\n      needsRecovery = true;\n      reason = 'Process running too long without cycling';\n    }\n    \n    // 3. Check if process is still alive\n    if (this.sweepProcess && this.actualProcessPid) {\n      try {\n        // Check if process exists\n        process.kill(this.actualProcessPid, 0);\n        logInfo(`✅ Process ${this.actualProcessPid} is still alive`);\n      } catch {\n        needsRecovery = true;\n        reason = 'Process no longer exists';\n      }\n    }\n    \n    // Perform recovery if needed\n    if (needsRecovery) {\n      logWarn(`⚠️ Health check failed: ${reason}`);\n      this.cyclingHealth.processHealth = 'unhealthy';\n      await this._performRecovery(reason);\n    } else if (this.cyclingHealth.lastDataReceived) {\n      this.cyclingHealth.processHealth = 'healthy';\n    }\n  }\n\n  /**\n   * Start a new sweep operation\n   */\n  async startSweep(config: SweepConfig): Promise<void> {\n    if (this.status.state === 'running') {\n      throw new Error('Sweep already in progress');\n    }\n\n    // Convert single frequency config to multi-frequency format\n    const frequencies = config.frequencies || [{\n      value: config.centerFrequency,\n      unit: 'Hz'\n    }];\n\n    // Start cycling with configured parameters\n    const success = await this.startCycle(frequencies, config.cycleTime || 10000);\n    if (!success) {\n      throw new Error('Failed to start sweep');\n    }\n  }\n\n  /**\n   * Start frequency cycling\n   */\n  async startCycle(frequencies: Array<{value: number; unit: string}>, cycleTime: number): Promise<boolean> {\n    // Verify service is initialized\n    if (!this.isInitialized) {\n      logWarn('Service not yet initialized');\n      return false;\n    }\n    \n    // Force cleanup existing processes before starting\n    await this._forceCleanupExistingProcesses();\n    \n    // Additional startup delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    if (this.isRunning) {\n      this._emitError('Sweep is already running', 'state_check');\n      return false;\n    }\n    \n    if (!frequencies || frequencies.length === 0) {\n      this._emitError('No frequencies provided', 'input_validation');\n      return false;\n    }\n\n    try {\n      // Normalize frequencies\n      const validatedFreqs = this._normalizeFrequencies(frequencies);\n      \n      if (validatedFreqs.length === 0) {\n        this._emitError('No valid frequencies provided', 'frequency_validation');\n        return false;\n      }\n      \n      // Check device availability\n      logInfo('🔍 Checking HackRF device availability...');\n      const deviceCheck = await this._testHackrfAvailability();\n      if (!deviceCheck.available) {\n        this._emitError(`HackRF not available: ${deviceCheck.reason}`, 'device_check');\n        return false;\n      }\n      \n      // Initialize cycling state\n      this.frequencies = validatedFreqs;\n      this.currentIndex = 0;\n      this.cycleTime = cycleTime || 10000;\n      \n      // Dynamically adjust switching time\n      this.switchingTime = Math.min(3000, Math.max(500, Math.floor(this.cycleTime * 0.25)));\n      \n      this.isCycling = validatedFreqs.length > 1;\n      this.isRunning = true;\n      this._resetErrorTracking();\n      \n      // Update status\n      this.status = {\n        state: 'running',\n        currentFrequency: this._convertToHz(validatedFreqs[0].value, validatedFreqs[0].unit),\n        sweepProgress: 0,\n        totalSweeps: validatedFreqs.length,\n        completedSweeps: 0,\n        startTime: Date.now()\n      };\n      \n      // Emit events\n      this._emitEvent('status', this.status);\n      this._emitEvent('cycle_config', {\n        frequencies: this.frequencies,\n        cycleTime: this.cycleTime,\n        totalCycleTime: this.frequencies.length * this.cycleTime,\n        isCycling: this.isCycling\n      });\n      \n      // Start the first frequency\n      try {\n        await this._runNextFrequency();\n        return true;\n      } catch (runError: unknown) {\n        const error = runError as Error;\n        logError('❌ Error in _runNextFrequency:', error.message);\n        logError('Stack:', error.stack);\n        \n        // Don't fail the whole cycle start, just log the error\n        // The sweep manager status is already set to running\n        return true;\n      }\n    } catch (error: unknown) {\n      const err = error as Error;\n      this._emitError(`Failed to start cycle: ${err.message}`, 'cycle_startup', err);\n      return false;\n    }\n  }\n\n  /**\n   * Stop the current sweep operation\n   */\n  async stopSweep(): Promise<void> {\n    logInfo('🛑 Stopping sweep... Current state:', this.status.state);\n    \n    // Allow stopping from any state except idle\n    if (this.status.state === 'idle') {\n      logInfo('Sweep already stopped');\n      return;\n    }\n\n    this.status.state = 'stopping';\n    this._emitEvent('status', this.status);\n    \n    // Stop cycling first\n    this.isCycling = false;\n    this.isRunning = false;\n    this.inFrequencyTransition = false;\n    \n    // Clear all timers\n    if (this.cycleTimer) {\n      clearTimeout(this.cycleTimer);\n      this.cycleTimer = null;\n    }\n    \n    if (this.switchTimer) {\n      clearTimeout(this.switchTimer);\n      this.switchTimer = null;\n    }\n    \n    if (this.processTimeout) {\n      clearTimeout(this.processTimeout);\n      this.processTimeout = null;\n    }\n    \n    if (this.processStartupTimeout) {\n      clearTimeout(this.processStartupTimeout);\n      this.processStartupTimeout = null;\n    }\n    \n    // Stop the sweep process\n    await this._stopSweepProcess();\n    \n    // Clear any remaining state\n    this.stdoutBuffer = '';\n    this.consecutiveErrors = 0;\n    \n    // Update status\n    this.status = { state: 'idle' };\n    this._emitEvent('status', this.status);\n    this._emitEvent('status_change', { status: 'stopped' });\n    \n    // Force emit idle status to ensure UI updates\n    setTimeout(() => {\n      this._emitEvent('status', { state: 'idle' });\n    }, 100);\n    \n    logInfo('Sweep stopped successfully');\n  }\n\n  /**\n   * Emergency stop - forcefully terminate all operations\n   */\n  async emergencyStop(): Promise<void> {\n    logWarn('Emergency stop initiated');\n    \n    // Force stop everything immediately\n    this.isCycling = false;\n    this.isRunning = false;\n    this.inFrequencyTransition = false;\n    \n    // Clear all timers\n    const timers = [\n      this.cycleTimer,\n      this.switchTimer,\n      this.processTimeout,\n      this.processStartupTimeout,\n      this.dataTimeoutTimer\n    ];\n    \n    timers.forEach(timer => {\n      if (timer) clearTimeout(timer);\n    });\n    \n    this.cycleTimer = null;\n    this.switchTimer = null;\n    this.processTimeout = null;\n    this.processStartupTimeout = null;\n    this.dataTimeoutTimer = null;\n    \n    // Clear intervals\n    if (this.processMonitorInterval) {\n      clearInterval(this.processMonitorInterval);\n      this.processMonitorInterval = null;\n    }\n    \n    // Force kill process with all methods available\n    if (this.sweepProcess || this.actualProcessPid) {\n      try {\n        // Try to kill by PID first\n        if (this.actualProcessPid) {\n          try {\n            process.kill(this.actualProcessPid, 'SIGKILL');\n            logInfo(`Sent SIGKILL to PID: ${this.actualProcessPid}`);\n          } catch {\n            logInfo('Process already dead or kill failed');\n          }\n        }\n        \n        // Try to kill process group\n        if (this.sweepProcessPgid) {\n          try {\n            process.kill(-this.sweepProcessPgid, 'SIGKILL');\n            logInfo(`Sent SIGKILL to PGID: ${this.sweepProcessPgid}`);\n          } catch {\n            // Ignore errors\n          }\n        }\n      } catch (e) {\n        logError('Emergency kill failed', { error: e }, 'emergency-kill');\n      }\n    }\n    \n    // Clear process references\n    this.sweepProcess = null;\n    this.sweepProcessPgid = null;\n    this.actualProcessPid = null;\n    \n    // Force cleanup all hackrf processes\n    await this._forceCleanupExistingProcesses();\n    \n    // Reset all state\n    this.stdoutBuffer = '';\n    this.consecutiveErrors = 0;\n    this.recentFailures = [];\n    this.frequencyErrors.clear();\n    this.frequencyBlacklist.clear();\n    \n    // Update status\n    this.status = { state: 'idle' };\n    this._emitEvent('status', this.status);\n    this._emitEvent('emergency_stop', { timestamp: new Date().toISOString() });\n    \n    logInfo('✅ Emergency stop completed');\n  }\n\n  /**\n   * Force cleanup of any lingering processes\n   */\n  async forceCleanup(): Promise<void> {\n    await this._forceCleanupExistingProcesses();\n    this.status = { state: 'idle' };\n  }\n\n  /**\n   * Get current sweep status\n   */\n  getStatus(): SweepStatus {\n    return { ...this.status };\n  }\n\n  /**\n   * Check HackRF device health\n   */\n  async checkHealth(): Promise<HackRFHealth> {\n    const check = await this._testHackrfAvailability();\n    return {\n      connected: check.available,\n      deviceInfo: check.deviceInfo,\n      error: check.available ? undefined : check.reason,\n      lastUpdate: Date.now()\n    };\n  }\n\n  /**\n   * Run the next frequency in the cycle\n   */\n  private async _runNextFrequency(): Promise<void> {\n    if (!this.isRunning || this.frequencies.length === 0) {\n      return;\n    }\n    \n    const frequency = this.frequencies[this.currentIndex];\n    \n    try {\n      // Start sweep for this frequency\n      await this._startSweepProcess(frequency);\n      \n      // Reset recovery attempts on successful start\n      this.cyclingHealth.recovery.recoveryAttempts = 0;\n      \n      // If cycling, set up timer for next frequency\n      if (this.isCycling && this.frequencies.length > 1) {\n        this.cycleTimer = setTimeout(() => {\n          void this._cycleToNextFrequency();\n        }, this.cycleTime);\n      }\n    } catch (error: unknown) {\n      logError('❌ Error starting sweep process:', error);\n      this._handleSweepError(error as Error, frequency);\n    }\n  }\n\n  /**\n   * Cycle to the next frequency\n   */\n  private async _cycleToNextFrequency(): Promise<void> {\n    if (!this.isCycling || !this.isRunning) {\n      return;\n    }\n    \n    // Move to next frequency\n    this.currentIndex = (this.currentIndex + 1) % this.frequencies.length;\n    \n    // Emit switching status\n    const nextFreq = this.frequencies[this.currentIndex];\n    this._emitEvent('status_change', { \n      status: 'switching', \n      nextFrequency: nextFreq \n    });\n    \n    // Stop current process\n    await this._stopSweepProcess();\n    \n    // Wait before switching\n    this.switchTimer = setTimeout(() => {\n      void this._runNextFrequency();\n    }, this.switchingTime);\n  }\n\n  /**\n   * Start the hackrf_sweep process\n   */\n  private async _startSweepProcess(frequency: {value: number; unit: string}): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        // Convert frequency to MHz\n        const centerFreqMHz = this._convertToMHz(frequency.value, frequency.unit);\n        const rangeMHz = 10; // Default 10 MHz range\n        const freqMinMHz = centerFreqMHz - rangeMHz;\n        const freqMaxMHz = centerFreqMHz + rangeMHz;\n        \n        // Validate range\n        if (freqMinMHz < 1 || freqMaxMHz > 7250) {\n          throw new Error(`Frequency ${centerFreqMHz} MHz out of range (1-7250 MHz)`);\n        }\n        \n        // Prepare arguments\n        // Using smaller bin width (20kHz) to reduce memory usage\n        const args = [\n          '-f', `${Math.floor(freqMinMHz)}:${Math.ceil(freqMaxMHz)}`,\n          '-g', '20',\n          '-l', '32',\n          '-w', '20000'  // Reduced from 100kHz to 20kHz\n        ];\n        \n        logInfo(`🚀 Starting hackrf_sweep for ${centerFreqMHz} MHz`);\n        logInfo(`📋 Command: hackrf_sweep ${args.join(' ')}`);\n        logInfo(`📍 Sweep parameters:`, {\n          centerFreq: `${frequency.value} ${frequency.unit}`,\n          range: `${freqMinMHz} - ${freqMaxMHz} MHz`,\n          binWidth: `20000 Hz (20 kHz)`,\n          gain: '20 dB',\n          lnaGain: '32 dB'\n        });\n        \n        // Update health state\n        this.cyclingHealth.processStartupPhase = 'spawning';\n        this.processStartTime = Date.now();\n        \n        // Spawn process\n        this.sweepProcess = spawn('hackrf_sweep', args, {\n          detached: true,\n          stdio: ['ignore', 'pipe', 'pipe']\n        });\n        \n        this.sweepProcessPgid = this.sweepProcess.pid || null;\n        this.actualProcessPid = this.sweepProcess.pid || null;\n        \n        logInfo(`✅ Process spawned with PID: ${this.actualProcessPid}, PGID: ${this.sweepProcessPgid}`);\n        \n        let processStarted = false;\n        let startupTimeout: ReturnType<typeof setTimeout> | null = null;\n        \n        // Set startup detection timeout\n        startupTimeout = setTimeout(() => {\n          if (!processStarted) {\n            logInfo('⏰ Startup detection timeout - allowing process to continue');\n            processStarted = true;\n            resolve();\n          }\n        }, this.processStartupDetectionMs);\n        \n        // Handle stdout\n        this.sweepProcess.stdout?.on('data', (data) => {\n          if (!processStarted) {\n            processStarted = true;\n            logInfo('✅ Process startup detected via stdout');\n            if (startupTimeout) {\n              clearTimeout(startupTimeout);\n            }\n            resolve();\n          }\n          \n          // Process output data with buffer overflow protection\n          const newData = data.toString();\n          \n          // Check buffer size before appending\n          if (this.stdoutBuffer.length + newData.length > this.maxBufferSize) {\n            logWarn('⚠️ Buffer overflow detected, clearing buffer');\n            this.bufferOverflowCount++;\n            this.stdoutBuffer = newData; // Reset with just new data\n            \n            if (this.bufferOverflowCount > 10) {\n              logError('Too many buffer overflows, process may be outputting too fast', null, 'buffer-overflow');\n              this._emitError('Buffer overflow - process outputting too fast', 'buffer_overflow');\n            }\n          } else {\n            this.stdoutBuffer += newData;\n          }\n          \n          let newlineIndex;\n          while ((newlineIndex = this.stdoutBuffer.indexOf('\\n')) >= 0) {\n            const line = this.stdoutBuffer.substring(0, newlineIndex).trim();\n            this.stdoutBuffer = this.stdoutBuffer.substring(newlineIndex + 1);\n            \n            if (line) {\n              try {\n                this._handleProcessOutputLine(line, frequency);\n              } catch (e) {\n                logError('Error processing line', { error: e }, 'line-processing');\n              }\n            }\n          }\n        });\n        \n        // Handle stderr\n        this.sweepProcess.stderr!.on('data', (data) => {\n          const message = data.toString().trim();\n          logWarn('stderr from process', { pid: this.actualProcessPid, message }, 'process-stderr');\n          \n          // Check for USB errors that can occur during operation\n          if (message.includes('libusb_submit_transfer') || \n              message.includes('hackrf_is_streaming') ||\n              message.includes('USB error') ||\n              message.includes('Device not found') ||\n              message.includes('usb_claim_interface error') ||\n              message.includes('HACKRF_ERROR')) {\n            logError('USB/Device error detected', { message }, 'usb-error');\n            this._emitError(`USB/Device error: ${message}`, 'usb_error');\n            \n            // Log device state\n            logInfo('Device state at error', {\n              status: this.deviceState.status,\n              lastSuccessful: this.deviceState.lastSuccessfulOperation?.toISOString(),\n              consecutiveBusyErrors: this.deviceState.consecutiveBusyErrors\n            }, 'device-error-state');\n            \n            // Kill the process as it won't recover from USB errors\n            if (this.sweepProcess) {\n              logInfo('Killing process due to USB error', null, 'usb-error-kill');\n              this.sweepProcess.kill('SIGTERM');\n            }\n          }\n          \n          if (!processStarted && this._isCriticalStartupError(message)) {\n            logError('Critical startup error detected', { message }, 'startup-error');\n            if (startupTimeout) {\n              clearTimeout(startupTimeout);\n            }\n            reject(new Error(message));\n          }\n        });\n        \n        // Handle process exit\n        this.sweepProcess.on('exit', (code, signal) => {\n          logInfo('Process exit event', {\n            code,\n            signal,\n            pid: this.actualProcessPid,\n            state: {\n              isRunning: this.isRunning,\n              inFrequencyTransition: this.inFrequencyTransition\n            },\n            recovery: {\n              attempts: this.cyclingHealth.recovery.recoveryAttempts,\n              maxAttempts: this.cyclingHealth.recovery.maxRecoveryAttempts\n            }\n          }, 'process-exit');\n          \n          // Log more details about the exit\n          let exitReason = 'Unknown';\n          if (code === 137 || signal === 'SIGKILL') {\n            exitReason = 'Process was killed (possibly OOM)';\n            logError('Process was killed (possibly OOM)', { code, signal }, 'process-kill-oom');\n          } else if (code === 139 || signal === 'SIGSEGV') {\n            exitReason = 'Process segmentation fault';\n            logError('Process segmentation fault', { code, signal }, 'process-segfault');\n          } else if (code === 1) {\n            exitReason = 'Process general error (device issue?)';\n            logError('Process general error (device issue?)', { code, signal }, 'process-general-error');\n          } else if (signal === 'SIGTERM') {\n            exitReason = 'Process terminated with SIGTERM';\n            logError('Process terminated with SIGTERM', { code, signal }, 'process-sigterm');\n          } else if (code !== 0 && code !== null) {\n            exitReason = `Process exited with code ${code}`;\n            logError('Process exited with non-zero code', { code, signal }, 'process-exit-error');\n          } else if (code === 0) {\n            exitReason = 'Process exited normally';\n            logInfo('Process exited normally', { code, signal }, 'process-exit-normal');\n          }\n          \n          this.sweepProcess = null;\n          this.sweepProcessPgid = null;\n          this.actualProcessPid = null;\n          \n          // Clear monitoring\n          if (this.processMonitorInterval) {\n            clearInterval(this.processMonitorInterval);\n            this.processMonitorInterval = null;\n          }\n          if (this.dataTimeoutTimer) {\n            clearTimeout(this.dataTimeoutTimer);\n            this.dataTimeoutTimer = null;\n          }\n          \n          // If we're still supposed to be running, this is unexpected\n          if (this.isRunning && !this.inFrequencyTransition) {\n            logError('Process died unexpectedly while isRunning=true', { exitReason }, 'process-unexpected-death');\n            this._emitError(`HackRF process terminated unexpectedly: ${exitReason}`, 'process_died');\n            \n            // Trigger recovery\n            void this._performRecovery(`Process died unexpectedly: ${exitReason}`);\n          } else {\n            logInfo('Process exit during expected state (not running or in transition)', { exitReason }, 'process-expected-exit');\n          }\n        });\n        \n        // Start process monitoring\n        this._startProcessMonitoring();\n        \n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Stop the sweep process\n   */\n  private async _stopSweepProcess(): Promise<void> {\n    if (!this.sweepProcess) {\n      return;\n    }\n    \n    logInfo('Stopping sweep process', { pid: this.actualProcessPid, pgid: this.sweepProcessPgid }, 'process-stopping');\n    \n    // Clear monitoring first to prevent race conditions\n    if (this.processMonitorInterval) {\n      clearInterval(this.processMonitorInterval);\n      this.processMonitorInterval = null;\n    }\n    if (this.dataTimeoutTimer) {\n      clearTimeout(this.dataTimeoutTimer);\n      this.dataTimeoutTimer = null;\n    }\n    \n    try {\n      // Try SIGTERM first for graceful shutdown\n      if (this.actualProcessPid) {\n        try {\n          process.kill(this.actualProcessPid, 'SIGTERM');\n          logInfo('Sent SIGTERM to process', { pid: this.actualProcessPid }, 'process-sigterm-sent');\n        } catch {\n          logWarn('Process already dead or SIGTERM failed', { pid: this.actualProcessPid }, 'process-sigterm-failed');\n        }\n        \n        // Give it a moment to terminate gracefully\n        await new Promise(resolve => setTimeout(resolve, 100));\n        \n        // Check if process still exists\n        try {\n          process.kill(this.actualProcessPid, 0);\n          // Process still exists, force kill\n          logWarn('Process still alive, sending SIGKILL', { pid: this.actualProcessPid }, 'process-sigkill-needed');\n          process.kill(this.actualProcessPid, 'SIGKILL');\n        } catch {\n          // Process is already dead\n          logInfo('Process terminated successfully', { pid: this.actualProcessPid }, 'process-terminated');\n        }\n      }\n      \n      // Also try to kill the entire process group if we're using detached mode\n      if (this.sweepProcessPgid && this.sweepProcessPgid !== this.actualProcessPid) {\n        try {\n          process.kill(-this.sweepProcessPgid, 'SIGKILL');\n          logInfo('Killed process group', { pgid: this.sweepProcessPgid }, 'process-group-killed');\n        } catch (e) {\n          // Process group might already be dead\n          logError('Process group kill failed', { error: e, pgid: this.sweepProcessPgid }, 'process-group-kill-failed');\n        }\n      }\n    } catch (error) {\n      logError('Error during process termination', { error }, 'process-termination-error');\n    }\n    \n    // Clear process references\n    this.sweepProcess = null;\n    this.sweepProcessPgid = null;\n    this.actualProcessPid = null;\n    \n    // Ensure hackrf_sweep is not running using system command as backup\n    try {\n      await new Promise<void>((resolve) => {\n        exec('pkill -9 -x hackrf_sweep', (error) => {\n          if (error && error.code !== 1) { // Exit code 1 means no processes found\n            logError('pkill error', { error }, 'pkill-error');\n          }\n          resolve();\n        });\n      });\n    } catch (e) {\n      logError('Failed to run pkill', { error: e }, 'pkill-failed');\n    }\n    \n    // Wait for cleanup\n    await new Promise(resolve => setTimeout(resolve, 500));\n  }\n\n  /**\n   * Handle process output line\n   */\n  private _handleProcessOutputLine(line: string, frequency: {value: number; unit: string}): void {\n    try {\n      const parsed = this._parseHackrfOutput(line);\n      if (!parsed) return;\n      \n      // Log data received (only log every 10th line to reduce noise)\n      if (Math.random() < 0.1) {\n        logDebug('Data received', { frequency: parsed.frequency.toFixed(2), power: parsed.db.toFixed(2) }, 'hackrf-data-received');\n      }\n      \n      // Calculate target frequency\n      const _targetFreqMHz = this._convertToMHz(frequency.value, frequency.unit);\n      \n      // Create spectrum data\n      const spectrumData: SpectrumData = {\n        timestamp: new Date().toISOString(),\n        frequency: parsed.frequency,\n        power: parsed.db,\n        unit: 'MHz',\n        binData: parsed.dbValues,\n        metadata: {\n          targetFrequency: frequency,\n          currentIndex: this.currentIndex,\n          totalFrequencies: this.frequencies.length,\n          frequencyRange: parsed.frequencyRange,\n          binWidth: parsed.binWidth,\n          signalStrength: parsed.signalStrength\n        }\n      };\n      \n      // Update last data received time\n      this.cyclingHealth.lastDataReceived = new Date();\n      \n      // Reset data timeout\n      this._resetDataTimeout();\n      \n      // Emit data\n      if (this.sseEmitter) {\n        this.sseEmitter('sweep_data', spectrumData);\n      }\n      \n      this.emit('spectrum', spectrumData);\n      \n    } catch (error) {\n      logError('Error processing output line', { error, line }, 'output-processing-error');\n    }\n  }\n\n  /**\n   * Parse hackrf_sweep output line\n   */\n  private _parseHackrfOutput(line: string): any {\n    const parts = line.trim().split(/[,\\s]+/).filter(p => p);\n    \n    if (parts.length < 7) return null;\n    \n    try {\n      const date = parts[0];\n      const time = parts[1];\n      const freqLow = parseFloat(parts[2]);    // in Hz\n      const freqHigh = parseFloat(parts[3]);   // in Hz\n      const binWidth = parseFloat(parts[4]);   // in Hz\n      const numSamples = parseInt(parts[5]);\n      \n      const dbValues = [];\n      for (let i = 6; i < parts.length; i++) {\n        const db = parseFloat(parts[i]);\n        if (!isNaN(db)) {\n          dbValues.push(db);\n        }\n      }\n      \n      if (dbValues.length === 0) {\n        return null;\n      }\n      \n      // Find peak signal\n      const maxDb = Math.max(...dbValues);\n      const maxDbIndex = dbValues.indexOf(maxDb);\n      \n      // Calculate peak frequency\n      const peakFrequencyHz = freqLow + (maxDbIndex * binWidth) + (binWidth / 2);\n      const sweepCenterFrequencyHz = (freqLow + freqHigh) / 2;\n      \n      return {\n        date,\n        time,\n        frequencyRange: {\n          low: freqLow,\n          high: freqHigh,\n          center: sweepCenterFrequencyHz\n        },\n        binWidth,\n        numSamples,\n        maxDb,\n        signalStrength: this._getSignalStrength(maxDb),\n        dbValues,\n        frequency: peakFrequencyHz / 1000000, // Convert to MHz\n        unit: 'MHz',\n        db: maxDb,\n        peakBinIndex: maxDbIndex\n      };\n    } catch (error) {\n      logError('Error parsing hackrf output', { error }, 'hackrf-parsing-error');\n      return null;\n    }\n  }\n\n  /**\n   * Get signal strength category\n   */\n  private _getSignalStrength(dB: number): string {\n    if (dB < -90) return 'No Signal';\n    if (dB >= -90 && dB < -70) return 'Very Weak';\n    if (dB >= -70 && dB < -50) return 'Weak';\n    if (dB >= -50 && dB < -30) return 'Moderate';\n    if (dB >= -30 && dB < -10) return 'Strong';\n    return 'Very Strong';\n  }\n\n  /**\n   * Test HackRF availability\n   */\n  private async _testHackrfAvailability(): Promise<{available: boolean; reason: string; deviceInfo?: string}> {\n    return new Promise((resolve) => {\n      exec('timeout 3 hackrf_info', (error, stdout, stderr) => {\n        if (error) {\n          if (error.code === 124) {\n            resolve({ available: false, reason: 'Device check timeout' });\n          } else {\n            resolve({ available: false, reason: `Device check failed: ${error.message}` });\n          }\n        } else if (stderr.includes('Resource busy')) {\n          resolve({ available: false, reason: 'Device busy' });\n        } else if (stderr.includes('No HackRF boards found')) {\n          resolve({ available: false, reason: 'No HackRF found' });\n        } else if (stdout.includes('Serial number')) {\n          // Extract device info\n          const deviceInfo = stdout.split('\\n').filter(line => line.trim()).join(', ');\n          resolve({ available: true, reason: 'HackRF detected', deviceInfo });\n        } else {\n          resolve({ available: false, reason: 'Unknown error' });\n        }\n      });\n    });\n  }\n\n  /**\n   * Force cleanup existing processes\n   */\n  private async _forceCleanupExistingProcesses(): Promise<void> {\n    logInfo('Force cleaning up existing HackRF processes', null, 'hackrf-cleanup-start');\n    \n    try {\n      // Only kill hackrf_sweep processes that aren't ours\n      if (this.sweepProcessPgid) {\n        // Kill all hackrf_sweep processes except our current process group\n        await new Promise<void>((resolve) => {\n          exec(`pgrep -x hackrf_sweep | grep -v \"^${this.sweepProcessPgid}$\" | xargs -r kill -9`, () => resolve());\n        });\n      } else {\n        // No current process, safe to kill all\n        await new Promise<void>((resolve) => {\n          exec('pkill -9 -x hackrf_sweep', () => resolve());\n        });\n      }\n      \n      // Kill any hackrf_info processes\n      await new Promise<void>((resolve) => {\n        exec('pkill -9 -f hackrf_info', () => resolve());\n      });\n      \n      // Wait for cleanup\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      logInfo('Cleanup complete', null, 'hackrf-cleanup-complete');\n    } catch (error) {\n      logError('Cleanup failed', { error }, 'hackrf-cleanup-failed');\n    }\n  }\n\n  /**\n   * Check if error is critical startup error\n   */\n  private _isCriticalStartupError(message: string): boolean {\n    const criticalErrors = [\n      'No HackRF boards found',\n      'hackrf_open() failed',\n      'Resource busy',\n      'Permission denied',\n      'libusb_open() failed',\n      'USB error',\n      'hackrf_is_streaming() failed',\n      'hackrf_start_rx() failed'\n    ];\n    \n    return criticalErrors.some(error => \n      message.toLowerCase().includes(error.toLowerCase())\n    );\n  }\n\n  /**\n   * Normalize frequencies to standard format\n   */\n  private _normalizeFrequencies(frequencies: any[]): Array<{value: number; unit: string}> {\n    return frequencies.map(freq => {\n      if (typeof freq === 'number') {\n        return { value: freq, unit: 'MHz' };\n      } else if (freq.frequency !== undefined) {\n        return { value: freq.frequency, unit: freq.unit || 'MHz' };\n      } else if (freq.value !== undefined) {\n        return { value: freq.value, unit: freq.unit || 'MHz' };\n      }\n      throw new Error('Invalid frequency format');\n    }).filter(f => f.value > 0);\n  }\n\n  /**\n   * Convert frequency to Hz\n   */\n  private _convertToHz(value: number, unit: string): number {\n    switch (unit.toLowerCase()) {\n      case 'hz': return value;\n      case 'khz': return value * 1000;\n      case 'mhz': return value * 1000000;\n      case 'ghz': return value * 1000000000;\n      default: return value * 1000000; // Default to MHz\n    }\n  }\n\n  /**\n   * Convert frequency to MHz\n   */\n  private _convertToMHz(value: number, unit: string): number {\n    switch (unit.toLowerCase()) {\n      case 'hz': return value / 1000000;\n      case 'khz': return value / 1000;\n      case 'mhz': return value;\n      case 'ghz': return value * 1000;\n      default: return value;\n    }\n  }\n\n  /**\n   * Reset error tracking\n   */\n  private _resetErrorTracking(): void {\n    this.consecutiveErrors = 0;\n    this.recentFailures = [];\n    this.frequencyErrors.clear();\n  }\n\n  /**\n   * Handle sweep errors\n   */\n  private _handleSweepError(error: Error, frequency: {value: number; unit: string}): void {\n    logError('Sweep error', { error, frequency }, 'sweep-error');\n    \n    this.consecutiveErrors++;\n    this.recentFailures.push(Date.now());\n    \n    // Track frequency-specific errors\n    const freqHz = this._convertToHz(frequency.value, frequency.unit);\n    this.frequencyErrors.set(freqHz, (this.frequencyErrors.get(freqHz) || 0) + 1);\n    \n    // Check if we should blacklist this frequency\n    if (this.frequencyErrors.get(freqHz)! > 3) {\n      this.frequencyBlacklist.add(freqHz);\n      logWarn('Blacklisting frequency', { frequency: frequency.value, unit: frequency.unit }, 'frequency-blacklisted');\n    }\n    \n    // Emit error event\n    this._emitError(error.message, 'sweep_error', error);\n    \n    // Check if we should stop\n    if (this.consecutiveErrors >= this.maxConsecutiveErrors) {\n      logError('Too many consecutive errors - stopping sweep', { consecutiveErrors: this.consecutiveErrors, maxErrors: this.maxConsecutiveErrors }, 'sweep-error-limit');\n      void this.stopSweep();\n    }\n  }\n\n  /**\n   * Emit event via SSE and EventEmitter\n   */\n  private _emitEvent(event: string, data: any): void {\n    if (this.sseEmitter) {\n      try {\n        this.sseEmitter(event, data);\n      } catch (error) {\n        // SSE connection might be closed, clear the emitter\n        logWarn('SSE emitter error, clearing reference:', error);\n        this.sseEmitter = null;\n      }\n    }\n    // Only emit to EventEmitter if there are listeners\n    if (this.listenerCount(event) > 0) {\n      this.emit(event, data);\n    }\n  }\n\n  /**\n   * Emit error event\n   */\n  private _emitError(message: string, type: string, error?: Error): void {\n    const errorData = {\n      message,\n      type,\n      timestamp: new Date().toISOString(),\n      details: error?.stack\n    };\n    \n    this._emitEvent('error', errorData);\n    logError(`❌ ${type}: ${message}`, { type, details: error?.stack });\n  }\n\n  /**\n   * Perform recovery operation\n   */\n  private async _performRecovery(reason: string): Promise<void> {\n    logInfo('Recovery triggered', {\n      reason,\n      attempts: this.cyclingHealth.recovery.recoveryAttempts,\n      maxAttempts: this.cyclingHealth.recovery.maxRecoveryAttempts,\n      isRecovering: this.cyclingHealth.recovery.isRecovering,\n      lastRecovery: this.cyclingHealth.recovery.lastRecoveryAttempt?.toISOString()\n    }, 'recovery-triggered');\n    \n    // Check if we can still recover\n    if (this.cyclingHealth.recovery.recoveryAttempts >= this.cyclingHealth.recovery.maxRecoveryAttempts) {\n      logError('Max recovery attempts reached, stopping sweep', {\n        attempts: this.cyclingHealth.recovery.recoveryAttempts,\n        reason: reason,\n        processState: {\n          isRunning: this.isRunning,\n          sweepProcess: !!this.sweepProcess,\n          pid: this.actualProcessPid\n        }\n      }, 'recovery-max-attempts');\n      this._emitError('Max recovery attempts reached', 'recovery_failed');\n      // Ensure status is properly updated before stopping\n      this.status = { state: 'stopping' };\n      this._emitEvent('status', this.status);\n      await this.stopSweep();\n      return;\n    }\n    \n    // Check recovery cooldown (don't recover too frequently)\n    if (this.cyclingHealth.recovery.lastRecoveryAttempt) {\n      const timeSinceLastRecovery = Date.now() - this.cyclingHealth.recovery.lastRecoveryAttempt.getTime();\n      if (timeSinceLastRecovery < 10000) { // 10 second cooldown\n        logInfo('Recovery cooldown active', { timeSinceLastRecovery: Math.round(timeSinceLastRecovery / 1000) }, 'recovery-cooldown');\n        return;\n      }\n    }\n    \n    logInfo('Starting recovery attempt', { \n      attempt: this.cyclingHealth.recovery.recoveryAttempts + 1,\n      maxAttempts: this.cyclingHealth.recovery.maxRecoveryAttempts,\n      reason \n    }, 'recovery-attempt-start');\n    this.cyclingHealth.recovery.isRecovering = true;\n    this.cyclingHealth.recovery.recoveryAttempts++;\n    this.cyclingHealth.recovery.lastRecoveryAttempt = new Date();\n    \n    this._emitEvent('recovery_start', {\n      reason,\n      attempt: this.cyclingHealth.recovery.recoveryAttempts,\n      maxAttempts: this.cyclingHealth.recovery.maxRecoveryAttempts\n    });\n    \n    try {\n      // Kill existing process\n      if (this.sweepProcess) {\n        await this._stopSweepProcess();\n      }\n      \n      // Force cleanup\n      await this._forceCleanupExistingProcesses();\n      \n      // Wait a bit\n      await new Promise(resolve => setTimeout(resolve, 2000));\n      \n      // Restart current frequency\n      if (this.frequencies.length > 0 && this.isRunning) {\n        const frequency = this.frequencies[this.currentIndex];\n        await this._startSweepProcess(frequency);\n        \n        logInfo('Recovery completed', { reason, attempt: this.cyclingHealth.recovery.recoveryAttempts }, 'recovery-complete');\n        this._emitEvent('recovery_complete', {\n          reason,\n          attempt: this.cyclingHealth.recovery.recoveryAttempts\n        });\n      }\n    } catch (error: any) {\n      logError('Recovery failed', { error, reason }, 'recovery-failed');\n      this._emitError(`Recovery failed: ${error.message}`, 'recovery_error');\n      \n      // Stop if recovery fails\n      await this.stopSweep();\n    } finally {\n      this.cyclingHealth.recovery.isRecovering = false;\n    }\n  }\n\n  /**\n   * Start process monitoring\n   */\n  private _startProcessMonitoring(): void {\n    // Clear any existing monitoring\n    if (this.processMonitorInterval) {\n      clearInterval(this.processMonitorInterval);\n    }\n    \n    // Monitor process every 2 seconds\n    this.processMonitorInterval = setInterval(() => {\n      if (!this.sweepProcess || !this.actualProcessPid) return;\n      \n      try {\n        // Check if process is still alive\n        process.kill(this.actualProcessPid, 0);\n        \n        // Also check buffer health\n        if (this.stdoutBuffer.length > this.maxBufferSize * 0.8) {\n          logWarn('Buffer size warning', { bufferSizeKB: Math.round(this.stdoutBuffer.length / 1024) }, 'buffer-size-warning');\n        }\n      } catch {\n        logError('Process monitor: Process no longer exists', { pid: this.actualProcessPid }, 'process-dead');\n        // Process is dead, trigger exit handler\n        if (this.sweepProcess) {\n          this.sweepProcess.emit('exit', null, 'UNKNOWN');\n        }\n      }\n    }, 2000);\n    \n    // Set up data timeout monitoring\n    this._resetDataTimeout();\n  }\n  \n  /**\n   * Reset data timeout timer\n   */\n  private _resetDataTimeout(): void {\n    if (this.dataTimeoutTimer) {\n      clearTimeout(this.dataTimeoutTimer);\n    }\n    \n    // Set timeout for 120 seconds (increased from 90)\n    this.dataTimeoutTimer = setTimeout(() => {\n      if (this.isRunning && !this.inFrequencyTransition) {\n        logWarn('No data received for 120 seconds', {\n          lastDataReceived: this.cyclingHealth.lastDataReceived?.toISOString(),\n          isRunning: this.isRunning,\n          sweepProcess: !!this.sweepProcess,\n          pid: this.actualProcessPid,\n          inFrequencyTransition: this.inFrequencyTransition\n        }, 'data-timeout');\n        void this._performRecovery('No data timeout');\n      }\n    }, 7200000);  // 2 hours timeout for long-term monitoring\n  }\n\n  /**\n   * Check system memory\n   */\n  private async _checkSystemMemory(): Promise<{availablePercent: number; totalMB: number; availableMB: number}> {\n    return new Promise((resolve, reject) => {\n      exec('free -m', (error, stdout) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        \n        const lines = stdout.trim().split('\\n');\n        const memLine = lines[1]; // \"Mem:\" line\n        const parts = memLine.split(/\\s+/);\n        \n        const totalMB = parseInt(parts[1]);\n        const availableMB = parseInt(parts[6] || parts[3]); // Try \"available\" column first, then \"free\"\n        const availablePercent = Math.round((availableMB / totalMB) * 100);\n        \n        resolve({ availablePercent, totalMB, availableMB });\n      });\n    });\n  }\n\n  /**\n   * Clean up resources\n   */\n  async cleanup(): Promise<void> {\n    // Stop health monitoring\n    if (this.healthMonitorInterval) {\n      clearInterval(this.healthMonitorInterval);\n    }\n    \n    // Stop process monitoring\n    if (this.processMonitorInterval) {\n      clearInterval(this.processMonitorInterval);\n    }\n    \n    // Clear data timeout\n    if (this.dataTimeoutTimer) {\n      clearTimeout(this.dataTimeoutTimer);\n    }\n    \n    // Stop any running sweep\n    await this.emergencyStop();\n  }\n}\n\n// Singleton instance\nexport const sweepManager = new SweepManager();\n\n// Export getter function for consistency\nexport function getSweepManager(): SweepManager {\n  return sweepManager;\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/server/hackrf/types.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 56,
				"column": 20,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 56,
				"endColumn": 23,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [1354, 1357], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [1354, 1357], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 70,
				"column": 34,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 70,
				"endColumn": 37,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [1597, 1600], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [1597, 1600], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 2,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "// HackRF API Types and Interfaces\n\nexport interface SweepConfig {\n  centerFrequency: number;\n  bandwidth?: number;\n  sampleRate?: number;\n  lnaGain?: number;\n  vgaGain?: number;\n  txvgaGain?: number;\n  ampEnable?: boolean;\n  antennaEnable?: boolean;\n  binSize?: number;\n  numSweeps?: number;\n  sweepRate?: number;\n  // Support for multi-frequency cycling\n  frequencies?: Array<{value: number; unit: string}>;\n  cycleTime?: number; // Time per frequency in ms\n}\n\nexport interface SweepStatus {\n  state: 'idle' | 'running' | 'stopping' | 'error';\n  currentFrequency?: number;\n  sweepProgress?: number;\n  totalSweeps?: number;\n  completedSweeps?: number;\n  startTime?: number;\n  error?: string;\n}\n\nexport interface SpectrumDataPoint {\n  frequency: number;\n  power: number;\n  timestamp: number;\n}\n\nexport interface SpectrumData {\n  timestamp: string;\n  frequency: number;  // Peak frequency in MHz\n  power: number;      // Peak power in dB\n  unit?: string;\n  binData?: number[]; // Array of power values\n  metadata?: {\n    targetFrequency?: {value: number; unit: string};\n    currentIndex?: number;\n    totalFrequencies?: number;\n    frequencyRange?: {\n      low: number;\n      high: number;\n      center: number;\n    };\n    binWidth?: number;\n    signalStrength?: string;\n    date?: string;\n    time?: string;\n    peakBinIndex?: number;\n    [key: string]: any;\n  };\n}\n\nexport interface HackRFHealth {\n  connected: boolean;\n  serialNumber?: string;\n  firmwareVersion?: string;\n  temperature?: number;\n  deviceInfo?: string;\n  error?: string;\n  lastUpdate: number;\n}\n\nexport interface ApiResponse<T = any> {\n  success: boolean;\n  data?: T;\n  error?: string;\n  timestamp: number;\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/server/kismet/index.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/server/kismet/kismetProxy.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unsafe-return",
				"severity": 2,
				"message": "Unsafe return of a value of type `any`.",
				"line": 46,
				"column": 7,
				"nodeType": "ReturnStatement",
				"messageId": "unsafeReturn",
				"endLine": 46,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 78,
				"column": 20,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 78,
				"endColumn": 23,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [2549, 2552], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [2549, 2552], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .regex on an `any` value.",
				"line": 92,
				"column": 15,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 92,
				"endColumn": 20
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 96,
				"column": 42,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 96,
				"endColumn": 45,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [3035, 3038], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [3035, 3038], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 209,
				"column": 39,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 209,
				"endColumn": 42,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [6199, 6202], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [6199, 6202], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 210,
				"column": 34,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 210,
				"endColumn": 37,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [6253, 6256], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [6253, 6256], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-return",
				"severity": 2,
				"message": "Unsafe return of a value of type `any`.",
				"line": 211,
				"column": 7,
				"nodeType": "ReturnStatement",
				"messageId": "unsafeReturn",
				"endLine": 211,
				"endColumn": 70
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-return",
				"severity": 2,
				"message": "Unsafe return of a value of type `any`.",
				"line": 211,
				"column": 52,
				"nodeType": "ChainExpression",
				"messageId": "unsafeReturn",
				"endLine": 211,
				"endColumn": 63
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access [part] on an `any` value.",
				"line": 211,
				"column": 58,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 211,
				"endColumn": 62
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
				"line": 214,
				"column": 37,
				"nodeType": "CallExpression",
				"messageId": "unsafeArgument",
				"endLine": 214,
				"endColumn": 83
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 215,
				"column": 11,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 215,
				"endColumn": 78
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 216,
				"column": 11,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 216,
				"endColumn": 73
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 219,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 219,
				"endColumn": 74
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 220,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 220,
				"endColumn": 59
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 221,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 221,
				"endColumn": 112
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
				"line": 221,
				"column": 62,
				"nodeType": "CallExpression",
				"messageId": "unsafeArgument",
				"endLine": 221,
				"endColumn": 111
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 223,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 223,
				"endColumn": 65
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 224,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 224,
				"endColumn": 69
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 225,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 225,
				"endColumn": 63
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 228,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 228,
				"endColumn": 76
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 229,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 229,
				"endColumn": 74
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type `any` assigned to a parameter of type `number`.",
				"line": 230,
				"column": 44,
				"nodeType": "Identifier",
				"messageId": "unsafeArgument",
				"endLine": 230,
				"endColumn": 61
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'mac' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 267,
				"column": 38,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 267,
				"endColumn": 41
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 276,
				"column": 48,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 276,
				"endColumn": 51,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [8836, 8839], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [8836, 8839], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 280,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 280,
				"endColumn": 28
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .lat on an `any` value.",
				"line": 280,
				"column": 25,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 280,
				"endColumn": 28
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 281,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 281,
				"endColumn": 28
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .lon on an `any` value.",
				"line": 281,
				"column": 25,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 281,
				"endColumn": 28
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 282,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 282,
				"endColumn": 28
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .alt on an `any` value.",
				"line": 282,
				"column": 25,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 282,
				"endColumn": 28
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 289,
				"column": 48,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 289,
				"endColumn": 51,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [9140, 9143], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [9140, 9143], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 296,
				"column": 47,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 296,
				"endColumn": 50,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [9304, 9307], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [9304, 9307], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 296,
				"column": 61,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 296,
				"endColumn": 64,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [9318, 9321], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [9318, 9321], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 306,
				"column": 59,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 306,
				"endColumn": 62,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [9570, 9573], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [9570, 9573], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 306,
				"column": 107,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 306,
				"endColumn": 110,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [9618, 9621], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [9618, 9621], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 322,
				"column": 43,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 322,
				"endColumn": 46,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [9999, 10002], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [9999, 10002], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 329,
				"column": 42,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 329,
				"endColumn": 45,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [10140, 10143], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [10140, 10143], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 25,
		"fatalErrorCount": 0,
		"warningCount": 12,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "// Proxy for Kismet REST API\nimport type { KismetDevice, DeviceFilter, DeviceStats } from './types';\n\nexport class KismetProxy {\n  // Read configuration from environment variables with defaults\n  private static readonly KISMET_HOST = process.env.KISMET_HOST || 'localhost';\n  private static readonly KISMET_PORT = process.env.KISMET_PORT || '2501';\n  private static readonly API_KEY = process.env.KISMET_API_KEY || '';\n  private static readonly KISMET_USER = process.env.KISMET_USER || 'admin';\n  private static readonly KISMET_PASSWORD = process.env.KISMET_PASSWORD || 'admin';\n  private static readonly BASE_URL = `http://${KismetProxy.KISMET_HOST}:${KismetProxy.KISMET_PORT}`;\n\n  /**\n   * Make a request to the Kismet API\n   */\n  private static async request<T>(\n    endpoint: string,\n    options: RequestInit = {}\n  ): Promise<T> {\n    const url = `${this.BASE_URL}${endpoint}`;\n    \n    // Create basic auth header\n    const auth = Buffer.from(`${this.KISMET_USER}:${this.KISMET_PASSWORD}`).toString('base64');\n    \n    const headers: Record<string, string> = {\n      'Authorization': `Basic ${auth}`,\n      'Content-Type': 'application/json',\n      ...options.headers\n    };\n    \n    // If API key is provided, add it as well\n    if (this.API_KEY) {\n      headers['KISMET'] = this.API_KEY;\n    }\n\n    try {\n      const response = await fetch(url, {\n        ...options,\n        headers\n      });\n\n      if (!response.ok) {\n        throw new Error(`Kismet API error: ${response.status} ${response.statusText}`);\n      }\n\n      return await response.json();\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('ECONNREFUSED')) {\n        throw new Error('Cannot connect to Kismet. Is it running?');\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get all devices from Kismet\n   */\n  static async getDevices(filter?: DeviceFilter): Promise<KismetDevice[]> {\n    try {\n      // Kismet uses a specific JSON command structure for queries\n      const fields = [\n        'kismet.device.base.macaddr',\n        'kismet.device.base.name',\n        'kismet.device.base.type',\n        'kismet.device.base.channel',\n        'kismet.device.base.frequency',\n        'kismet.device.base.signal',\n        'kismet.device.base.first_time',\n        'kismet.device.base.last_time',\n        'kismet.device.base.packets.total',\n        'kismet.device.base.packets.data',\n        'kismet.device.base.crypt',\n        'kismet.device.base.location',\n        'kismet.device.base.manuf'\n      ];\n\n      // Build the JSON query\n      const query: any = { fields };\n      \n      // Add filters if provided\n      const regex: Array<[string, string]> = [];\n      \n      if (filter?.ssid) {\n        regex.push(['kismet.device.base.name', filter.ssid]);\n      }\n      \n      if (filter?.manufacturer) {\n        regex.push(['kismet.device.base.manuf', filter.manufacturer]);\n      }\n      \n      if (regex.length > 0) {\n        query.regex = regex;\n      }\n\n      // Use the actual Kismet endpoint\n      const devices = await this.request<any[]>('/devices/views/all/devices.json', {\n        method: 'POST',\n        body: JSON.stringify(query)\n      });\n\n      // Transform and filter the devices\n      let transformedDevices = devices.map(device => this.transformDevice(device));\n      \n      // Apply additional filters that can't be done via Kismet query\n      if (filter) {\n        transformedDevices = this.applyFilters(transformedDevices, filter);\n      }\n\n      return transformedDevices;\n    } catch (error) {\n      console.error('Error fetching devices:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Apply filters that can't be done via Kismet query\n   */\n  private static applyFilters(devices: KismetDevice[], filter: DeviceFilter): KismetDevice[] {\n    return devices.filter(device => {\n      // Filter by type\n      if (filter.type && device.type !== filter.type) {\n        return false;\n      }\n      \n      // Filter by signal strength\n      if (filter.minSignal !== undefined && device.signal !== undefined && device.signal < filter.minSignal) {\n        return false;\n      }\n      \n      if (filter.maxSignal !== undefined && device.signal !== undefined && device.signal > filter.maxSignal) {\n        return false;\n      }\n      \n      // Filter by last seen time\n      if (filter.seenWithin !== undefined) {\n        const lastSeenTime = new Date(device.lastSeen).getTime();\n        const cutoffTime = Date.now() - (filter.seenWithin * 60 * 1000);\n        if (lastSeenTime < cutoffTime) {\n          return false;\n        }\n      }\n      \n      return true;\n    });\n  }\n\n  /**\n   * Get device statistics\n   */\n  static async getDeviceStats(): Promise<DeviceStats> {\n    try {\n      const devices = await this.getDevices();\n      const now = Date.now();\n      const fiveMinAgo = now - 5 * 60 * 1000;\n      const fifteenMinAgo = now - 15 * 60 * 1000;\n\n      const stats: DeviceStats = {\n        total: devices.length,\n        byType: {\n          AP: 0,\n          Client: 0,\n          Bridge: 0,\n          Unknown: 0\n        },\n        byEncryption: {},\n        byManufacturer: {},\n        activeInLast5Min: 0,\n        activeInLast15Min: 0\n      };\n\n      devices.forEach(device => {\n        // Count by type\n        stats.byType[device.type]++;\n\n        // Count by encryption\n        if (device.encryptionType) {\n          device.encryptionType.forEach(enc => {\n            stats.byEncryption[enc] = (stats.byEncryption[enc] || 0) + 1;\n          });\n        }\n\n        // Count by manufacturer\n        if (device.manufacturer) {\n          stats.byManufacturer[device.manufacturer] = \n            (stats.byManufacturer[device.manufacturer] || 0) + 1;\n        }\n\n        // Count active devices\n        const lastSeenTime = new Date(device.lastSeen).getTime();\n        if (lastSeenTime > fiveMinAgo) {\n          stats.activeInLast5Min++;\n        }\n        if (lastSeenTime > fifteenMinAgo) {\n          stats.activeInLast15Min++;\n        }\n      });\n\n      return stats;\n    } catch (error) {\n      console.error('Error calculating device stats:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Transform raw Kismet device data to our format\n   */\n  private static transformDevice(raw: any): KismetDevice {\n    const getNestedValue = (obj: any, path: string) => {\n      return path.split('.').reduce((acc, part) => acc?.[part], obj);\n    };\n\n    const type = this.mapDeviceType(getNestedValue(raw, 'kismet.device.base.type'));\n    const encryptionBitmask = getNestedValue(raw, 'kismet.device.base.crypt');\n    const manufacturer = getNestedValue(raw, 'kismet.device.base.manuf');\n    \n    return {\n      mac: getNestedValue(raw, 'kismet.device.base.macaddr') || 'Unknown',\n      ssid: getNestedValue(raw, 'kismet.device.base.name'),\n      manufacturer: manufacturer || this.extractManufacturer(getNestedValue(raw, 'kismet.device.base.macaddr')),\n      type,\n      channel: getNestedValue(raw, 'kismet.device.base.channel'),\n      frequency: getNestedValue(raw, 'kismet.device.base.frequency'),\n      signal: getNestedValue(raw, 'kismet.device.base.signal'),\n      firstSeen: new Date(getNestedValue(raw, 'kismet.device.base.first_time') * 1000).toISOString(),\n      lastSeen: new Date(getNestedValue(raw, 'kismet.device.base.last_time') * 1000).toISOString(),\n      packets: getNestedValue(raw, 'kismet.device.base.packets.total') || 0,\n      dataPackets: getNestedValue(raw, 'kismet.device.base.packets.data'),\n      encryptionType: this.parseEncryption(encryptionBitmask),\n      location: this.extractLocation(getNestedValue(raw, 'kismet.device.base.location'))\n    };\n  }\n\n  /**\n   * Map Kismet device type to our type\n   */\n  private static mapDeviceType(kismetType: string): KismetDevice['type'] {\n    const typeMap: Record<string, KismetDevice['type']> = {\n      'Wi-Fi AP': 'AP',\n      'Wi-Fi Client': 'Client',\n      'Wi-Fi Bridge': 'Bridge'\n    };\n    return typeMap[kismetType] || 'Unknown';\n  }\n\n  /**\n   * Parse encryption bitmask to array of encryption types\n   */\n  private static parseEncryption(bitmask: number): string[] {\n    if (!bitmask) return ['Open'];\n    \n    const encryption: string[] = [];\n    // Kismet encryption flags (simplified)\n    if (bitmask & 0x00000001) encryption.push('WEP');\n    if (bitmask & 0x00000002) encryption.push('WPA');\n    if (bitmask & 0x00000004) encryption.push('WPA2');\n    if (bitmask & 0x00000008) encryption.push('WPA3');\n    if (bitmask & 0x00000010) encryption.push('WPS');\n    \n    return encryption.length > 0 ? encryption : ['Unknown'];\n  }\n\n  /**\n   * Extract manufacturer from MAC address\n   */\n  private static extractManufacturer(mac: string): string {\n    // This would normally use an OUI database lookup\n    // For now, return a placeholder\n    return 'Unknown';\n  }\n\n  /**\n   * Extract location data\n   */\n  private static extractLocation(locationData: any): KismetDevice['location'] | undefined {\n    if (!locationData) return undefined;\n    \n    return {\n      lat: locationData.lat,\n      lon: locationData.lon,\n      alt: locationData.alt\n    };\n  }\n\n  /**\n   * Generic proxy method for GET requests\n   */\n  static async proxyGet(path: string): Promise<any> {\n    return this.request(path, { method: 'GET' });\n  }\n\n  /**\n   * Generic proxy method for POST requests\n   */\n  static async proxyPost(path: string, body?: any): Promise<any> {\n    return this.request(path, { \n      method: 'POST',\n      body: body ? JSON.stringify(body) : undefined\n    });\n  }\n\n  /**\n   * Generic proxy method that handles any HTTP method\n   */\n  static async proxy(path: string, method: string, body?: any, headers?: Record<string, string>): Promise<any> {\n    const options: RequestInit = {\n      method,\n      headers: headers\n    };\n\n    if (body && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {\n      options.body = typeof body === 'string' ? body : JSON.stringify(body);\n    }\n\n    return this.request(path, options);\n  }\n\n  /**\n   * Get Kismet system status\n   */\n  static async getSystemStatus(): Promise<any> {\n    return this.request('/system/status.json');\n  }\n\n  /**\n   * Get Kismet datasources\n   */\n  static async getDatasources(): Promise<any> {\n    return this.request('/datasource/all_sources.json');\n  }\n\n  /**\n   * Check if API key is configured\n   */\n  static isApiKeyConfigured(): boolean {\n    return this.API_KEY !== '';\n  }\n\n  /**\n   * Get proxy configuration info\n   */\n  static getConfig() {\n    return {\n      host: this.KISMET_HOST,\n      port: this.KISMET_PORT,\n      baseUrl: this.BASE_URL,\n      apiKeyConfigured: this.isApiKeyConfigured()\n    };\n  }\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/server/kismet/scriptManager.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 14,
				"column": 75,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 14,
				"endColumn": 78,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [547, 550], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [547, 550], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'stats' is assigned a value but never used. Allowed unused vars must match /^_/u.",
				"line": 33,
				"column": 21,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 33,
				"endColumn": 26
			},
			{
				"ruleId": "no-empty",
				"severity": 2,
				"message": "Empty block statement.",
				"line": 40,
				"column": 23,
				"nodeType": "BlockStatement",
				"messageId": "unexpected",
				"endLine": 40,
				"endColumn": 25,
				"suggestions": [
					{
						"messageId": "suggestComment",
						"data": { "type": "block" },
						"fix": { "range": [1352, 1352], "text": " /* empty */ " },
						"desc": "Add comment inside empty block statement."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 92,
				"column": 14,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 92,
				"endColumn": 24
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'output' is assigned a value but never used. Allowed unused vars must match /^_/u.",
				"line": 97,
				"column": 11,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 97,
				"endColumn": 17
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'error' is assigned a value but never used. Allowed unused vars must match /^_/u.",
				"line": 98,
				"column": 11,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 98,
				"endColumn": 16
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 101,
				"column": 19,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 101,
				"endColumn": 32
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .toString on an `any` value.",
				"line": 101,
				"column": 24,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 101,
				"endColumn": 32
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 105,
				"column": 18,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 105,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .toString on an `any` value.",
				"line": 105,
				"column": 23,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 105,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'code' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 109,
				"column": 25,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 109,
				"endColumn": 29
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 171,
				"column": 62,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 171,
				"endColumn": 65,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [4766, 4769], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [4766, 4769], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'error' is defined but never used.",
				"line": 189,
				"column": 14,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 189,
				"endColumn": 19
			}
		],
		"suppressedMessages": [],
		"errorCount": 10,
		"fatalErrorCount": 0,
		"warningCount": 3,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "// Kismet script management\nimport { exec, spawn } from 'child_process';\nimport { promisify } from 'util';\nimport { readdir, stat, access } from 'fs/promises';\nimport { constants } from 'fs';\nimport { join } from 'path';\nimport type { KismetScript, ScriptExecutionResult } from './types';\n\nconst execAsync = promisify(exec);\n\nexport class ScriptManager {\n  private static readonly SCRIPTS_DIR = '/home/pi/Scripts';\n  private static readonly STINKY_DIR = '/home/pi/stinky';\n  private static runningScripts = new Map<string, { pid: number; process: any }>();\n\n  /**\n   * List available scripts\n   */\n  static async listScripts(): Promise<KismetScript[]> {\n    const scripts: KismetScript[] = [];\n    \n    try {\n      // Get scripts from both directories\n      const scriptDirs = [this.SCRIPTS_DIR, this.STINKY_DIR];\n      \n      for (const dir of scriptDirs) {\n        try {\n          const files = await readdir(dir);\n          \n          for (const file of files) {\n            if (file.endsWith('.sh') || file.endsWith('.py')) {\n              const fullPath = join(dir, file);\n              const stats = await stat(fullPath);\n              \n              // Check if executable\n              let executable = false;\n              try {\n                await access(fullPath, constants.X_OK);\n                executable = true;\n              } catch {}\n              \n              // Check if script is running\n              const running = this.runningScripts.has(fullPath);\n              const pid = running ? this.runningScripts.get(fullPath)?.pid : undefined;\n              \n              scripts.push({\n                name: file,\n                path: fullPath,\n                description: this.getScriptDescription(file),\n                executable,\n                running,\n                pid\n              });\n            }\n          }\n        } catch (error) {\n          console.error(`Error reading directory ${dir}:`, error);\n        }\n      }\n      \n      return scripts.sort((a, b) => a.name.localeCompare(b.name));\n    } catch (error) {\n      console.error('Error listing scripts:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Execute a script\n   */\n  static async executeScript(scriptPath: string): Promise<ScriptExecutionResult> {\n    try {\n      // Validate script exists and is executable\n      await access(scriptPath, constants.F_OK | constants.X_OK);\n      \n      // Check if already running\n      if (this.runningScripts.has(scriptPath)) {\n        return {\n          success: false,\n          error: 'Script is already running'\n        };\n      }\n      \n      // Spawn the script\n      const child = spawn(scriptPath, [], {\n        detached: true,\n        stdio: ['ignore', 'pipe', 'pipe']\n      });\n      \n      // Store the running process\n      this.runningScripts.set(scriptPath, {\n        pid: child.pid!,\n        process: child\n      });\n      \n      // Collect output\n      let output = '';\n      let error = '';\n      \n      child.stdout?.on('data', (data) => {\n        output += data.toString();\n      });\n      \n      child.stderr?.on('data', (data) => {\n        error += data.toString();\n      });\n      \n      // Handle process exit\n      child.on('exit', (code) => {\n        this.runningScripts.delete(scriptPath);\n      });\n      \n      // Return immediately for long-running scripts\n      return {\n        success: true,\n        pid: child.pid,\n        output: 'Script started successfully'\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      };\n    }\n  }\n\n  /**\n   * Stop a running script\n   */\n  static async stopScript(scriptPath: string): Promise<ScriptExecutionResult> {\n    try {\n      const running = this.runningScripts.get(scriptPath);\n      if (!running) {\n        return {\n          success: false,\n          error: 'Script is not running'\n        };\n      }\n      \n      // Try graceful shutdown first\n      process.kill(running.pid, 'SIGTERM');\n      \n      // Wait a moment\n      await new Promise(resolve => setTimeout(resolve, 2000));\n      \n      // Check if still running and force kill if needed\n      try {\n        process.kill(running.pid, 0); // Check if process exists\n        process.kill(running.pid, 'SIGKILL');\n      } catch {\n        // Process already terminated\n      }\n      \n      this.runningScripts.delete(scriptPath);\n      \n      return {\n        success: true,\n        output: 'Script stopped successfully'\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      };\n    }\n  }\n\n  /**\n   * Get script execution history from logs\n   */\n  static async getScriptHistory(limit: number = 50): Promise<any[]> {\n    try {\n      // Read from various log files\n      const { stdout } = await execAsync(\n        `grep -h \"script\\\\|Script\" /home/pi/tmp/*.log 2>/dev/null | tail -n ${limit}`\n      );\n      \n      return stdout.trim().split('\\n').filter(Boolean).map(line => {\n        // Parse log lines (simplified)\n        const match = line.match(/(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})\\s+(.+)/);\n        if (match) {\n          return {\n            timestamp: match[1],\n            message: match[2]\n          };\n        }\n        return { message: line };\n      });\n    } catch (error) {\n      return [];\n    }\n  }\n\n  /**\n   * Get a description for known scripts\n   */\n  private static getScriptDescription(filename: string): string {\n    const descriptions: Record<string, string> = {\n      'start_kismet.sh': 'Start Kismet WiFi monitoring',\n      'gps_kismet_wigle.sh': 'Start GPS, Kismet, and WigleToTAK services',\n      'test-hackrf.sh': 'Test HackRF hardware',\n      'test-hackrf-reception.sh': 'Test HackRF reception',\n      'mavgps.py': 'MAVLink to GPSD bridge',\n      'WigleToTak2.py': 'Convert Kismet data to TAK format',\n      'spectrum_analyzer.py': 'HackRF spectrum analyzer'\n    };\n    \n    return descriptions[filename] || '';\n  }\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/server/kismet/serviceManager.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/server/kismet/types.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 96,
				"column": 9,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 96,
				"endColumn": 12,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [1861, 1864], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [1861, 1864], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 1,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "// Kismet API type definitions\n\nexport interface KismetServiceStatus {\n  running: boolean;\n  pid?: number;\n  uptime?: number;\n  memory?: number;\n  cpu?: number;\n  error?: string;\n}\n\nexport interface KismetDevice {\n  mac: string;\n  ssid?: string;\n  manufacturer?: string;\n  type: 'AP' | 'Client' | 'Bridge' | 'Unknown';\n  channel?: number;\n  frequency?: number;\n  signal?: number;\n  lastSeen: string;\n  firstSeen: string;\n  packets: number;\n  dataPackets?: number;\n  encryptionType?: string[];\n  location?: {\n    lat?: number;\n    lon?: number;\n    alt?: number;\n  };\n}\n\nexport interface KismetScript {\n  name: string;\n  path: string;\n  description?: string;\n  executable: boolean;\n  running?: boolean;\n  pid?: number;\n}\n\nexport interface KismetConfig {\n  interfaces: string[];\n  channels: number[];\n  hopRate: number;\n  logLevel: string;\n  logPath: string;\n  alertsEnabled: boolean;\n  gpsEnabled: boolean;\n  remoteCapture?: {\n    enabled: boolean;\n    sources: string[];\n  };\n}\n\nexport interface ScriptExecutionResult {\n  success: boolean;\n  output?: string;\n  error?: string;\n  pid?: number;\n  exitCode?: number;\n}\n\nexport interface DeviceFilter {\n  type?: 'AP' | 'Client' | 'Bridge' | 'Unknown';\n  manufacturer?: string;\n  ssid?: string;\n  minSignal?: number;\n  maxSignal?: number;\n  encryptionType?: string;\n  seenWithin?: number; // minutes\n}\n\nexport interface DeviceStats {\n  total: number;\n  byType: {\n    AP: number;\n    Client: number;\n    Bridge: number;\n    Unknown: number;\n  };\n  byEncryption: Record<string, number>;\n  byManufacturer: Record<string, number>;\n  activeInLast5Min: number;\n  activeInLast15Min: number;\n}\n\nexport interface KismetApiResponse<T> {\n  success: boolean;\n  data?: T;\n  error?: string;\n  timestamp: string;\n}\n\nexport interface WebSocketMessage {\n  type: 'device_update' | 'alert' | 'status_change' | 'log' | 'error';\n  data: any;\n  timestamp: string;\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/server/kismet/webSocketManager.ts",
		"messages": [
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'NodeJS' is not defined.",
				"line": 22,
				"column": 29,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 22,
				"endColumn": 35
			},
			{
				"ruleId": "@typescript-eslint/no-floating-promises",
				"severity": 2,
				"message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
				"line": 65,
				"column": 5,
				"nodeType": "ExpressionStatement",
				"messageId": "floatingVoid",
				"endLine": 65,
				"endColumn": 27,
				"suggestions": [
					{
						"messageId": "floatingFixVoid",
						"fix": { "range": [1719, 1719], "text": "void " },
						"desc": "Add void operator to ignore."
					},
					{
						"messageId": "floatingFixAwait",
						"fix": { "range": [1719, 1719], "text": "await " },
						"desc": "Add await operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-floating-promises",
				"severity": 2,
				"message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
				"line": 69,
				"column": 7,
				"nodeType": "ExpressionStatement",
				"messageId": "floatingVoid",
				"endLine": 69,
				"endColumn": 29,
				"suggestions": [
					{
						"messageId": "floatingFixVoid",
						"fix": { "range": [1826, 1826], "text": "void " },
						"desc": "Add void operator to ignore."
					},
					{
						"messageId": "floatingFixAwait",
						"fix": { "range": [1826, 1826], "text": "await " },
						"desc": "Add await operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 96,
				"column": 13,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 96,
				"endColumn": 44
			},
			{
				"ruleId": "@typescript-eslint/no-floating-promises",
				"severity": 2,
				"message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
				"line": 108,
				"column": 9,
				"nodeType": "ExpressionStatement",
				"messageId": "floatingVoid",
				"endLine": 108,
				"endColumn": 33,
				"suggestions": [
					{
						"messageId": "floatingFixVoid",
						"fix": { "range": [2818, 2818], "text": "void " },
						"desc": "Add void operator to ignore."
					},
					{
						"messageId": "floatingFixAwait",
						"fix": { "range": [2818, 2818], "text": "await " },
						"desc": "Add await operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 123,
				"column": 45,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 123,
				"endColumn": 48,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [3174, 3177], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [3174, 3177], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 124,
				"column": 11,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 124,
				"endColumn": 61
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.device.base.key'] on an `any` value.",
				"line": 124,
				"column": 36,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 124,
				"endColumn": 60
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 125,
				"column": 11,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 125,
				"endColumn": 63
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.device.base.macaddr'] on an `any` value.",
				"line": 125,
				"column": 34,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 125,
				"endColumn": 62
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 131,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 131,
				"endColumn": 19
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 132,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 132,
				"endColumn": 58
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.device.base.name'] on an `any` value.",
				"line": 132,
				"column": 26,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 132,
				"endColumn": 51
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 133,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 133,
				"endColumn": 74
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.device.base.manuf'] on an `any` value.",
				"line": 133,
				"column": 34,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 133,
				"endColumn": 60
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 135,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 135,
				"endColumn": 58
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.device.base.channel'] on an `any` value.",
				"line": 135,
				"column": 29,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 135,
				"endColumn": 57
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 136,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 136,
				"endColumn": 62
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.device.base.frequency'] on an `any` value.",
				"line": 136,
				"column": 31,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 136,
				"endColumn": 61
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 137,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 137,
				"endColumn": 94
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.device.base.signal'] on an `any` value.",
				"line": 137,
				"column": 28,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 137,
				"endColumn": 55
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.device.base.last_time'] on an `any` value.",
				"line": 138,
				"column": 39,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 138,
				"endColumn": 69
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.device.base.first_time'] on an `any` value.",
				"line": 139,
				"column": 40,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 139,
				"endColumn": 71
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 140,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 140,
				"endColumn": 69
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.device.base.packets.total'] on an `any` value.",
				"line": 140,
				"column": 29,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 140,
				"endColumn": 63
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 141,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 141,
				"endColumn": 72
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.device.base.packets.data'] on an `any` value.",
				"line": 141,
				"column": 33,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 141,
				"endColumn": 66
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
				"line": 147,
				"column": 41,
				"nodeType": "Identifier",
				"messageId": "unsafeArgument",
				"endLine": 147,
				"endColumn": 50
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
				"line": 152,
				"column": 28,
				"nodeType": "Identifier",
				"messageId": "unsafeArgument",
				"endLine": 152,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
				"line": 158,
				"column": 49,
				"nodeType": "Identifier",
				"messageId": "unsafeArgument",
				"endLine": 158,
				"endColumn": 58
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
				"line": 161,
				"column": 34,
				"nodeType": "Identifier",
				"messageId": "unsafeArgument",
				"endLine": 161,
				"endColumn": 43
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 169,
				"column": 33,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 169,
				"endColumn": 36,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [4958, 4961], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [4958, 4961], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 170,
				"column": 11,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 170,
				"endColumn": 51
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.device.base.type'] on an `any` value.",
				"line": 170,
				"column": 25,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 170,
				"endColumn": 50
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 180,
				"column": 38,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 180,
				"endColumn": 41,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [5305, 5308], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [5305, 5308], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 181,
				"column": 11,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 181,
				"endColumn": 53
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.device.base.crypt'] on an `any` value.",
				"line": 181,
				"column": 26,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 181,
				"endColumn": 52
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['Open'] on an `any` value.",
				"line": 186,
				"column": 15,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 186,
				"endColumn": 21
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['WEP'] on an `any` value.",
				"line": 187,
				"column": 15,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 187,
				"endColumn": 20
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['WPA'] on an `any` value.",
				"line": 188,
				"column": 15,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 188,
				"endColumn": 20
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['WPA2'] on an `any` value.",
				"line": 189,
				"column": 15,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 189,
				"endColumn": 21
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['WPA3'] on an `any` value.",
				"line": 190,
				"column": 15,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 190,
				"endColumn": 21
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 198,
				"column": 37,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 198,
				"endColumn": 40,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [5764, 5767], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [5764, 5767], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 199,
				"column": 11,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 199,
				"endColumn": 59
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.device.base.location'] on an `any` value.",
				"line": 199,
				"column": 29,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 199,
				"endColumn": 58
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 203,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 203,
				"endColumn": 50
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.common.location.lat'] on an `any` value.",
				"line": 203,
				"column": 21,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 203,
				"endColumn": 49
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 204,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 204,
				"endColumn": 50
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.common.location.lon'] on an `any` value.",
				"line": 204,
				"column": 21,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 204,
				"endColumn": 49
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 205,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 205,
				"endColumn": 50
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.common.location.alt'] on an `any` value.",
				"line": 205,
				"column": 21,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 205,
				"endColumn": 49
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 268,
				"column": 13,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 268,
				"endColumn": 43
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 274,
				"column": 11,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 274,
				"endColumn": 66
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.system.packets.rate'] on an `any` value.",
				"line": 274,
				"column": 32,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 274,
				"endColumn": 60
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 275,
				"column": 11,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 275,
				"endColumn": 64
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.system.memory.rss'] on an `any` value.",
				"line": 275,
				"column": 32,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 275,
				"endColumn": 58
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 276,
				"column": 11,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 276,
				"endColumn": 61
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.system.cpu.system'] on an `any` value.",
				"line": 276,
				"column": 29,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 276,
				"endColumn": 55
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.system.timestamp.start_sec'] on an `any` value.",
				"line": 277,
				"column": 26,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 277,
				"endColumn": 61
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.system.timestamp.start_sec'] on an `any` value.",
				"line": 278,
				"column": 34,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 278,
				"endColumn": 69
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 279,
				"column": 11,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 279,
				"endColumn": 68
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.system.channels.channels'] on an `any` value.",
				"line": 279,
				"column": 28,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 279,
				"endColumn": 61
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 280,
				"column": 11,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 280,
				"endColumn": 63
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access ['kismet.system.interfaces'] on an `any` value.",
				"line": 280,
				"column": 30,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 280,
				"endColumn": 56
			},
			{
				"ruleId": "no-console",
				"severity": 1,
				"message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
				"line": 321,
				"column": 7,
				"nodeType": "MemberExpression",
				"messageId": "limited",
				"endLine": 321,
				"endColumn": 18,
				"suggestions": [
					{
						"fix": { "range": [9322, 9394], "text": "" },
						"messageId": "removeConsole",
						"data": { "propertyName": "log" },
						"desc": "Remove the console.log()."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 331,
				"column": 15,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 331,
				"endColumn": 52
			},
			{
				"ruleId": "@typescript-eslint/no-base-to-string",
				"severity": 2,
				"message": "'data' may use Object's default stringification format ('[object Object]') when stringified.",
				"line": 331,
				"column": 36,
				"nodeType": "Identifier",
				"messageId": "baseToString",
				"endLine": 331,
				"endColumn": 40
			},
			{
				"ruleId": "no-console",
				"severity": 1,
				"message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
				"line": 359,
				"column": 5,
				"nodeType": "MemberExpression",
				"messageId": "limited",
				"endLine": 359,
				"endColumn": 16,
				"suggestions": [
					{
						"fix": { "range": [10376, 10445], "text": "" },
						"messageId": "removeConsole",
						"data": { "propertyName": "log" },
						"desc": "Remove the console.log()."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 365,
				"column": 55,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 365,
				"endColumn": 58,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [10551, 10554], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [10551, 10554], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .type on an `any` value.",
				"line": 369,
				"column": 21,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 369,
				"endColumn": 25
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .events on an `any` value.",
				"line": 371,
				"column": 21,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 371,
				"endColumn": 27
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 372,
				"column": 11,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 372,
				"endColumn": 33
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .events on an `any` value.",
				"line": 372,
				"column": 19,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 372,
				"endColumn": 25
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .events on an `any` value.",
				"line": 377,
				"column": 21,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 377,
				"endColumn": 27
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 378,
				"column": 11,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 378,
				"endColumn": 33
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .events on an `any` value.",
				"line": 378,
				"column": 19,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 378,
				"endColumn": 25
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 383,
				"column": 9,
				"nodeType": "AssignmentExpression",
				"messageId": "anyAssignment",
				"endLine": 383,
				"endColumn": 38
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .filters on an `any` value.",
				"line": 383,
				"column": 31,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 383,
				"endColumn": 38
			},
			{
				"ruleId": "no-console",
				"severity": 1,
				"message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
				"line": 465,
				"column": 7,
				"nodeType": "MemberExpression",
				"messageId": "limited",
				"endLine": 465,
				"endColumn": 18,
				"suggestions": [
					{
						"fix": { "range": [13062, 13133], "text": "" },
						"messageId": "removeConsole",
						"data": { "propertyName": "log" },
						"desc": "Remove the console.log()."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 71,
		"fatalErrorCount": 0,
		"warningCount": 8,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "// WebSocket management for Kismet real-time data\nimport { WebSocket } from 'ws';\nimport type { WebSocketMessage, KismetDevice } from './types';\nimport { EventEmitter } from 'events';\n\ninterface CachedDevice {\n  device: KismetDevice;\n  lastUpdate: number;\n}\n\ninterface Subscription {\n  types: Set<string>;\n  filters?: {\n    minSignal?: number;\n    deviceTypes?: string[];\n  };\n}\n\nexport class WebSocketManager extends EventEmitter {\n  private static instance: WebSocketManager;\n  private clients = new Map<WebSocket, Subscription>();\n  private pollingInterval?: NodeJS.Timeout;\n  private deviceCache = new Map<string, CachedDevice>();\n  private lastPollTime = 0;\n  private isPolling = false;\n  \n  // Configuration\n  private readonly POLL_INTERVAL = 2000; // 2 seconds\n  private readonly THROTTLE_INTERVAL = 500; // 500ms throttle for updates\n  private readonly CACHE_EXPIRY = 300000; // 5 minutes\n  private readonly KISMET_API_URL = process.env.KISMET_API_URL || 'http://localhost:2501';\n  private readonly KISMET_API_KEY = process.env.KISMET_API_KEY || '';\n  \n  // Throttle management\n  private updateThrottles = new Map<string, number>();\n  private statsThrottle = 0;\n\n  private constructor() {\n    super();\n    this.startPolling();\n    \n    // Cleanup stale cache periodically\n    setInterval(() => this.cleanupCache(), 60000); // Every minute\n  }\n\n  /**\n   * Get singleton instance\n   */\n  static getInstance(): WebSocketManager {\n    if (!this.instance) {\n      this.instance = new WebSocketManager();\n    }\n    return this.instance;\n  }\n\n  /**\n   * Start polling Kismet API\n   */\n  private startPolling() {\n    if (this.pollingInterval) {\n      clearInterval(this.pollingInterval);\n    }\n\n    // Initial poll\n    this.pollKismetData();\n\n    // Set up regular polling\n    this.pollingInterval = setInterval(() => {\n      this.pollKismetData();\n    }, this.POLL_INTERVAL);\n  }\n\n  /**\n   * Poll Kismet for updates\n   */\n  private async pollKismetData() {\n    if (this.isPolling || this.clients.size === 0) {\n      return;\n    }\n\n    this.isPolling = true;\n    const startTime = Date.now();\n\n    try {\n      // Fetch devices from Kismet\n      const response = await fetch(`${this.KISMET_API_URL}/devices/last-time/${this.lastPollTime}/devices.json`, {\n        headers: {\n          'KISMET': this.KISMET_API_KEY\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`Kismet API error: ${response.status}`);\n      }\n\n      const devices = await response.json();\n      \n      // Process device updates\n      for (const device of devices) {\n        this.processDeviceUpdate(device);\n      }\n\n      // Update last poll time\n      this.lastPollTime = Math.floor(startTime / 1000);\n\n      // Emit system status if not throttled\n      if (Date.now() - this.statsThrottle > this.THROTTLE_INTERVAL) {\n        this.emitSystemStatus();\n        this.statsThrottle = Date.now();\n      }\n\n    } catch (error) {\n      console.error('Error polling Kismet:', error);\n      this.emitError('Failed to poll Kismet data');\n    } finally {\n      this.isPolling = false;\n    }\n  }\n\n  /**\n   * Process a device update from Kismet\n   */\n  private processDeviceUpdate(kismetDevice: any) {\n    const deviceKey = kismetDevice['kismet.device.base.key'];\n    const macAddr = kismetDevice['kismet.device.base.macaddr'];\n    \n    if (!deviceKey || !macAddr) return;\n\n    // Transform to our device format\n    const device: KismetDevice = {\n      mac: macAddr,\n      ssid: kismetDevice['kismet.device.base.name'] || '',\n      manufacturer: kismetDevice['kismet.device.base.manuf'] || 'Unknown',\n      type: this.getDeviceType(kismetDevice),\n      channel: kismetDevice['kismet.device.base.channel'],\n      frequency: kismetDevice['kismet.device.base.frequency'],\n      signal: kismetDevice['kismet.device.base.signal']?.['kismet.common.signal.last_signal'],\n      lastSeen: new Date(kismetDevice['kismet.device.base.last_time'] * 1000).toISOString(),\n      firstSeen: new Date(kismetDevice['kismet.device.base.first_time'] * 1000).toISOString(),\n      packets: kismetDevice['kismet.device.base.packets.total'] || 0,\n      dataPackets: kismetDevice['kismet.device.base.packets.data'] || 0,\n      encryptionType: this.getEncryptionTypes(kismetDevice),\n      location: this.getDeviceLocation(kismetDevice)\n    };\n\n    // Check if device has changed\n    const cached = this.deviceCache.get(deviceKey);\n    const hasChanged = !cached || this.hasDeviceChanged(cached.device, device);\n\n    if (hasChanged) {\n      // Update cache\n      this.deviceCache.set(deviceKey, {\n        device,\n        lastUpdate: Date.now()\n      });\n\n      // Check throttle\n      const lastEmit = this.updateThrottles.get(deviceKey) || 0;\n      if (Date.now() - lastEmit > this.THROTTLE_INTERVAL) {\n        this.emitDeviceUpdate(device);\n        this.updateThrottles.set(deviceKey, Date.now());\n      }\n    }\n  }\n\n  /**\n   * Determine device type from Kismet data\n   */\n  private getDeviceType(device: any): 'AP' | 'Client' | 'Bridge' | 'Unknown' {\n    const type = device['kismet.device.base.type'];\n    if (type === 'Wi-Fi AP') return 'AP';\n    if (type === 'Wi-Fi Client') return 'Client';\n    if (type === 'Wi-Fi Bridge') return 'Bridge';\n    return 'Unknown';\n  }\n\n  /**\n   * Extract encryption types\n   */\n  private getEncryptionTypes(device: any): string[] {\n    const crypt = device['kismet.device.base.crypt'];\n    const types: string[] = [];\n    \n    if (!crypt) return types;\n    \n    if (crypt['Open']) types.push('Open');\n    if (crypt['WEP']) types.push('WEP');\n    if (crypt['WPA']) types.push('WPA');\n    if (crypt['WPA2']) types.push('WPA2');\n    if (crypt['WPA3']) types.push('WPA3');\n    \n    return types;\n  }\n\n  /**\n   * Extract device location\n   */\n  private getDeviceLocation(device: any): KismetDevice['location'] | undefined {\n    const location = device['kismet.device.base.location'];\n    if (!location) return undefined;\n    \n    return {\n      lat: location['kismet.common.location.lat'],\n      lon: location['kismet.common.location.lon'],\n      alt: location['kismet.common.location.alt']\n    };\n  }\n\n  /**\n   * Check if device has changed\n   */\n  private hasDeviceChanged(oldDevice: KismetDevice, newDevice: KismetDevice): boolean {\n    return (\n      oldDevice.signal !== newDevice.signal ||\n      oldDevice.channel !== newDevice.channel ||\n      oldDevice.packets !== newDevice.packets ||\n      oldDevice.ssid !== newDevice.ssid ||\n      oldDevice.lastSeen !== newDevice.lastSeen\n    );\n  }\n\n  /**\n   * Emit device update to subscribed clients\n   */\n  private emitDeviceUpdate(device: KismetDevice) {\n    const message: WebSocketMessage = {\n      type: 'device_update',\n      data: device,\n      timestamp: new Date().toISOString()\n    };\n\n    this.broadcast(message, (sub) => {\n      // Check if client is subscribed to device updates\n      if (!sub.types.has('device_update') && !sub.types.has('*')) {\n        return false;\n      }\n\n      // Apply filters\n      if (sub.filters) {\n        if (sub.filters.minSignal && device.signal && device.signal < sub.filters.minSignal) {\n          return false;\n        }\n        if (sub.filters.deviceTypes && !sub.filters.deviceTypes.includes(device.type)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * Emit system status\n   */\n  private async emitSystemStatus() {\n    try {\n      // Get system stats from Kismet\n      const response = await fetch(`${this.KISMET_API_URL}/system/status.json`, {\n        headers: {\n          'KISMET': this.KISMET_API_KEY\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to get system status: ${response.status}`);\n      }\n\n      const status = await response.json();\n      \n      const message: WebSocketMessage = {\n        type: 'status_change',\n        data: {\n          devices_count: this.deviceCache.size,\n          packets_rate: status['kismet.system.packets.rate'] || 0,\n          memory_usage: status['kismet.system.memory.rss'] || 0,\n          cpu_usage: status['kismet.system.cpu.system'] || 0,\n          uptime: status['kismet.system.timestamp.start_sec'] ? \n            Date.now() - (status['kismet.system.timestamp.start_sec'] * 1000) : 0,\n          channels: status['kismet.system.channels.channels'] || [],\n          interfaces: status['kismet.system.interfaces'] || []\n        },\n        timestamp: new Date().toISOString()\n      };\n\n      this.broadcast(message, (sub) => sub.types.has('status_change') || sub.types.has('*'));\n    } catch (error) {\n      console.error('Error emitting system status:', error);\n    }\n  }\n\n  /**\n   * Emit error message\n   */\n  private emitError(errorText: string) {\n    const message: WebSocketMessage = {\n      type: 'error',\n      data: {\n        error: errorText,\n        timestamp: new Date().toISOString()\n      },\n      timestamp: new Date().toISOString()\n    };\n\n    this.broadcast(message);\n  }\n\n  /**\n   * Add a client WebSocket with subscription preferences\n   */\n  addClient(ws: WebSocket, subscription?: Partial<Subscription>) {\n    // Default subscription\n    const sub: Subscription = {\n      types: new Set(subscription?.types || ['device_update', 'status_change', 'alert']),\n      filters: subscription?.filters\n    };\n\n    this.clients.set(ws, sub);\n    \n    ws.on('close', () => {\n      this.clients.delete(ws);\n      console.log(`Client disconnected. Total clients: ${this.clients.size}`);\n    });\n\n    ws.on('error', (error) => {\n      console.error('Client WebSocket error:', error);\n      this.clients.delete(ws);\n    });\n\n    ws.on('message', (data) => {\n      try {\n        const message = JSON.parse(data.toString());\n        this.handleClientMessage(ws, message);\n      } catch (error) {\n        console.error('Error parsing client message:', error);\n      }\n    });\n\n    // Send initial status\n    const statusMessage: WebSocketMessage = {\n      type: 'status_change',\n      data: {\n        connected: true,\n        polling_active: !!this.pollingInterval,\n        clients_connected: this.clients.size,\n        devices_cached: this.deviceCache.size\n      },\n      timestamp: new Date().toISOString()\n    };\n    \n    if (ws.readyState === WebSocket.OPEN) {\n      ws.send(JSON.stringify(statusMessage));\n    }\n\n    // Send cached devices if subscribed\n    if (sub.types.has('device_update') || sub.types.has('*')) {\n      this.sendCachedDevices(ws, sub);\n    }\n\n    console.log(`Client connected. Total clients: ${this.clients.size}`);\n  }\n\n  /**\n   * Handle messages from clients\n   */\n  private handleClientMessage(ws: WebSocket, message: any) {\n    const sub = this.clients.get(ws);\n    if (!sub) return;\n\n    switch (message.type) {\n      case 'subscribe':\n        if (message.events) {\n          message.events.forEach((event: string) => sub.types.add(event));\n        }\n        break;\n        \n      case 'unsubscribe':\n        if (message.events) {\n          message.events.forEach((event: string) => sub.types.delete(event));\n        }\n        break;\n        \n      case 'set_filters':\n        sub.filters = message.filters;\n        break;\n        \n      case 'get_devices':\n        this.sendCachedDevices(ws, sub);\n        break;\n        \n      case 'ping':\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.send(JSON.stringify({ type: 'pong', timestamp: new Date().toISOString() }));\n        }\n        break;\n    }\n  }\n\n  /**\n   * Send cached devices to a client\n   */\n  private sendCachedDevices(ws: WebSocket, sub: Subscription) {\n    const devices = Array.from(this.deviceCache.values())\n      .map(cached => cached.device)\n      .filter(device => {\n        if (sub.filters) {\n          if (sub.filters.minSignal && device.signal && device.signal < sub.filters.minSignal) {\n            return false;\n          }\n          if (sub.filters.deviceTypes && !sub.filters.deviceTypes.includes(device.type)) {\n            return false;\n          }\n        }\n        return true;\n      });\n\n    const message: WebSocketMessage = {\n      type: 'device_update',\n      data: {\n        devices,\n        total: devices.length,\n        cached: true\n      },\n      timestamp: new Date().toISOString()\n    };\n\n    if (ws.readyState === WebSocket.OPEN) {\n      ws.send(JSON.stringify(message));\n    }\n  }\n\n  /**\n   * Broadcast message to clients with optional filter\n   */\n  private broadcast(message: WebSocketMessage, filter?: (sub: Subscription) => boolean) {\n    const data = JSON.stringify(message);\n    \n    this.clients.forEach((sub, client) => {\n      if (client.readyState === WebSocket.OPEN) {\n        if (!filter || filter(sub)) {\n          client.send(data);\n        }\n      }\n    });\n  }\n\n  /**\n   * Clean up stale cache entries\n   */\n  private cleanupCache() {\n    const now = Date.now();\n    const staleKeys: string[] = [];\n\n    this.deviceCache.forEach((cached, key) => {\n      if (now - cached.lastUpdate > this.CACHE_EXPIRY) {\n        staleKeys.push(key);\n      }\n    });\n\n    staleKeys.forEach(key => {\n      this.deviceCache.delete(key);\n      this.updateThrottles.delete(key);\n    });\n\n    if (staleKeys.length > 0) {\n      console.log(`Cleaned up ${staleKeys.length} stale devices from cache`);\n    }\n  }\n\n  /**\n   * Get current statistics\n   */\n  getStats() {\n    return {\n      clients: this.clients.size,\n      devices: this.deviceCache.size,\n      polling: !!this.pollingInterval,\n      lastPoll: this.lastPollTime\n    };\n  }\n\n  /**\n   * Clean up resources\n   */\n  destroy() {\n    if (this.pollingInterval) {\n      clearInterval(this.pollingInterval);\n      this.pollingInterval = undefined;\n    }\n    \n    this.clients.forEach((_, client) => {\n      client.close();\n    });\n    \n    this.clients.clear();\n    this.deviceCache.clear();\n    this.updateThrottles.clear();\n    this.removeAllListeners();\n  }\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/server/websocket-server.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'Duplex' is defined but never used. Allowed unused vars must match /^_/u.",
				"line": 3,
				"column": 15,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 3,
				"endColumn": 21
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 6,
				"column": 41,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 6,
				"endColumn": 44,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [194, 197], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [194, 197], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 9,
				"column": 46,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 9,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [293, 296], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [293, 296], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 9,
				"column": 60,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 9,
				"endColumn": 63,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [307, 310], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [307, 310], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 14,
				"column": 51,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 14,
				"endColumn": 54,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [414, 417], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [414, 417], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "no-console",
				"severity": 1,
				"message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
				"line": 34,
				"column": 3,
				"nodeType": "MemberExpression",
				"messageId": "limited",
				"endLine": 34,
				"endColumn": 14,
				"suggestions": [
					{
						"fix": { "range": [850, 908], "text": "" },
						"messageId": "removeConsole",
						"data": { "propertyName": "log" },
						"desc": "Remove the console.log()."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 36,
				"column": 29,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 36,
				"endColumn": 32,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [938, 941], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [938, 941], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "no-console",
				"severity": 1,
				"message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
				"line": 40,
				"column": 5,
				"nodeType": "MemberExpression",
				"messageId": "limited",
				"endLine": 40,
				"endColumn": 16,
				"suggestions": [
					{
						"fix": { "range": [1051, 1106], "text": "" },
						"messageId": "removeConsole",
						"data": { "propertyName": "log" },
						"desc": "Remove the console.log()."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 46,
				"column": 5,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 46,
				"endColumn": 31,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [1255, 1256], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 49,
				"column": 5,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 49,
				"endColumn": 12
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .send on an `any` value.",
				"line": 49,
				"column": 8,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 49,
				"endColumn": 12
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 56,
				"column": 5,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 56,
				"endColumn": 10
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .on on an `any` value.",
				"line": 56,
				"column": 8,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 56,
				"endColumn": 10
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 58,
				"column": 15,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 58,
				"endColumn": 52
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .type on an `any` value.",
				"line": 61,
				"column": 21,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 61,
				"endColumn": 25
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 62,
				"column": 11,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 62,
				"endColumn": 18
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .send on an `any` value.",
				"line": 62,
				"column": 14,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 62,
				"endColumn": 18
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 71,
				"column": 11,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 71,
				"endColumn": 18
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .send on an `any` value.",
				"line": 71,
				"column": 14,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 71,
				"endColumn": 18
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 78,
				"column": 9,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 78,
				"endColumn": 16
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .send on an `any` value.",
				"line": 78,
				"column": 12,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 78,
				"endColumn": 16
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 85,
				"column": 5,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 85,
				"endColumn": 10
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .on on an `any` value.",
				"line": 85,
				"column": 8,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 85,
				"endColumn": 10
			},
			{
				"ruleId": "no-console",
				"severity": 1,
				"message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
				"line": 86,
				"column": 7,
				"nodeType": "MemberExpression",
				"messageId": "limited",
				"endLine": 86,
				"endColumn": 18,
				"suggestions": [
					{
						"fix": { "range": [2311, 2370], "text": "" },
						"messageId": "removeConsole",
						"data": { "propertyName": "log" },
						"desc": "Remove the console.log()."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 90,
				"column": 5,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 90,
				"endColumn": 10
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .on on an `any` value.",
				"line": 90,
				"column": 8,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 90,
				"endColumn": 10
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .type on an `any` value.",
				"line": 102,
				"column": 19,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 102,
				"endColumn": 23
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 104,
				"column": 7,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 104,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .send on an `any` value.",
				"line": 104,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 104,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 117,
				"column": 7,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 117,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .send on an `any` value.",
				"line": 117,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 117,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 130,
				"column": 7,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 130,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .send on an `any` value.",
				"line": 130,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 130,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 134,
				"column": 11,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 134,
				"endColumn": 59
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .config on an `any` value.",
				"line": 134,
				"column": 30,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 134,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 135,
				"column": 11,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 135,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .config on an `any` value.",
				"line": 135,
				"column": 28,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 135,
				"endColumn": 34
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 136,
				"column": 11,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 136,
				"endColumn": 61
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .config on an `any` value.",
				"line": 136,
				"column": 32,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 136,
				"endColumn": 38
			},
			{
				"ruleId": "no-case-declarations",
				"severity": 2,
				"message": "Unexpected lexical declaration in case block.",
				"line": 142,
				"column": 7,
				"nodeType": "VariableDeclaration",
				"messageId": "unexpected",
				"endLine": 142,
				"endColumn": 24,
				"suggestions": [
					{
						"messageId": "addBrackets",
						"fix": {
							"range": [3278, 4307],
							"text": "{ ws.send(JSON.stringify({\n        type: 'sweep_status',\n        data: {\n          active: true,\n          startFreq: message.config?.startFreq || 88000000,\n          endFreq: message.config?.endFreq || 108000000,\n          currentFreq: message.config?.startFreq || 88000000,\n          progress: 0\n        }\n      }));\n      \n      // Simulate sweep progress\n      let progress = 0;\n      const interval = setInterval(() => {\n        progress += 10;\n        if (progress > 100) {\n          clearInterval(interval);\n          ws.send(JSON.stringify({\n            type: 'sweep_status',\n            data: { active: false, progress: 100 }\n          }));\n        } else {\n          ws.send(JSON.stringify({\n            type: 'spectrum_data',\n            data: {\n              frequencies: Array.from({ length: 100 }, (_, i) => 88000000 + i * 200000),\n              power: Array.from({ length: 100 }, () => -80 + Math.random() * 40),\n              timestamp: Date.now()\n            }\n          }));\n        }\n      }, 1000);\n      break; }"
						},
						"desc": "Add {} brackets around the case block."
					}
				]
			},
			{
				"ruleId": "no-case-declarations",
				"severity": 2,
				"message": "Unexpected lexical declaration in case block.",
				"line": 143,
				"column": 7,
				"nodeType": "VariableDeclaration",
				"messageId": "unexpected",
				"endLine": 161,
				"endColumn": 16,
				"suggestions": [
					{
						"messageId": "addBrackets",
						"fix": {
							"range": [3278, 4307],
							"text": "{ ws.send(JSON.stringify({\n        type: 'sweep_status',\n        data: {\n          active: true,\n          startFreq: message.config?.startFreq || 88000000,\n          endFreq: message.config?.endFreq || 108000000,\n          currentFreq: message.config?.startFreq || 88000000,\n          progress: 0\n        }\n      }));\n      \n      // Simulate sweep progress\n      let progress = 0;\n      const interval = setInterval(() => {\n        progress += 10;\n        if (progress > 100) {\n          clearInterval(interval);\n          ws.send(JSON.stringify({\n            type: 'sweep_status',\n            data: { active: false, progress: 100 }\n          }));\n        } else {\n          ws.send(JSON.stringify({\n            type: 'spectrum_data',\n            data: {\n              frequencies: Array.from({ length: 100 }, (_, i) => 88000000 + i * 200000),\n              power: Array.from({ length: 100 }, () => -80 + Math.random() * 40),\n              timestamp: Date.now()\n            }\n          }));\n        }\n      }, 1000);\n      break; }"
						},
						"desc": "Add {} brackets around the case block."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 147,
				"column": 11,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 147,
				"endColumn": 18
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .send on an `any` value.",
				"line": 147,
				"column": 14,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 147,
				"endColumn": 18
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 152,
				"column": 11,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 152,
				"endColumn": 18
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .send on an `any` value.",
				"line": 152,
				"column": 14,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 152,
				"endColumn": 18
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 165,
				"column": 7,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 165,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .send on an `any` value.",
				"line": 165,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 165,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 172,
				"column": 7,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 172,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .send on an `any` value.",
				"line": 172,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 172,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 174,
				"column": 9,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 174,
				"endColumn": 33
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .streams on an `any` value.",
				"line": 174,
				"column": 26,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 174,
				"endColumn": 33
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 179,
				"column": 7,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 179,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .send on an `any` value.",
				"line": 179,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 179,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .type on an `any` value.",
				"line": 181,
				"column": 51,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 181,
				"endColumn": 55
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .type on an `any` value.",
				"line": 190,
				"column": 19,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 190,
				"endColumn": 23
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 192,
				"column": 7,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 192,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .send on an `any` value.",
				"line": 192,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 192,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 205,
				"column": 7,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 205,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .send on an `any` value.",
				"line": 205,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 205,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 233,
				"column": 7,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 233,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .send on an `any` value.",
				"line": 233,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 233,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 246,
				"column": 7,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 246,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .send on an `any` value.",
				"line": 246,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 246,
				"endColumn": 14
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .type on an `any` value.",
				"line": 248,
				"column": 51,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 248,
				"endColumn": 55
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 256,
				"column": 54,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 256,
				"endColumn": 57,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [6487, 6490], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [6487, 6490], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .readyState on an `any` value.",
				"line": 261,
				"column": 14,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 261,
				"endColumn": 24
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 262,
				"column": 9,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 262,
				"endColumn": 16
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .send on an `any` value.",
				"line": 262,
				"column": 12,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 262,
				"endColumn": 16
			}
		],
		"suppressedMessages": [],
		"errorCount": 58,
		"fatalErrorCount": 0,
		"warningCount": 10,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { WebSocketServer } from 'ws';\nimport type { IncomingMessage } from 'http';\nimport type { Duplex } from 'stream';\n\n// Store for active connections\nconst connections = new Map<string, Set<any>>();\n\n// Message handlers for different endpoints\nconst messageHandlers = new Map<string, (ws: any, message: any) => void>();\n\n/**\n * Initialize WebSocket server\n */\nexport function initializeWebSocketServer(server: any, port: number = 5173) {\n  const wss = new WebSocketServer({ \n    port,\n    perMessageDeflate: {\n      zlibDeflateOptions: {\n        chunkSize: 1024,\n        memLevel: 7,\n        level: 3\n      },\n      zlibInflateOptions: {\n        chunkSize: 10 * 1024\n      },\n      clientNoContextTakeover: true,\n      serverNoContextTakeover: true,\n      serverMaxWindowBits: 10,\n      concurrencyLimit: 10,\n      threshold: 1024\n    }\n  });\n\n  console.log(`WebSocket server listening on port ${port}`);\n\n  wss.on('connection', (ws: any, req: IncomingMessage) => {\n    const url = req.url || '/';\n    const endpoint = url.split('?')[0];\n    \n    console.log(`New WebSocket connection to ${endpoint}`);\n    \n    // Add to connections\n    if (!connections.has(endpoint)) {\n      connections.set(endpoint, new Set());\n    }\n    connections.get(endpoint)!.add(ws);\n    \n    // Send initial connection success\n    ws.send(JSON.stringify({\n      type: 'connected',\n      endpoint,\n      timestamp: Date.now()\n    }));\n    \n    // Setup message handling\n    ws.on('message', (data: Buffer) => {\n      try {\n        const message = JSON.parse(data.toString());\n        \n        // Handle ping/pong\n        if (message.type === 'ping') {\n          ws.send(JSON.stringify({ type: 'pong', timestamp: Date.now() }));\n          return;\n        }\n        \n        // Route to appropriate handler\n        const handler = messageHandlers.get(endpoint);\n        if (handler) {\n          handler(ws, message);\n        } else {\n          ws.send(JSON.stringify({\n            type: 'error',\n            message: `No handler for endpoint ${endpoint}`\n          }));\n        }\n      } catch (error) {\n        console.error('WebSocket message error:', error);\n        ws.send(JSON.stringify({\n          type: 'error',\n          message: 'Invalid message format'\n        }));\n      }\n    });\n    \n    ws.on('close', () => {\n      console.log(`WebSocket connection closed for ${endpoint}`);\n      connections.get(endpoint)?.delete(ws);\n    });\n    \n    ws.on('error', (error: Error) => {\n      console.error(`WebSocket error for ${endpoint}:`, error);\n    });\n  });\n  \n  return wss;\n}\n\n/**\n * Register HackRF WebSocket handler\n */\nmessageHandlers.set('/hackrf', (ws, message) => {\n  switch (message.type) {\n    case 'request_status':\n      ws.send(JSON.stringify({\n        type: 'status',\n        data: {\n          connected: true,\n          sweeping: false,\n          frequency: 100000000,\n          sampleRate: 20000000,\n          gain: 40\n        }\n      }));\n      break;\n      \n    case 'request_sweep_status':\n      ws.send(JSON.stringify({\n        type: 'sweep_status',\n        data: {\n          active: false,\n          startFreq: 88000000,\n          endFreq: 108000000,\n          currentFreq: 0,\n          progress: 0\n        }\n      }));\n      break;\n      \n    case 'start_sweep':\n      ws.send(JSON.stringify({\n        type: 'sweep_status',\n        data: {\n          active: true,\n          startFreq: message.config?.startFreq || 88000000,\n          endFreq: message.config?.endFreq || 108000000,\n          currentFreq: message.config?.startFreq || 88000000,\n          progress: 0\n        }\n      }));\n      \n      // Simulate sweep progress\n      let progress = 0;\n      const interval = setInterval(() => {\n        progress += 10;\n        if (progress > 100) {\n          clearInterval(interval);\n          ws.send(JSON.stringify({\n            type: 'sweep_status',\n            data: { active: false, progress: 100 }\n          }));\n        } else {\n          ws.send(JSON.stringify({\n            type: 'spectrum_data',\n            data: {\n              frequencies: Array.from({ length: 100 }, (_, i) => 88000000 + i * 200000),\n              power: Array.from({ length: 100 }, () => -80 + Math.random() * 40),\n              timestamp: Date.now()\n            }\n          }));\n        }\n      }, 1000);\n      break;\n      \n    case 'stop_sweep':\n      ws.send(JSON.stringify({\n        type: 'sweep_status',\n        data: { active: false }\n      }));\n      break;\n      \n    case 'subscribe':\n      ws.send(JSON.stringify({\n        type: 'subscribed',\n        streams: message.streams\n      }));\n      break;\n      \n    default:\n      ws.send(JSON.stringify({\n        type: 'error',\n        message: `Unknown message type: ${message.type}`\n      }));\n  }\n});\n\n/**\n * Register Kismet WebSocket handler\n */\nmessageHandlers.set('/kismet', (ws, message) => {\n  switch (message.type) {\n    case 'request_status':\n      ws.send(JSON.stringify({\n        type: 'status',\n        data: {\n          running: true,\n          connected: true,\n          devices: 42,\n          uptime: 3600,\n          packetsPerSecond: 150\n        }\n      }));\n      break;\n      \n    case 'request_devices':\n      ws.send(JSON.stringify({\n        type: 'devices_list',\n        data: [\n          {\n            mac: '00:11:22:33:44:55',\n            ssid: 'TestNetwork',\n            manufacturer: 'Example Corp',\n            signalStrength: -45,\n            channel: 6,\n            firstSeen: new Date(Date.now() - 3600000).toISOString(),\n            lastSeen: new Date().toISOString(),\n            packets: 1234\n          },\n          {\n            mac: 'AA:BB:CC:DD:EE:FF',\n            ssid: 'AnotherNetwork',\n            manufacturer: 'Device Inc',\n            signalStrength: -72,\n            channel: 11,\n            firstSeen: new Date(Date.now() - 1800000).toISOString(),\n            lastSeen: new Date().toISOString(),\n            packets: 567\n          }\n        ]\n      }));\n      break;\n      \n    case 'refresh':\n      ws.send(JSON.stringify({\n        type: 'status',\n        data: {\n          running: true,\n          connected: true,\n          devices: 45,\n          uptime: 3700,\n          packetsPerSecond: 175\n        }\n      }));\n      break;\n      \n    default:\n      ws.send(JSON.stringify({\n        type: 'error',\n        message: `Unknown message type: ${message.type}`\n      }));\n  }\n});\n\n/**\n * Broadcast message to all connections on an endpoint\n */\nexport function broadcast(endpoint: string, message: any) {\n  const conns = connections.get(endpoint);\n  if (conns) {\n    const data = JSON.stringify(message);\n    conns.forEach(ws => {\n      if (ws.readyState === 1) { // WebSocket.OPEN\n        ws.send(data);\n      }\n    });\n  }\n}\n\n/**\n * Get connection count for an endpoint\n */\nexport function getConnectionCount(endpoint: string): number {\n  return connections.get(endpoint)?.size || 0;\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/api/config.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/api/example-usage.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/api/hackrf.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/api/index.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/api/kismet.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/api/system.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/db/dataAccessLayer.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/db/signalDatabase.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/drone/flightPathAnalyzer.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/hackrf/api.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/hackrf/hackrfService.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 374,
				"column": 9,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 374,
				"endColumn": 39
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "/**\n * HackRF Service Layer\n * High-level service for managing HackRF operations with real-time streaming\n */\n\nimport { writable, derived, type Readable, type Writable } from 'svelte/store';\nimport { hackrfAPI } from '../api';\nimport { HackRFWebSocketClient } from '../websocket/hackrf';\nimport type { \n  HackRFStatus, \n  HackRFConfig, \n  SweepResult, \n  SignalDetection,\n  SpectrumData \n} from '../api/hackrf';\n\ninterface HackRFServiceState {\n  status: HackRFStatus;\n  config: HackRFConfig | null;\n  sweepResults: SweepResult[];\n  detectedSignals: SignalDetection[];\n  spectrumData: SpectrumData | null;\n  isConnecting: boolean;\n  error: string | null;\n  lastUpdate: number;\n}\n\ninterface SweepControlOptions {\n  startFreq: number;\n  endFreq: number;\n  binSize?: number;\n  sampleRate?: number;\n  gain?: number;\n  amplifierEnabled?: boolean;\n  cycleTime?: number;\n}\n\nclass HackRFService {\n  private state: Writable<HackRFServiceState>;\n  private websocket: HackRFWebSocketClient | null = null;\n  private statusInterval: ReturnType<typeof setInterval> | null = null;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n  private reconnectDelay = 1000;\n  \n  // Public readable stores\n  public readonly status: Readable<HackRFStatus>;\n  public readonly config: Readable<HackRFConfig | null>;\n  public readonly sweepResults: Readable<SweepResult[]>;\n  public readonly detectedSignals: Readable<SignalDetection[]>;\n  public readonly spectrumData: Readable<SpectrumData | null>;\n  public readonly isConnecting: Readable<boolean>;\n  public readonly error: Readable<string | null>;\n  \n  constructor() {\n    // Initialize state\n    this.state = writable<HackRFServiceState>({\n      status: {\n        connected: false,\n        sweeping: false\n      },\n      config: null,\n      sweepResults: [],\n      detectedSignals: [],\n      spectrumData: null,\n      isConnecting: false,\n      error: null,\n      lastUpdate: Date.now()\n    });\n    \n    // Create derived stores for public access\n    this.status = derived(this.state, $state => $state.status);\n    this.config = derived(this.state, $state => $state.config);\n    this.sweepResults = derived(this.state, $state => $state.sweepResults);\n    this.detectedSignals = derived(this.state, $state => $state.detectedSignals);\n    this.spectrumData = derived(this.state, $state => $state.spectrumData);\n    this.isConnecting = derived(this.state, $state => $state.isConnecting);\n    this.error = derived(this.state, $state => $state.error);\n  }\n  \n  /**\n   * Initialize the service and connect to HackRF\n   */\n  async initialize(): Promise<void> {\n    try {\n      this.updateState({ isConnecting: true, error: null });\n      \n      // Get initial status\n      await this.updateStatus();\n      \n      // Setup WebSocket connection\n      this.setupWebSocket();\n      \n      // Start status polling\n      this.startStatusPolling();\n      \n      this.updateState({ isConnecting: false });\n    } catch (error) {\n      this.handleError('Failed to initialize HackRF service', error);\n      this.updateState({ isConnecting: false });\n    }\n  }\n  \n  /**\n   * Connect to HackRF device\n   */\n  async connect(): Promise<void> {\n    try {\n      this.updateState({ isConnecting: true, error: null });\n      \n      const result = await hackrfAPI.connect();\n      if (!result.success) {\n        throw new Error(result.message);\n      }\n      \n      // Update status and config after connection\n      await this.updateStatus();\n      await this.refreshConfig();\n      \n      this.updateState({ isConnecting: false });\n    } catch (error) {\n      this.handleError('Failed to connect to HackRF', error);\n      this.updateState({ isConnecting: false });\n      throw error;\n    }\n  }\n  \n  /**\n   * Disconnect from HackRF device\n   */\n  async disconnect(): Promise<void> {\n    try {\n      const result = await hackrfAPI.disconnect();\n      if (!result.success) {\n        throw new Error(result.message);\n      }\n      \n      await this.updateStatus();\n    } catch (error) {\n      this.handleError('Failed to disconnect from HackRF', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Start frequency sweep with configuration\n   */\n  async startSweep(options: SweepControlOptions): Promise<void> {\n    try {\n      this.updateState({ error: null });\n      \n      // Prepare config\n      const config: Partial<HackRFConfig> = {\n        startFreq: options.startFreq,\n        endFreq: options.endFreq,\n        binSize: options.binSize || 100000,\n        sampleRate: options.sampleRate || 20000000,\n        gain: options.gain || 20,\n        amplifierEnabled: options.amplifierEnabled || false\n      };\n      \n      // Send start sweep request\n      const result = await hackrfAPI.startSweep(config);\n      if (!result.success) {\n        throw new Error(result.message);\n      }\n      \n      // Clear previous results\n      this.updateState({\n        sweepResults: [],\n        detectedSignals: [],\n        spectrumData: null\n      });\n      \n      await this.updateStatus();\n    } catch (error) {\n      this.handleError('Failed to start sweep', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Stop frequency sweep\n   */\n  async stopSweep(): Promise<void> {\n    try {\n      const result = await hackrfAPI.stopSweep();\n      if (!result.success) {\n        throw new Error(result.message);\n      }\n      \n      await this.updateStatus();\n    } catch (error) {\n      this.handleError('Failed to stop sweep', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Emergency stop - forcefully terminate all operations\n   */\n  async emergencyStop(): Promise<void> {\n    try {\n      // Call emergency stop endpoint\n      const response = await fetch('/api/hackrf/emergency-stop', {\n        method: 'POST'\n      });\n      \n      if (!response.ok) {\n        throw new Error('Emergency stop failed');\n      }\n      \n      await this.updateStatus();\n    } catch (error) {\n      this.handleError('Emergency stop failed', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Update device configuration\n   */\n  async updateConfig(config: Partial<HackRFConfig>): Promise<void> {\n    try {\n      const result = await hackrfAPI.updateConfig(config);\n      if (!result.success) {\n        throw new Error('Failed to update configuration');\n      }\n      \n      this.updateState({ config: result.config });\n    } catch (error) {\n      this.handleError('Failed to update configuration', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Set gain level\n   */\n  async setGain(gain: number): Promise<void> {\n    try {\n      const result = await hackrfAPI.setGain(gain);\n      if (!result.success) {\n        throw new Error('Failed to set gain');\n      }\n      \n      await this.refreshConfig();\n    } catch (error) {\n      this.handleError('Failed to set gain', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Toggle amplifier\n   */\n  async toggleAmplifier(enabled: boolean): Promise<void> {\n    try {\n      const result = await hackrfAPI.toggleAmplifier(enabled);\n      if (!result.success) {\n        throw new Error('Failed to toggle amplifier');\n      }\n      \n      await this.refreshConfig();\n    } catch (error) {\n      this.handleError('Failed to toggle amplifier', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get device information\n   */\n  async getDeviceInfo(): Promise<Record<string, unknown>> {\n    try {\n      return await hackrfAPI.getDeviceInfo();\n    } catch (error) {\n      this.handleError('Failed to get device info', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Export sweep data\n   */\n  async exportData(format: 'csv' | 'json' = 'json'): Promise<void> {\n    try {\n      const blob = await hackrfAPI.exportData(format);\n      \n      // Create download link\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = `hackrf-sweep-${Date.now()}.${format}`;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    } catch (error) {\n      this.handleError('Failed to export data', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Setup WebSocket connection for real-time data\n   */\n  private setupWebSocket(): void {\n    try {\n      this.websocket = new HackRFWebSocketClient();\n      \n      // Handle connection events\n      this.websocket.on('open', (_event) => {\n        // HackRF WebSocket connected\n        this.reconnectAttempts = 0;\n      });\n      \n      this.websocket.on('close', (_event) => {\n        // HackRF WebSocket disconnected\n        void this.handleReconnect();\n      });\n      \n      this.websocket.on('error', (event) => {\n        // HackRF WebSocket error\n        this.updateState({ error: event.error?.message || 'WebSocket error' });\n      });\n      \n      // Handle data events using message handlers\n      this.websocket.onMessage('status', (status: HackRFStatus) => {\n        this.updateState({ status, lastUpdate: Date.now() });\n      });\n      \n      this.websocket.onMessage('sweep_data', (data: SpectrumData) => {\n        this.updateState({ spectrumData: data });\n      });\n      \n      this.websocket.onMessage('signal_detected', (signal: SignalDetection) => {\n        this.state.update(state => ({\n          ...state,\n          detectedSignals: [...state.detectedSignals.slice(-99), signal]\n        }));\n      });\n      \n      this.websocket.onMessage('config_update', (config: HackRFConfig) => {\n        this.updateState({ config });\n      });\n      \n      // Connect\n      this.websocket.connect();\n    } catch {\n      // Failed to setup WebSocket\n      // Don't throw - service can work without WebSocket\n    }\n  }\n  \n  /**\n   * Handle WebSocket reconnection\n   */\n  private handleReconnect(): void {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      this.updateState({ \n        error: 'WebSocket connection lost. Please refresh the page.' \n      });\n      return;\n    }\n    \n    this.reconnectAttempts++;\n    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);\n    \n    // Reconnecting WebSocket\n    \n    setTimeout(() => {\n      if (this.websocket) {\n        this.websocket.connect().catch((error: unknown) => {\n          console.error('WebSocket reconnect failed:', error);\n          void this.handleReconnect();\n        });\n      }\n    }, delay);\n  }\n  \n  /**\n   * Start status polling\n   */\n  private startStatusPolling(): void {\n    this.statusInterval = setInterval(() => {\n      void this.updateStatus().catch(() => {\n        // Status polling error\n      });\n    }, 5000);\n  }\n  \n  /**\n   * Update current status\n   */\n  private async updateStatus(): Promise<void> {\n    try {\n      const status = await hackrfAPI.getStatus();\n      this.updateState({ status, lastUpdate: Date.now() });\n    } catch {\n      // Failed to update status\n    }\n  }\n  \n  /**\n   * Refresh current configuration from server\n   */\n  private async refreshConfig(): Promise<void> {\n    try {\n      const config = await hackrfAPI.getConfig();\n      this.updateState({ config });\n    } catch {\n      // Failed to refresh config\n    }\n  }\n  \n  /**\n   * Update state helper\n   */\n  private updateState(partial: Partial<HackRFServiceState>): void {\n    this.state.update(state => ({ ...state, ...partial }));\n  }\n  \n  /**\n   * Handle errors\n   */\n  private handleError(message: string, error: unknown): void {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    // Error logged\n    this.updateState({ error: `${message}: ${errorMessage}` });\n  }\n  \n  /**\n   * Cleanup resources\n   */\n  destroy(): void {\n    if (this.statusInterval) {\n      clearInterval(this.statusInterval);\n    }\n    \n    if (this.websocket) {\n      this.websocket.disconnect();\n    }\n  }\n}\n\n// Export singleton instance\nexport const hackrfService = new HackRFService();",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/hackrf/index.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/hackrf/signalProcessor.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/hackrf/sweepAnalyzer.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/hackrf/timeWindowFilter.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/index.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/kismet/deviceManager.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/kismet/index.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/kismet/kismetService.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-base-to-string",
				"severity": 2,
				"message": "'typedFilter.value' will use Object's default stringification format ('[object Object]') when stringified.",
				"line": 283,
				"column": 26,
				"nodeType": "MemberExpression",
				"messageId": "baseToString",
				"endLine": 283,
				"endColumn": 43
			},
			{
				"ruleId": "@typescript-eslint/no-base-to-string",
				"severity": 2,
				"message": "'typedFilter.value' will use Object's default stringification format ('[object Object]') when stringified.",
				"line": 292,
				"column": 26,
				"nodeType": "MemberExpression",
				"messageId": "baseToString",
				"endLine": 292,
				"endColumn": 43
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 296,
				"column": 19,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 296,
				"endColumn": 49
			}
		],
		"suppressedMessages": [],
		"errorCount": 3,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "/**\n * Kismet Service Layer\n * High-level service for managing Kismet operations with real-time streaming\n */\n\nimport { writable, derived, type Readable, type Writable } from 'svelte/store';\nimport { kismetAPI } from '../api';\nimport { KismetWebSocketClient } from '../websocket/kismet';\nimport type {\n  KismetStatus,\n  KismetDevice,\n  KismetScript,\n  KismetStats,\n  KismetConfig,\n  DeviceFilter\n} from '../api/kismet';\n\ninterface KismetServiceState {\n  status: KismetStatus;\n  devices: KismetDevice[];\n  scripts: KismetScript[];\n  stats: KismetStats | null;\n  config: KismetConfig | null;\n  filters: DeviceFilter[];\n  isConnecting: boolean;\n  error: string | null;\n  lastUpdate: number;\n}\n\ninterface ServiceControlOptions {\n  autoRestart?: boolean;\n  restartDelay?: number;\n  maxRestartAttempts?: number;\n}\n\nclass KismetService {\n  private state: Writable<KismetServiceState>;\n  private websocket: KismetWebSocketClient | null = null;\n  private statusInterval: ReturnType<typeof setInterval> | null = null;\n  private deviceInterval: ReturnType<typeof setInterval> | null = null;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n  private reconnectDelay = 1000;\n  \n  // Service control\n  private serviceOptions: ServiceControlOptions = {\n    autoRestart: true,\n    restartDelay: 5000,\n    maxRestartAttempts: 3\n  };\n  private restartAttempts = 0;\n  \n  // Public readable stores\n  public readonly status: Readable<KismetStatus>;\n  public readonly devices: Readable<KismetDevice[]>;\n  public readonly scripts: Readable<KismetScript[]>;\n  public readonly stats: Readable<KismetStats | null>;\n  public readonly config: Readable<KismetConfig | null>;\n  public readonly isConnecting: Readable<boolean>;\n  public readonly error: Readable<string | null>;\n  \n  // Derived stores\n  public readonly deviceCount: Readable<number>;\n  public readonly activeDevices: Readable<KismetDevice[]>;\n  public readonly apCount: Readable<number>;\n  public readonly clientCount: Readable<number>;\n  \n  constructor() {\n    // Initialize state\n    this.state = writable<KismetServiceState>({\n      status: {\n        running: false,\n        version: 'Unknown',\n        devices: 0\n      },\n      devices: [],\n      scripts: [],\n      stats: null,\n      config: null,\n      filters: [],\n      isConnecting: false,\n      error: null,\n      lastUpdate: Date.now()\n    });\n    \n    // Create derived stores for public access\n    this.status = derived(this.state, $state => $state.status);\n    this.devices = derived(this.state, $state => $state.devices);\n    this.scripts = derived(this.state, $state => $state.scripts);\n    this.stats = derived(this.state, $state => $state.stats);\n    this.config = derived(this.state, $state => $state.config);\n    this.isConnecting = derived(this.state, $state => $state.isConnecting);\n    this.error = derived(this.state, $state => $state.error);\n    \n    // Create additional derived stores\n    this.deviceCount = derived(this.state, $state => $state.devices.length);\n    this.activeDevices = derived(this.state, $state => \n      $state.devices.filter(d => d.lastSeen && \n        Date.now() - new Date(d.lastSeen).getTime() < 300000) // Active in last 5 min\n    );\n    this.apCount = derived(this.state, $state => \n      $state.devices.filter(d => d.type === 'AP').length\n    );\n    this.clientCount = derived(this.state, $state => \n      $state.devices.filter(d => d.type === 'CLIENT').length\n    );\n  }\n  \n  /**\n   * Initialize the service\n   */\n  async initialize(): Promise<void> {\n    try {\n      this.updateState({ isConnecting: true, error: null });\n      \n      // Get initial status\n      await this.updateStatus();\n      \n      // Load available scripts\n      await this.loadScripts();\n      \n      // Setup WebSocket connection\n      this.setupWebSocket();\n      \n      // Start polling\n      this.startPolling();\n      \n      this.updateState({ isConnecting: false });\n    } catch (error) {\n      this.handleError('Failed to initialize Kismet service', error);\n      this.updateState({ isConnecting: false });\n    }\n  }\n  \n  /**\n   * Start Kismet service\n   */\n  async startService(): Promise<void> {\n    try {\n      this.updateState({ error: null });\n      \n      const result = await kismetAPI.startService();\n      if (!result.success) {\n        throw new Error(result.message);\n      }\n      \n      // Wait for service to fully start\n      await new Promise(resolve => setTimeout(resolve, 3000));\n      \n      await this.updateStatus();\n      \n      // Reinitialize WebSocket after service start\n      if (this.websocket) {\n        void this.websocket.connect();\n      }\n    } catch (error) {\n      this.handleError('Failed to start Kismet service', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Stop Kismet service\n   */\n  async stopService(): Promise<void> {\n    try {\n      const result = await kismetAPI.stopService();\n      if (!result.success) {\n        throw new Error(result.message);\n      }\n      \n      await this.updateStatus();\n    } catch (error) {\n      this.handleError('Failed to stop Kismet service', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Restart Kismet service\n   */\n  async restartService(): Promise<void> {\n    try {\n      const result = await kismetAPI.restartService();\n      if (!result.success) {\n        throw new Error(result.message);\n      }\n      \n      // Wait for service to restart\n      await new Promise(resolve => setTimeout(resolve, 5000));\n      \n      await this.updateStatus();\n      \n      // Reinitialize WebSocket\n      if (this.websocket) {\n        void this.websocket.connect();\n      }\n    } catch (error) {\n      this.handleError('Failed to restart Kismet service', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get service logs\n   */\n  async getLogs(lines: number = 100): Promise<string[]> {\n    try {\n      // @ts-expect-error - getServiceLogs method not defined in API type\n      const logs = await (kismetAPI as unknown as { getServiceLogs: (lines: number) => Promise<string[]> }).getServiceLogs(lines);\n      return logs;\n    } catch (error) {\n      this.handleError('Failed to get service logs', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Execute a script\n   */\n  async executeScript(scriptName: string, args?: string[]): Promise<unknown> {\n    try {\n      // @ts-expect-error - executeScript method not defined in API type\n      const result = await (kismetAPI as unknown as { executeScript: (scriptName: string, args?: string[]) => Promise<{ success: boolean; message?: string; data?: unknown }> }).executeScript(scriptName, args);\n      \n      // Refresh scripts list in case status changed\n      await this.loadScripts();\n      \n      return result;\n    } catch (error) {\n      this.handleError(`Failed to execute script ${scriptName}`, error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Apply device filters\n   */\n  async applyFilters(filters: DeviceFilter[]): Promise<void> {\n    try {\n      this.updateState({ filters });\n      \n      // If we have a WebSocket connection, send filters through it\n      if (this.websocket?.isConnected()) {\n        this.websocket.send('apply_filters', { filters });\n      }\n      \n      // Also refresh devices with filters\n      await this.updateDevices();\n    } catch (error) {\n      this.handleError('Failed to apply filters', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get filtered devices\n   */\n  getFilteredDevices(): KismetDevice[] {\n    let currentState: KismetServiceState;\n    this.state.subscribe(s => currentState = s)();\n    \n    const { devices, filters } = currentState;\n    \n    if (filters.length === 0) {\n      return devices;\n    }\n    \n    return devices.filter(device => {\n      return filters.every(filter => {\n        // Type assertion for filter with field/value/operator structure\n        const typedFilter = filter as unknown as { field: string; value: unknown; operator?: string };\n        \n        switch (typedFilter.field) {\n          case 'type':\n            return typedFilter.value === 'all' || device.type === typedFilter.value;\n          case 'manufacturer': {\n            if (!typedFilter.value) return true;\n            const filterValue = typeof typedFilter.value === 'string' \n              ? typedFilter.value \n              : typeof typedFilter.value === 'object' && typedFilter.value !== null \n                ? JSON.stringify(typedFilter.value) \n                : String(typedFilter.value);\n            return device.manufacturer?.toLowerCase().includes(filterValue.toLowerCase());\n          }\n          case 'ssid': {\n            if (!typedFilter.value) return true;\n            const filterValue = typeof typedFilter.value === 'string' \n              ? typedFilter.value \n              : typeof typedFilter.value === 'object' && typedFilter.value !== null \n                ? JSON.stringify(typedFilter.value) \n                : String(typedFilter.value);\n            return device.ssid?.toLowerCase().includes(filterValue.toLowerCase());\n          }\n          case 'signal': {\n            const signal = device.signal ?? -100;\n            let threshold = -80;\n            if (typedFilter.value !== null && typedFilter.value !== undefined) {\n              if (typeof typedFilter.value === 'number') {\n                threshold = typedFilter.value;\n              } else if (typeof typedFilter.value === 'string') {\n                threshold = parseInt(typedFilter.value) || -80;\n              }\n            }\n            return typedFilter.operator === 'gt' ? signal > threshold : signal < threshold;\n          }\n          default:\n            return true;\n        }\n      });\n    });\n  }\n  \n  /**\n   * Export devices data\n   */\n  exportDevices(format: 'csv' | 'json' = 'json'): void {\n    try {\n      const devices = this.getFilteredDevices();\n      let content: string;\n      let filename: string;\n      \n      if (format === 'csv') {\n        // Create CSV content\n        const headers = ['MAC', 'Type', 'SSID', 'Manufacturer', 'Channel', 'Signal', 'First Seen', 'Last Seen'];\n        const rows = devices.map(d => ([\n          d.mac,\n          d.type,\n          d.ssid || '',\n          d.manufacturer || '',\n          d.channel || '',\n          d.signal || '',\n          d.firstSeen || '',\n          d.lastSeen || ''\n        ] as string[]));\n        \n        content = [headers, ...rows].map(row => row.join(',')).join('\\n');\n        filename = `kismet-devices-${Date.now()}.csv`;\n      } else {\n        // Create JSON content\n        content = JSON.stringify(devices, null, 2);\n        filename = `kismet-devices-${Date.now()}.json`;\n      }\n      \n      // Create download\n      const blob = new Blob([content], { type: format === 'csv' ? 'text/csv' : 'application/json' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = filename;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    } catch (error) {\n      this.handleError('Failed to export devices', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Setup WebSocket connection for real-time updates\n   */\n  private setupWebSocket(): void {\n    try {\n      this.websocket = new KismetWebSocketClient();\n      \n      // Handle connection events\n      this.websocket.on('connect', () => {\n        // console.info('Kismet WebSocket connected');\n        this.reconnectAttempts = 0;\n        \n        // Apply any existing filters\n        let currentState: KismetServiceState;\n        this.state.subscribe(s => currentState = s)();\n        if (currentState.filters.length > 0) {\n          this.websocket?.send('apply_filters', { filters: currentState.filters });\n        }\n      });\n      \n      this.websocket.on('disconnect', () => {\n        // console.info('Kismet WebSocket disconnected');\n        void this.handleReconnect();\n      });\n      \n      this.websocket.on('error', (error) => {\n        console.error('Kismet WebSocket error:', error);\n        this.updateState({ error: (error as Error).message });\n      });\n      \n      // Handle data events\n      this.websocket.on('device_new', (device: KismetDevice) => {\n        this.state.update(state => ({\n          ...state,\n          devices: [...state.devices, device],\n          lastUpdate: Date.now()\n        }));\n      });\n      \n      this.websocket.on('device_update', (device: KismetDevice) => {\n        this.state.update(state => ({\n          ...state,\n          devices: state.devices.map(d => \n            d.mac === device.mac ? { ...d, ...device } : d\n          ),\n          lastUpdate: Date.now()\n        }));\n      });\n      \n      this.websocket.on('device_remove', (mac: string) => {\n        this.state.update(state => ({\n          ...state,\n          devices: state.devices.filter(d => d.mac !== mac),\n          lastUpdate: Date.now()\n        }));\n      });\n      \n      this.websocket.on('stats_update', (stats: KismetStats) => {\n        this.updateState({ stats });\n      });\n      \n      this.websocket.on('status_update', (status: KismetStatus) => {\n        this.updateState({ status });\n      });\n      \n      // Connect\n      void this.websocket.connect();\n    } catch (error) {\n      console.error('Failed to setup WebSocket:', error);\n      // Don't throw - service can work without WebSocket\n    }\n  }\n  \n  /**\n   * Handle WebSocket reconnection\n   */\n  private handleReconnect(): void {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      this.updateState({ \n        error: 'WebSocket connection lost. Please refresh the page.' \n      });\n      return;\n    }\n    \n    this.reconnectAttempts++;\n    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);\n    \n    // console.info(`Reconnecting WebSocket in ${delay}ms (attempt ${this.reconnectAttempts}`);\n    \n    setTimeout(() => {\n      if (this.websocket) {\n        void this.websocket.connect();\n      }\n    }, delay);\n  }\n  \n  /**\n   * Start polling for updates\n   */\n  private startPolling(): void {\n    // Status polling (every 5 seconds)\n    this.statusInterval = setInterval(() => {\n      try {\n        void this.updateStatus();\n      } catch (error) {\n        console.error('Status polling error:', error);\n      }\n    }, 5000);\n    \n    // Device polling (every 10 seconds)\n    this.deviceInterval = setInterval(() => {\n      try {\n        void this.updateDevices();\n      } catch (error) {\n        console.error('Device polling error:', error);\n      }\n    }, 10000);\n  }\n  \n  /**\n   * Update service status\n   */\n  private async updateStatus(): Promise<void> {\n    try {\n      const status = await kismetAPI.getStatus();\n      this.updateState({ status, lastUpdate: Date.now() });\n      \n      // Handle service health\n      if (!status.running && this.serviceOptions.autoRestart) {\n        void this.handleServiceDown();\n      } else {\n        this.restartAttempts = 0;\n      }\n    } catch (error) {\n      console.error('Failed to update status:', error);\n    }\n  }\n  \n  /**\n   * Update devices list\n   */\n  private async updateDevices(): Promise<void> {\n    try {\n      let currentState: KismetServiceState;\n      this.state.subscribe(s => currentState = s)();\n      \n      const devices = await kismetAPI.getDevices({\n        filters: currentState.filters,\n        limit: 1000\n      });\n      \n      this.updateState({ devices });\n    } catch (error) {\n      console.error('Failed to update devices:', error);\n    }\n  }\n  \n  /**\n   * Load available scripts\n   */\n  private async loadScripts(): Promise<void> {\n    try {\n      const scripts = await kismetAPI.getScripts();\n      this.updateState({ scripts });\n    } catch (error) {\n      console.error('Failed to load scripts:', error);\n    }\n  }\n  \n  /**\n   * Handle service down\n   */\n  private handleServiceDown(): void {\n    if (this.restartAttempts >= (this.serviceOptions.maxRestartAttempts || 3)) {\n      this.updateState({ \n        error: 'Kismet service is down and auto-restart failed. Please check the service manually.' \n      });\n      return;\n    }\n    \n    this.restartAttempts++;\n    // console.info(`Attempting to restart Kismet service (attempt ${this.restartAttempts})`);\n    \n    setTimeout(() => {\n      try {\n        void this.startService();\n      } catch (error) {\n        console.error('Auto-restart failed:', error);\n      }\n    }, this.serviceOptions.restartDelay);\n  }\n  \n  /**\n   * Update state helper\n   */\n  private updateState(partial: Partial<KismetServiceState>): void {\n    this.state.update(state => ({ ...state, ...partial }));\n  }\n  \n  /**\n   * Handle errors\n   */\n  private handleError(message: string, error: unknown): void {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    console.error(`${message}:`, error);\n    this.updateState({ error: `${message}: ${errorMessage}` });\n  }\n  \n  /**\n   * Cleanup resources\n   */\n  destroy(): void {\n    if (this.statusInterval) {\n      clearInterval(this.statusInterval);\n    }\n    \n    if (this.deviceInterval) {\n      clearInterval(this.deviceInterval);\n    }\n    \n    if (this.websocket) {\n      this.websocket.disconnect();\n    }\n  }\n}\n\n// Export singleton instance\nexport const kismetService = new KismetService();",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/map/aiPatternDetector.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 16,
				"column": 28,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 16,
				"endColumn": 31,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [412, 415], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [412, 415], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 63,
				"column": 5,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 63,
				"endColumn": 33,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [1627, 1628], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 89,
				"column": 23,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 89,
				"endColumn": 57
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 121,
				"column": 23,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 121,
				"endColumn": 58
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 360,
				"column": 7,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 360,
				"endColumn": 34,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [11714, 11715], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 5,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "/**\n * AI-powered pattern detection for RF signals\n * Identifies anomalies, moving signals, and interesting patterns\n */\n\nimport type { SignalMarker } from '$lib/stores/map/signals';\n\nexport interface Pattern {\n  id: string;\n  type: PatternType;\n  confidence: number; // 0-1\n  priority: 'high' | 'medium' | 'low';\n  signals: SignalMarker[];\n  description: string;\n  timestamp: number;\n  metadata: Record<string, any>;\n}\n\nexport type PatternType = \n  | 'new_device'\n  | 'moving_signal'\n  | 'anomalous_power'\n  | 'frequency_hopping'\n  | 'device_cluster'\n  | 'suspicious_behavior'\n  | 'infrastructure'\n  | 'routine_traffic';\n\nexport interface PatternDetectorConfig {\n  enabledPatterns: PatternType[];\n  sensitivityLevel: 'high' | 'medium' | 'low';\n  baselineLearningTime: number; // minutes\n  anomalyThreshold: number; // standard deviations\n}\n\nexport const DEFAULT_PATTERN_CONFIG: PatternDetectorConfig = {\n  enabledPatterns: [\n    'new_device',\n    'moving_signal',\n    'anomalous_power',\n    'frequency_hopping',\n    'suspicious_behavior'\n  ],\n  sensitivityLevel: 'medium',\n  baselineLearningTime: 5,\n  anomalyThreshold: 2.5\n};\n\n/**\n * Signal baseline for anomaly detection\n */\nexport class SignalBaseline {\n  private signalHistory = new Map<string, SignalMarker[]>();\n  private locationProfiles = new Map<string, LocationProfile>();\n  private deviceProfiles = new Map<string, DeviceProfile>();\n  private startTime = Date.now();\n  \n  addSignal(signal: SignalMarker) {\n    const key = this.getSignalKey(signal);\n    if (!this.signalHistory.has(key)) {\n      this.signalHistory.set(key, []);\n    }\n    this.signalHistory.get(key)!.push(signal);\n    \n    // Update profiles\n    this.updateLocationProfile(signal);\n    this.updateDeviceProfile(signal);\n  }\n  \n  private getSignalKey(signal: SignalMarker): string {\n    // Create a key based on frequency band and approximate location\n    const freqBand = Math.floor(signal.frequency / 100) * 100;\n    const latGrid = Math.floor(signal.lat * 1000) / 1000;\n    const lonGrid = Math.floor(signal.lon * 1000) / 1000;\n    return `${freqBand}_${latGrid}_${lonGrid}`;\n  }\n  \n  private updateLocationProfile(signal: SignalMarker) {\n    const locKey = `${Math.floor(signal.lat * 100)}_${Math.floor(signal.lon * 100)}`;\n    \n    if (!this.locationProfiles.has(locKey)) {\n      this.locationProfiles.set(locKey, {\n        position: { lat: signal.lat, lon: signal.lon },\n        typicalPower: { mean: signal.power, stdDev: 0, samples: 1 },\n        typicalFrequencies: new Set([signal.frequency]),\n        deviceTypes: new Map()\n      });\n    } else {\n      const profile = this.locationProfiles.get(locKey)!;\n      // Update running statistics\n      const oldMean = profile.typicalPower.mean;\n      const n = profile.typicalPower.samples;\n      profile.typicalPower.mean = (oldMean * n + signal.power) / (n + 1);\n      profile.typicalPower.samples++;\n      \n      // Update standard deviation\n      const variance = Math.pow(signal.power - profile.typicalPower.mean, 2);\n      profile.typicalPower.stdDev = Math.sqrt(\n        (profile.typicalPower.stdDev * profile.typicalPower.stdDev * n + variance) / (n + 1)\n      );\n      \n      profile.typicalFrequencies.add(signal.frequency);\n      \n      const deviceType = signal.metadata?.signalType || 'unknown';\n      profile.deviceTypes.set(deviceType, (profile.deviceTypes.get(deviceType) || 0) + 1);\n    }\n  }\n  \n  private updateDeviceProfile(signal: SignalMarker) {\n    const deviceKey = `${signal.metadata?.signalType}_${Math.floor(signal.frequency / 100)}`;\n    \n    if (!this.deviceProfiles.has(deviceKey)) {\n      this.deviceProfiles.set(deviceKey, {\n        type: signal.metadata?.signalType || 'unknown',\n        typicalPower: { mean: signal.power, stdDev: 0, samples: 1 },\n        frequencyRange: { min: signal.frequency, max: signal.frequency },\n        lastSeen: signal.timestamp,\n        locations: new Set([`${signal.lat.toFixed(4)}_${signal.lon.toFixed(4)}`])\n      });\n    } else {\n      const profile = this.deviceProfiles.get(deviceKey)!;\n      \n      // Update power statistics\n      const oldMean = profile.typicalPower.mean;\n      const n = profile.typicalPower.samples;\n      profile.typicalPower.mean = (oldMean * n + signal.power) / (n + 1);\n      profile.typicalPower.samples++;\n      \n      profile.frequencyRange.min = Math.min(profile.frequencyRange.min, signal.frequency);\n      profile.frequencyRange.max = Math.max(profile.frequencyRange.max, signal.frequency);\n      profile.lastSeen = signal.timestamp;\n      profile.locations.add(`${signal.lat.toFixed(4)}_${signal.lon.toFixed(4)}`);\n    }\n  }\n  \n  isAnomaly(signal: SignalMarker, threshold: number): boolean {\n    // Check if we have enough baseline data\n    if (Date.now() - this.startTime < 60000) return false; // Need at least 1 minute\n    \n    const locKey = `${Math.floor(signal.lat * 100)}_${Math.floor(signal.lon * 100)}`;\n    const locationProfile = this.locationProfiles.get(locKey);\n    \n    if (!locationProfile || locationProfile.typicalPower.samples < 10) {\n      return false; // Not enough data\n    }\n    \n    // Check if power is anomalous\n    const powerDiff = Math.abs(signal.power - locationProfile.typicalPower.mean);\n    const sigmas = powerDiff / (locationProfile.typicalPower.stdDev + 0.01);\n    \n    return sigmas > threshold;\n  }\n  \n  getDeviceMovement(deviceType: string): number {\n    const profiles = Array.from(this.deviceProfiles.entries())\n      .filter(([key]) => key.startsWith(deviceType))\n      .map(([_, profile]) => profile);\n    \n    if (profiles.length === 0) return 0;\n    \n    // Calculate average location spread\n    let totalSpread = 0;\n    profiles.forEach(profile => {\n      totalSpread += profile.locations.size;\n    });\n    \n    return totalSpread / profiles.length;\n  }\n}\n\ninterface LocationProfile {\n  position: { lat: number; lon: number };\n  typicalPower: { mean: number; stdDev: number; samples: number };\n  typicalFrequencies: Set<number>;\n  deviceTypes: Map<string, number>;\n}\n\ninterface DeviceProfile {\n  type: string;\n  typicalPower: { mean: number; stdDev: number; samples: number };\n  frequencyRange: { min: number; max: number };\n  lastSeen: number;\n  locations: Set<string>;\n}\n\n/**\n * AI Pattern Detector\n */\nexport class AIPatternDetector {\n  private baseline = new SignalBaseline();\n  private detectedPatterns = new Map<string, Pattern>();\n  private signalBuffer: SignalMarker[] = [];\n  private config: PatternDetectorConfig;\n  \n  constructor(config: PatternDetectorConfig = DEFAULT_PATTERN_CONFIG) {\n    this.config = config;\n  }\n  \n  /**\n   * Process new signal and detect patterns\n   */\n  processSignal(signal: SignalMarker): Pattern[] {\n    this.signalBuffer.push(signal);\n    this.baseline.addSignal(signal);\n    \n    // Keep buffer size manageable\n    if (this.signalBuffer.length > 1000) {\n      this.signalBuffer = this.signalBuffer.slice(-1000);\n    }\n    \n    const patterns: Pattern[] = [];\n    \n    // Run enabled pattern detectors\n    if (this.config.enabledPatterns.includes('new_device')) {\n      const newDevice = this.detectNewDevice(signal);\n      if (newDevice) patterns.push(newDevice);\n    }\n    \n    if (this.config.enabledPatterns.includes('anomalous_power')) {\n      const anomaly = this.detectAnomalousPower(signal);\n      if (anomaly) patterns.push(anomaly);\n    }\n    \n    if (this.config.enabledPatterns.includes('moving_signal')) {\n      const moving = this.detectMovingSignal(signal);\n      if (moving) patterns.push(moving);\n    }\n    \n    if (this.config.enabledPatterns.includes('frequency_hopping')) {\n      const hopping = this.detectFrequencyHopping();\n      if (hopping) patterns.push(hopping);\n    }\n    \n    if (this.config.enabledPatterns.includes('suspicious_behavior')) {\n      const suspicious = this.detectSuspiciousBehavior(signal);\n      if (suspicious) patterns.push(suspicious);\n    }\n    \n    // Store detected patterns\n    patterns.forEach(pattern => {\n      this.detectedPatterns.set(pattern.id, pattern);\n    });\n    \n    return patterns;\n  }\n  \n  /**\n   * Detect new device appearance\n   */\n  private detectNewDevice(signal: SignalMarker): Pattern | null {\n    const recentSignals = this.signalBuffer.slice(-100);\n    const similarSignals = recentSignals.filter(s => \n      Math.abs(s.frequency - signal.frequency) < 10 &&\n      this.calculateDistance({lat: s.lat, lon: s.lon}, {lat: signal.lat, lon: signal.lon}) < 50\n    );\n    \n    if (similarSignals.length === 1) { // Only this signal\n      return {\n        id: `new-device-${Date.now()}`,\n        type: 'new_device',\n        confidence: 0.8,\n        priority: 'medium',\n        signals: [signal],\n        description: `New ${signal.metadata?.signalType || 'unknown'} device detected at ${signal.frequency.toFixed(0)} MHz`,\n        timestamp: Date.now(),\n        metadata: {\n          deviceType: signal.metadata?.signalType,\n          frequency: signal.frequency,\n          power: signal.power\n        }\n      };\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Detect anomalous power levels\n   */\n  private detectAnomalousPower(signal: SignalMarker): Pattern | null {\n    if (this.baseline.isAnomaly(signal, this.config.anomalyThreshold)) {\n      return {\n        id: `anomaly-power-${Date.now()}`,\n        type: 'anomalous_power',\n        confidence: 0.7,\n        priority: signal.power > -40 ? 'high' : 'medium',\n        signals: [signal],\n        description: `Unusual signal strength: ${signal.power.toFixed(0)} dBm at ${signal.frequency.toFixed(0)} MHz`,\n        timestamp: Date.now(),\n        metadata: {\n          power: signal.power,\n          expectedRange: { min: -80, max: -50 }\n        }\n      };\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Detect moving signals\n   */\n  private detectMovingSignal(signal: SignalMarker): Pattern | null {\n    const timeWindow = 30000; // 30 seconds\n    const recentSignals = this.signalBuffer.filter(s => \n      s.timestamp > Date.now() - timeWindow &&\n      Math.abs(s.frequency - signal.frequency) < 5 &&\n      s.metadata?.signalType === signal.metadata?.signalType\n    );\n    \n    if (recentSignals.length < 3) return null;\n    \n    // Calculate movement\n    let totalDistance = 0;\n    for (let i = 1; i < recentSignals.length; i++) {\n      totalDistance += this.calculateDistance(\n        {lat: recentSignals[i-1].lat, lon: recentSignals[i-1].lon},\n        {lat: recentSignals[i].lat, lon: recentSignals[i].lon}\n      );\n    }\n    \n    const avgSpeed = totalDistance / (timeWindow / 1000); // m/s\n    \n    if (avgSpeed > 1) { // Moving faster than 1 m/s\n      return {\n        id: `moving-signal-${Date.now()}`,\n        type: 'moving_signal',\n        confidence: Math.min(0.9, avgSpeed / 10),\n        priority: avgSpeed > 10 ? 'high' : 'medium',\n        signals: recentSignals,\n        description: `Moving signal detected: ${avgSpeed.toFixed(1)} m/s`,\n        timestamp: Date.now(),\n        metadata: {\n          speed: avgSpeed,\n          direction: this.calculateDirection(recentSignals),\n          trajectory: recentSignals.map(s => ({lat: s.lat, lon: s.lon}))\n        }\n      };\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Detect frequency hopping behavior\n   */\n  private detectFrequencyHopping(): Pattern | null {\n    const timeWindow = 10000; // 10 seconds\n    const recentSignals = this.signalBuffer.filter(s => \n      s.timestamp > Date.now() - timeWindow\n    );\n    \n    // Group by approximate location\n    const locationGroups = new Map<string, SignalMarker[]>();\n    recentSignals.forEach(signal => {\n      const locKey = `${Math.floor(signal.lat * 1000)}_${Math.floor(signal.lon * 1000)}`;\n      if (!locationGroups.has(locKey)) {\n        locationGroups.set(locKey, []);\n      }\n      locationGroups.get(locKey)!.push(signal);\n    });\n    \n    // Check each location group for frequency hopping\n    for (const [locKey, signals] of locationGroups) {\n      if (signals.length < 5) continue;\n      \n      // Check frequency variation\n      const frequencies = signals.map(s => s.frequency);\n      const uniqueFreqs = new Set(frequencies);\n      \n      if (uniqueFreqs.size >= 3 && uniqueFreqs.size === signals.length) {\n        // All different frequencies - possible hopping\n        return {\n          id: `freq-hopping-${Date.now()}`,\n          type: 'frequency_hopping',\n          confidence: 0.75,\n          priority: 'high',\n          signals,\n          description: `Frequency hopping detected: ${uniqueFreqs.size} frequencies in ${timeWindow/1000}s`,\n          timestamp: Date.now(),\n          metadata: {\n            frequencies: Array.from(uniqueFreqs).sort(),\n            hopRate: uniqueFreqs.size / (timeWindow / 1000),\n            location: locKey\n          }\n        };\n      }\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Detect suspicious behavior patterns\n   */\n  private detectSuspiciousBehavior(signal: SignalMarker): Pattern | null {\n    // Check for unusual characteristics\n    const suspicious: string[] = [];\n    \n    // Very high power in unexpected frequency\n    if (signal.power > -30 && !this.isExpectedHighPower(signal)) {\n      suspicious.push('Unusually high power');\n    }\n    \n    // Rapid appearance/disappearance\n    const similarRecent = this.signalBuffer.slice(-20).filter(s =>\n      Math.abs(s.frequency - signal.frequency) < 5 &&\n      this.calculateDistance({lat: s.lat, lon: s.lon}, {lat: signal.lat, lon: signal.lon}) < 20\n    );\n    \n    if (similarRecent.length === 1 && this.signalBuffer.length > 10) {\n      suspicious.push('Burst transmission');\n    }\n    \n    // Non-standard frequencies\n    if (!this.isStandardFrequency(signal.frequency)) {\n      suspicious.push('Non-standard frequency');\n    }\n    \n    if (suspicious.length > 0) {\n      return {\n        id: `suspicious-${Date.now()}`,\n        type: 'suspicious_behavior',\n        confidence: 0.6 + (suspicious.length * 0.1),\n        priority: suspicious.length > 1 ? 'high' : 'medium',\n        signals: [signal],\n        description: `Suspicious signal: ${suspicious.join(', ')}`,\n        timestamp: Date.now(),\n        metadata: {\n          reasons: suspicious,\n          frequency: signal.frequency,\n          power: signal.power\n        }\n      };\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Helper functions\n   */\n  private calculateDistance(pos1: { lat: number; lon: number }, pos2: { lat: number; lon: number }): number {\n    const R = 6371e3;\n    const φ1 = pos1.lat * Math.PI / 180;\n    const φ2 = pos2.lat * Math.PI / 180;\n    const Δφ = (pos2.lat - pos1.lat) * Math.PI / 180;\n    const Δλ = (pos2.lon - pos1.lon) * Math.PI / 180;\n\n    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +\n              Math.cos(φ1) * Math.cos(φ2) *\n              Math.sin(Δλ/2) * Math.sin(Δλ/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\n    return R * c;\n  }\n  \n  private calculateDirection(signals: SignalMarker[]): number {\n    if (signals.length < 2) return 0;\n    \n    const first = {lat: signals[0].lat, lon: signals[0].lon};\n    const last = {lat: signals[signals.length - 1].lat, lon: signals[signals.length - 1].lon};\n    \n    const dLon = (last.lon - first.lon) * Math.PI / 180;\n    const y = Math.sin(dLon) * Math.cos(last.lat * Math.PI / 180);\n    const x = Math.cos(first.lat * Math.PI / 180) * Math.sin(last.lat * Math.PI / 180) -\n              Math.sin(first.lat * Math.PI / 180) * Math.cos(last.lat * Math.PI / 180) * Math.cos(dLon);\n    \n    const bearing = Math.atan2(y, x) * 180 / Math.PI;\n    return (bearing + 360) % 360;\n  }\n  \n  private isExpectedHighPower(signal: SignalMarker): boolean {\n    // Cell towers and known APs can have high power\n    return signal.metadata?.signalType === 'cellular' || \n           (signal.metadata?.signalType === 'wifi_2.4' && signal.power > -40);\n  }\n  \n  private isStandardFrequency(freq: number): boolean {\n    // Check against known frequency bands\n    const standardBands = [\n      { min: 2400, max: 2484 },    // 2.4 GHz WiFi/Bluetooth\n      { min: 5150, max: 5875 },    // 5 GHz WiFi\n      { min: 824, max: 894 },      // Cellular 850\n      { min: 1850, max: 1990 },    // Cellular 1900\n      { min: 902, max: 928 },      // ISM 900\n      { min: 433, max: 435 }       // ISM 433\n    ];\n    \n    return standardBands.some(band => freq >= band.min && freq <= band.max);\n  }\n  \n  /**\n   * Get filtered signals based on pattern priority\n   */\n  getFilteredSignals(signals: SignalMarker[], minPriority: 'low' | 'medium' | 'high' = 'medium'): SignalMarker[] {\n    const priorityMap = { low: 0, medium: 1, high: 2 };\n    const minPriorityValue = priorityMap[minPriority];\n    \n    // Get all signals that are part of high-priority patterns\n    const importantSignalIds = new Set<string>();\n    \n    this.detectedPatterns.forEach(pattern => {\n      if (priorityMap[pattern.priority] >= minPriorityValue) {\n        pattern.signals.forEach(signal => {\n          importantSignalIds.add(signal.id);\n        });\n      }\n    });\n    \n    return signals.filter(signal => importantSignalIds.has(signal.id));\n  }\n  \n  /**\n   * Get active patterns\n   */\n  getActivePatterns(maxAge: number = 60000): Pattern[] {\n    const now = Date.now();\n    return Array.from(this.detectedPatterns.values())\n      .filter(pattern => now - pattern.timestamp < maxAge)\n      .sort((a, b) => {\n        // Sort by priority then timestamp\n        const priorityOrder = { high: 0, medium: 1, low: 2 };\n        const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];\n        if (priorityDiff !== 0) return priorityDiff;\n        return b.timestamp - a.timestamp;\n      });\n  }\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/map/altitudeLayerManager.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'HeatmapLayer' is defined but never used. Allowed unused vars must match /^_/u.",
				"line": 6,
				"column": 15,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 6,
				"endColumn": 27
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "/**\n * Altitude layer manager for drone signal visualization\n * Manages multiple heatmap layers at different altitude bands\n */\n\nimport type { HeatmapLayer } from './heatmapService';\n\nexport interface AltitudeBand {\n  id: string;\n  name: string;\n  minAltitude: number; // meters\n  maxAltitude: number; // meters\n  color: string; // Primary color for this band\n  icon: string; // Icon identifier\n}\n\nexport interface LayerBlendMode {\n  mode: 'normal' | 'additive' | 'multiply' | 'screen';\n  opacity: number;\n}\n\nexport class AltitudeLayerManager {\n  private bands: Map<string, AltitudeBand> = new Map();\n  private layerVisibility: Map<string, boolean> = new Map();\n  private layerOpacity: Map<string, number> = new Map();\n  private blendMode: LayerBlendMode = {\n    mode: 'normal',\n    opacity: 1\n  };\n  \n  // Predefined altitude bands for drone operations\n  private defaultBands: AltitudeBand[] = [\n    {\n      id: 'ground',\n      name: 'Ground Level',\n      minAltitude: 0,\n      maxAltitude: 50,\n      color: '#00ff00',\n      icon: 'ground'\n    },\n    {\n      id: 'low',\n      name: 'Low Altitude',\n      minAltitude: 50,\n      maxAltitude: 150,\n      color: '#ffff00',\n      icon: 'low-flight'\n    },\n    {\n      id: 'medium',\n      name: 'Medium Altitude',\n      minAltitude: 150,\n      maxAltitude: 400,\n      color: '#ff8800',\n      icon: 'medium-flight'\n    },\n    {\n      id: 'high',\n      name: 'High Altitude',\n      minAltitude: 400,\n      maxAltitude: 1000,\n      color: '#ff0000',\n      icon: 'high-flight'\n    },\n    {\n      id: 'vhigh',\n      name: 'Very High Altitude',\n      minAltitude: 1000,\n      maxAltitude: 10000,\n      color: '#ff00ff',\n      icon: 'very-high-flight'\n    }\n  ];\n\n  constructor() {\n    this.initializeDefaultBands();\n  }\n\n  /**\n   * Initialize default altitude bands\n   */\n  private initializeDefaultBands(): void {\n    this.defaultBands.forEach(band => {\n      this.bands.set(band.id, band);\n      this.layerVisibility.set(band.id, true);\n      this.layerOpacity.set(band.id, 0.7);\n    });\n  }\n\n  /**\n   * Add custom altitude band\n   */\n  addBand(band: AltitudeBand): void {\n    this.bands.set(band.id, band);\n    this.layerVisibility.set(band.id, true);\n    this.layerOpacity.set(band.id, 0.7);\n  }\n\n  /**\n   * Remove altitude band\n   */\n  removeBand(bandId: string): void {\n    this.bands.delete(bandId);\n    this.layerVisibility.delete(bandId);\n    this.layerOpacity.delete(bandId);\n  }\n\n  /**\n   * Get all bands\n   */\n  getBands(): AltitudeBand[] {\n    return Array.from(this.bands.values());\n  }\n\n  /**\n   * Get band for specific altitude\n   */\n  getBandForAltitude(altitude: number): AltitudeBand | null {\n    for (const band of this.bands.values()) {\n      if (altitude >= band.minAltitude && altitude < band.maxAltitude) {\n        return band;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Set layer visibility\n   */\n  setLayerVisibility(bandId: string, visible: boolean): void {\n    this.layerVisibility.set(bandId, visible);\n  }\n\n  /**\n   * Get layer visibility\n   */\n  isLayerVisible(bandId: string): boolean {\n    return this.layerVisibility.get(bandId) ?? false;\n  }\n\n  /**\n   * Set layer opacity\n   */\n  setLayerOpacity(bandId: string, opacity: number): void {\n    this.layerOpacity.set(bandId, Math.max(0, Math.min(1, opacity)));\n  }\n\n  /**\n   * Get layer opacity\n   */\n  getLayerOpacity(bandId: string): number {\n    return this.layerOpacity.get(bandId) ?? 0.7;\n  }\n\n  /**\n   * Set blend mode for all layers\n   */\n  setBlendMode(mode: LayerBlendMode): void {\n    this.blendMode = mode;\n  }\n\n  /**\n   * Get current blend mode\n   */\n  getBlendMode(): LayerBlendMode {\n    return this.blendMode;\n  }\n\n  /**\n   * Toggle all layers visibility\n   */\n  toggleAllLayers(visible: boolean): void {\n    this.bands.forEach((_, bandId) => {\n      this.layerVisibility.set(bandId, visible);\n    });\n  }\n\n  /**\n   * Set opacity for all layers\n   */\n  setAllLayersOpacity(opacity: number): void {\n    this.bands.forEach((_, bandId) => {\n      this.layerOpacity.set(bandId, opacity);\n    });\n  }\n\n  /**\n   * Get visible altitude range\n   */\n  getVisibleAltitudeRange(): { min: number; max: number } {\n    let min = Infinity;\n    let max = -Infinity;\n\n    this.bands.forEach((band, bandId) => {\n      if (this.isLayerVisible(bandId)) {\n        min = Math.min(min, band.minAltitude);\n        max = Math.max(max, band.maxAltitude);\n      }\n    });\n\n    return {\n      min: min === Infinity ? 0 : min,\n      max: max === -Infinity ? 10000 : max\n    };\n  }\n\n  /**\n   * Create gradient for altitude band\n   */\n  createGradientForBand(bandId: string): Record<number, string> {\n    const band = this.bands.get(bandId);\n    if (!band) {\n      return {\n        0.0: '#0000ff',\n        0.5: '#00ff00',\n        1.0: '#ff0000'\n      };\n    }\n\n    // Create gradient based on band color\n    const baseColor = band.color;\n    const rgb = this.hexToRgb(baseColor);\n    \n    if (!rgb) {\n      return {\n        0.0: '#0000ff',\n        0.5: '#00ff00',\n        1.0: '#ff0000'\n      };\n    }\n\n    // Create gradient from dark to bright version of the color\n    return {\n      0.0: this.rgbToHex(rgb[0] * 0.2, rgb[1] * 0.2, rgb[2] * 0.2),\n      0.3: this.rgbToHex(rgb[0] * 0.5, rgb[1] * 0.5, rgb[2] * 0.5),\n      0.6: baseColor,\n      0.8: this.rgbToHex(\n        Math.min(255, rgb[0] * 1.3),\n        Math.min(255, rgb[1] * 1.3),\n        Math.min(255, rgb[2] * 1.3)\n      ),\n      1.0: this.rgbToHex(\n        Math.min(255, rgb[0] * 1.5),\n        Math.min(255, rgb[1] * 1.5),\n        Math.min(255, rgb[2] * 1.5)\n      )\n    };\n  }\n\n  /**\n   * Get altitude statistics from signals\n   */\n  getAltitudeStatistics(signals: Array<{ altitude?: number }>): {\n    min: number;\n    max: number;\n    average: number;\n    distribution: Map<string, number>;\n  } {\n    const altitudes = signals\n      .map(s => s.altitude ?? 0)\n      .filter(alt => alt >= 0);\n\n    if (altitudes.length === 0) {\n      return {\n        min: 0,\n        max: 0,\n        average: 0,\n        distribution: new Map()\n      };\n    }\n\n    const min = Math.min(...altitudes);\n    const max = Math.max(...altitudes);\n    const average = altitudes.reduce((a, b) => a + b, 0) / altitudes.length;\n\n    // Calculate distribution by band\n    const distribution = new Map<string, number>();\n    this.bands.forEach((band, bandId) => {\n      const count = altitudes.filter(\n        alt => alt >= band.minAltitude && alt < band.maxAltitude\n      ).length;\n      distribution.set(bandId, count);\n    });\n\n    return { min, max, average, distribution };\n  }\n\n  /**\n   * Convert hex to RGB\n   */\n  private hexToRgb(hex: string): [number, number, number] | null {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? [\n      parseInt(result[1], 16),\n      parseInt(result[2], 16),\n      parseInt(result[3], 16)\n    ] : null;\n  }\n\n  /**\n   * Convert RGB to hex\n   */\n  private rgbToHex(r: number, g: number, b: number): string {\n    const toHex = (n: number) => {\n      const hex = Math.round(n).toString(16);\n      return hex.length === 1 ? '0' + hex : hex;\n    };\n    return '#' + toHex(r) + toHex(g) + toHex(b);\n  }\n\n  /**\n   * Export configuration\n   */\n  exportConfig(): {\n    bands: AltitudeBand[];\n    visibility: Record<string, boolean>;\n    opacity: Record<string, number>;\n    blendMode: LayerBlendMode;\n  } {\n    return {\n      bands: Array.from(this.bands.values()),\n      visibility: Object.fromEntries(this.layerVisibility),\n      opacity: Object.fromEntries(this.layerOpacity),\n      blendMode: this.blendMode\n    };\n  }\n\n  /**\n   * Import configuration\n   */\n  importConfig(config: {\n    bands?: AltitudeBand[];\n    visibility?: Record<string, boolean>;\n    opacity?: Record<string, number>;\n    blendMode?: LayerBlendMode;\n  }): void {\n    if (config.bands) {\n      this.bands.clear();\n      config.bands.forEach(band => this.addBand(band));\n    }\n\n    if (config.visibility) {\n      Object.entries(config.visibility).forEach(([bandId, visible]) => {\n        this.layerVisibility.set(bandId, visible);\n      });\n    }\n\n    if (config.opacity) {\n      Object.entries(config.opacity).forEach(([bandId, opacity]) => {\n        this.layerOpacity.set(bandId, opacity);\n      });\n    }\n\n    if (config.blendMode) {\n      this.blendMode = config.blendMode;\n    }\n  }\n}\n\n// Singleton instance\nlet altitudeLayerManagerInstance: AltitudeLayerManager | null = null;\n\nexport function getAltitudeLayerManager(): AltitudeLayerManager {\n  if (!altitudeLayerManagerInstance) {\n    altitudeLayerManagerInstance = new AltitudeLayerManager();\n  }\n  return altitudeLayerManagerInstance;\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/map/contourGenerator.ts",
		"messages": [
			{
				"ruleId": "no-case-declarations",
				"severity": 2,
				"message": "Unexpected lexical declaration in case block.",
				"line": 177,
				"column": 7,
				"nodeType": "VariableDeclaration",
				"messageId": "unexpected",
				"endLine": 177,
				"endColumn": 71,
				"suggestions": [
					{
						"messageId": "addBrackets",
						"fix": {
							"range": [5108, 5242],
							"text": "{ const t0 = (level - grid[i][j]) / (grid[i][j + 1] - grid[i][j]);\n      lat = baseLat;\n      lon = baseLon + t0 * lonStep;\n      break; }"
						},
						"desc": "Add {} brackets around the case block."
					}
				]
			},
			{
				"ruleId": "no-case-declarations",
				"severity": 2,
				"message": "Unexpected lexical declaration in case block.",
				"line": 182,
				"column": 7,
				"nodeType": "VariableDeclaration",
				"messageId": "unexpected",
				"endLine": 182,
				"endColumn": 83,
				"suggestions": [
					{
						"messageId": "addBrackets",
						"fix": {
							"range": [5275, 5431],
							"text": "{ const t1 = (level - grid[i][j + 1]) / (grid[i + 1][j + 1] - grid[i][j + 1]);\n      lat = baseLat + t1 * latStep;\n      lon = baseLon + lonStep;\n      break; }"
						},
						"desc": "Add {} brackets around the case block."
					}
				]
			},
			{
				"ruleId": "no-case-declarations",
				"severity": 2,
				"message": "Unexpected lexical declaration in case block.",
				"line": 187,
				"column": 7,
				"nodeType": "VariableDeclaration",
				"messageId": "unexpected",
				"endLine": 187,
				"endColumn": 83,
				"suggestions": [
					{
						"messageId": "addBrackets",
						"fix": {
							"range": [5465, 5621],
							"text": "{ const t2 = (level - grid[i + 1][j]) / (grid[i + 1][j + 1] - grid[i + 1][j]);\n      lat = baseLat + latStep;\n      lon = baseLon + t2 * lonStep;\n      break; }"
						},
						"desc": "Add {} brackets around the case block."
					}
				]
			},
			{
				"ruleId": "no-case-declarations",
				"severity": 2,
				"message": "Unexpected lexical declaration in case block.",
				"line": 192,
				"column": 7,
				"nodeType": "VariableDeclaration",
				"messageId": "unexpected",
				"endLine": 192,
				"endColumn": 71,
				"suggestions": [
					{
						"messageId": "addBrackets",
						"fix": {
							"range": [5653, 5787],
							"text": "{ const t3 = (level - grid[i][j]) / (grid[i + 1][j] - grid[i][j]);\n      lat = baseLat + t3 * latStep;\n      lon = baseLon;\n      break; }"
						},
						"desc": "Add {} brackets around the case block."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 4,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "/**\n * Contour line generation for RF signal visualization\n * Uses marching squares algorithm to create smooth contour lines\n */\n\nimport type { SignalMarker } from '$lib/stores/map/signals';\n\nexport interface ContourPoint {\n  lat: number;\n  lon: number;\n  value: number;\n}\n\nexport interface ContourLine {\n  points: [number, number][];\n  level: number;\n  color: string;\n}\n\nexport interface ContourConfig {\n  levels: number[]; // Signal strength levels to create contours for\n  smoothing: number; // Smoothing factor (0-1)\n  resolution: number; // Grid resolution in meters\n  colors: string[]; // Colors for each level\n}\n\nexport const DEFAULT_CONTOUR_CONFIG: ContourConfig = {\n  levels: [-90, -80, -70, -60, -50], // dBm levels\n  smoothing: 0.5,\n  resolution: 25, // 25m grid\n  colors: ['#0066ff', '#66ff00', '#ffcc00', '#ff6600', '#ff0000'] // Blue to Red\n};\n\n/**\n * Interpolate signal strength at a given point using IDW (Inverse Distance Weighting)\n */\nfunction interpolateValue(lat: number, lon: number, signals: SignalMarker[]): number {\n  if (signals.length === 0) return -100; // No signal\n  \n  let weightedSum = 0;\n  let weightSum = 0;\n  \n  for (const signal of signals) {\n    const distance = calculateDistance(lat, lon, signal.lat, signal.lon);\n    \n    // If very close to a measurement point, return its value\n    if (distance < 1) return signal.power;\n    \n    // IDW with power parameter of 2\n    const weight = 1 / (distance * distance);\n    weightedSum += signal.power * weight;\n    weightSum += weight;\n  }\n  \n  return weightSum > 0 ? weightedSum / weightSum : -100;\n}\n\n/**\n * Calculate distance between two points in meters\n */\nfunction calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n  const R = 6371e3; // Earth's radius in meters\n  const φ1 = lat1 * Math.PI / 180;\n  const φ2 = lat2 * Math.PI / 180;\n  const Δφ = (lat2 - lat1) * Math.PI / 180;\n  const Δλ = (lon2 - lon1) * Math.PI / 180;\n\n  const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +\n            Math.cos(φ1) * Math.cos(φ2) *\n            Math.sin(Δλ/2) * Math.sin(Δλ/2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\n  return R * c;\n}\n\n/**\n * Create a regular grid of interpolated values\n */\nfunction createGrid(\n  bounds: { minLat: number; maxLat: number; minLon: number; maxLon: number },\n  resolution: number,\n  signals: SignalMarker[]\n): { grid: number[][]; latStep: number; lonStep: number } {\n  const latMetersPerDegree = 111320;\n  const lonMetersPerDegree = 111320 * Math.cos(((bounds.minLat + bounds.maxLat) / 2) * Math.PI / 180);\n  \n  const latStep = resolution / latMetersPerDegree;\n  const lonStep = resolution / lonMetersPerDegree;\n  \n  const rows = Math.ceil((bounds.maxLat - bounds.minLat) / latStep);\n  const cols = Math.ceil((bounds.maxLon - bounds.minLon) / lonStep);\n  \n  const grid: number[][] = [];\n  \n  for (let i = 0; i < rows; i++) {\n    grid[i] = [];\n    for (let j = 0; j < cols; j++) {\n      const lat = bounds.minLat + i * latStep;\n      const lon = bounds.minLon + j * lonStep;\n      grid[i][j] = interpolateValue(lat, lon, signals);\n    }\n  }\n  \n  return { grid, latStep, lonStep };\n}\n\n/**\n * Marching squares algorithm to generate contour lines\n */\nfunction marchingSquares(\n  grid: number[][],\n  level: number,\n  bounds: { minLat: number; maxLat: number; minLon: number; maxLon: number },\n  latStep: number,\n  lonStep: number\n): [number, number][][] {\n  const lines: [number, number][][] = [];\n  const rows = grid.length;\n  const cols = grid[0]?.length || 0;\n  \n  // Marching squares lookup table\n  const edgeTable = [\n    [], [0, 3], [0, 1], [1, 3], [1, 2], [0, 1, 2, 3], [0, 2], [2, 3],\n    [2, 3], [0, 2], [0, 3, 1, 2], [1, 2], [1, 3], [0, 1], [0, 3], []\n  ];\n  \n  for (let i = 0; i < rows - 1; i++) {\n    for (let j = 0; j < cols - 1; j++) {\n      // Get corner values\n      const a = grid[i][j] >= level ? 1 : 0;\n      const b = grid[i][j + 1] >= level ? 1 : 0;\n      const c = grid[i + 1][j + 1] >= level ? 1 : 0;\n      const d = grid[i + 1][j] >= level ? 1 : 0;\n      \n      // Calculate index for lookup table\n      const index = a * 8 + b * 4 + c * 2 + d;\n      const edges = edgeTable[index];\n      \n      // Generate line segments\n      for (let k = 0; k < edges.length; k += 2) {\n        const edge1 = edges[k];\n        const edge2 = edges[k + 1];\n        \n        const point1 = interpolatePoint(i, j, edge1, grid, level, bounds, latStep, lonStep);\n        const point2 = interpolatePoint(i, j, edge2, grid, level, bounds, latStep, lonStep);\n        \n        if (point1 && point2) {\n          lines.push([point1, point2]);\n        }\n      }\n    }\n  }\n  \n  return lines;\n}\n\n/**\n * Interpolate point on cell edge\n */\nfunction interpolatePoint(\n  i: number,\n  j: number,\n  edge: number,\n  grid: number[][],\n  level: number,\n  bounds: { minLat: number; maxLat: number; minLon: number; maxLon: number },\n  latStep: number,\n  lonStep: number\n): [number, number] | null {\n  const baseLat = bounds.minLat + i * latStep;\n  const baseLon = bounds.minLon + j * lonStep;\n  \n  let lat: number, lon: number;\n  \n  switch (edge) {\n    case 0: // Top edge\n      const t0 = (level - grid[i][j]) / (grid[i][j + 1] - grid[i][j]);\n      lat = baseLat;\n      lon = baseLon + t0 * lonStep;\n      break;\n    case 1: // Right edge\n      const t1 = (level - grid[i][j + 1]) / (grid[i + 1][j + 1] - grid[i][j + 1]);\n      lat = baseLat + t1 * latStep;\n      lon = baseLon + lonStep;\n      break;\n    case 2: // Bottom edge\n      const t2 = (level - grid[i + 1][j]) / (grid[i + 1][j + 1] - grid[i + 1][j]);\n      lat = baseLat + latStep;\n      lon = baseLon + t2 * lonStep;\n      break;\n    case 3: // Left edge\n      const t3 = (level - grid[i][j]) / (grid[i + 1][j] - grid[i][j]);\n      lat = baseLat + t3 * latStep;\n      lon = baseLon;\n      break;\n    default:\n      return null;\n  }\n  \n  return [lat, lon];\n}\n\n/**\n * Connect line segments into continuous contours\n */\nfunction connectSegments(segments: [number, number][][]): [number, number][][] {\n  const contours: [number, number][][] = [];\n  const used = new Set<number>();\n  \n  for (let i = 0; i < segments.length; i++) {\n    if (used.has(i)) continue;\n    \n    const contour: [number, number][] = [];\n    let currentSegment = segments[i];\n    contour.push(currentSegment[0], currentSegment[1]);\n    used.add(i);\n    \n    // Try to connect segments\n    let found = true;\n    while (found) {\n      found = false;\n      const lastPoint = contour[contour.length - 1];\n      \n      for (let j = 0; j < segments.length; j++) {\n        if (used.has(j)) continue;\n        \n        const segment = segments[j];\n        const dist1 = Math.hypot(lastPoint[0] - segment[0][0], lastPoint[1] - segment[0][1]);\n        const dist2 = Math.hypot(lastPoint[0] - segment[1][0], lastPoint[1] - segment[1][1]);\n        \n        if (dist1 < 0.00001) { // Threshold for connection\n          contour.push(segment[1]);\n          used.add(j);\n          found = true;\n          break;\n        } else if (dist2 < 0.00001) {\n          contour.push(segment[0]);\n          used.add(j);\n          found = true;\n          break;\n        }\n      }\n    }\n    \n    if (contour.length > 2) {\n      contours.push(contour);\n    }\n  }\n  \n  return contours;\n}\n\n/**\n * Generate contour lines from signal data\n */\nexport function generateContours(\n  signals: SignalMarker[],\n  bounds: { minLat: number; maxLat: number; minLon: number; maxLon: number },\n  config: ContourConfig = DEFAULT_CONTOUR_CONFIG\n): ContourLine[] {\n  if (signals.length === 0) return [];\n  \n  // Create interpolated grid\n  const { grid, latStep, lonStep } = createGrid(bounds, config.resolution, signals);\n  \n  // Generate contour lines for each level\n  const contourLines: ContourLine[] = [];\n  \n  config.levels.forEach((level, index) => {\n    const segments = marchingSquares(grid, level, bounds, latStep, lonStep);\n    const contours = connectSegments(segments);\n    \n    contours.forEach(points => {\n      contourLines.push({\n        points,\n        level,\n        color: config.colors[index] || '#888888'\n      });\n    });\n  });\n  \n  return contourLines;\n}\n\n/**\n * Smooth contour lines using Chaikin's algorithm\n */\nexport function smoothContours(contours: ContourLine[], iterations: number = 2): ContourLine[] {\n  return contours.map(contour => ({\n    ...contour,\n    points: smoothPolyline(contour.points, iterations)\n  }));\n}\n\nfunction smoothPolyline(points: [number, number][], iterations: number): [number, number][] {\n  let smoothed = points;\n  \n  for (let i = 0; i < iterations; i++) {\n    const newPoints: [number, number][] = [];\n    \n    for (let j = 0; j < smoothed.length - 1; j++) {\n      const p1 = smoothed[j];\n      const p2 = smoothed[j + 1];\n      \n      // Chaikin's algorithm: cut corners at 1/4 and 3/4\n      newPoints.push([\n        0.75 * p1[0] + 0.25 * p2[0],\n        0.75 * p1[1] + 0.25 * p2[1]\n      ]);\n      newPoints.push([\n        0.25 * p1[0] + 0.75 * p2[0],\n        0.25 * p1[1] + 0.75 * p2[1]\n      ]);\n    }\n    \n    smoothed = newPoints;\n  }\n  \n  return smoothed;\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/map/droneDetection.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'DRONE_FREQUENCY_BANDS' is defined but never used. Allowed unused vars must match /^_/u.",
				"line": 7,
				"column": 47,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 7,
				"endColumn": 68
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 268,
				"column": 21,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 268,
				"endColumn": 52
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 1,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "/**\n * Drone Detection and Tracking Service\n * Specialized algorithms for identifying and tracking drone signals\n */\n\nimport type { SignalMarker } from '$lib/stores/map/signals';\nimport { signalFilter, type FilteringOptions, DRONE_FREQUENCY_BANDS } from './signalFiltering';\n\nexport interface DroneSignature {\n  id: string;\n  type: 'controller' | 'video' | 'telemetry' | 'unknown';\n  confidence: number;\n  signals: SignalMarker[];\n  trajectory?: TrajectoryData;\n  characteristics: DroneCharacteristics;\n  firstSeen: number;\n  lastSeen: number;\n  status: 'active' | 'lost' | 'landed';\n}\n\nexport interface TrajectoryData {\n  points: Array<{ lat: number; lon: number; timestamp: number; altitude?: number }>;\n  speed: number; // m/s\n  heading: number; // degrees\n  altitude?: number; // meters\n  verticalSpeed?: number; // m/s\n  predictedPath?: Array<{ lat: number; lon: number; timestamp: number }>;\n}\n\nexport interface DroneCharacteristics {\n  manufacturer?: string;\n  model?: string;\n  controlFreq?: number;\n  videoFreq?: number;\n  signalPattern: string; // 'continuous' | 'burst' | 'frequency_hopping'\n  powerProfile: 'commercial' | 'professional' | 'military' | 'custom';\n}\n\n// Known drone signal patterns\nconst DRONE_PATTERNS = {\n  DJI: {\n    control: [2400, 2483], // 2.4GHz\n    video: [5725, 5850], // 5.8GHz\n    signalPattern: 'continuous',\n    powerRange: [-70, -40]\n  },\n  Parrot: {\n    control: [2400, 2483],\n    video: [2400, 2483], // Uses same band\n    signalPattern: 'burst',\n    powerRange: [-75, -45]\n  },\n  Autel: {\n    control: [2400, 2483],\n    video: [5725, 5850],\n    signalPattern: 'continuous',\n    powerRange: [-70, -40]\n  },\n  Custom: {\n    control: [433, 915, 1200], // Various ISM bands\n    video: [1200, 2400, 5800],\n    signalPattern: 'frequency_hopping',\n    powerRange: [-80, -30]\n  }\n};\n\nexport class DroneDetectionService {\n  private activeDrones = new Map<string, DroneSignature>();\n  private signalAssociations = new Map<string, string>(); // signalId -> droneId\n  private detectionHistory = new Map<string, DroneSignature[]>();\n  \n  constructor(\n    private filterOptions: FilteringOptions = {\n      droneFrequencies: true,\n      minPower: -80,\n      movingSignalsOnly: false, // We'll handle movement detection ourselves\n      timeWindow: 60000 // 1 minute window\n    }\n  ) {}\n  \n  /**\n   * Process signals to detect and track drones\n   */\n  detectDrones(signals: SignalMarker[]): DroneDetectionResult {\n    // First, apply drone-specific filtering\n    const filtered = signalFilter.filterSignals(signals);\n    \n    // Group signals by potential drone associations\n    const droneGroups = this.groupSignalsByDrone(filtered.signals);\n    \n    // Update or create drone signatures\n    droneGroups.forEach(group => {\n      this.updateDroneSignature(group);\n    });\n    \n    // Clean up old/inactive drones\n    this.cleanupInactiveDrones();\n    \n    // Analyze trajectories and predict paths\n    this.updateTrajectories();\n    \n    // Generate alerts for significant events\n    const alerts = this.generateAlerts();\n    \n    return {\n      activeDrones: Array.from(this.activeDrones.values()),\n      totalSignals: filtered.signals.length,\n      filteredSignals: filtered.signals,\n      alerts,\n      statistics: this.generateStatistics()\n    };\n  }\n  \n  /**\n   * Group signals that likely belong to the same drone\n   */\n  private groupSignalsByDrone(signals: SignalMarker[]): SignalGroup[] {\n    const groups: SignalGroup[] = [];\n    const unassigned = new Set(signals);\n    \n    // First pass: Group by spatial-temporal proximity\n    signals.forEach(signal => {\n      if (!unassigned.has(signal)) return;\n      \n      const group: SignalGroup = {\n        id: `group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        signals: [signal],\n        centerLat: signal.lat,\n        centerLon: signal.lon,\n        timeRange: { start: signal.timestamp, end: signal.timestamp }\n      };\n      \n      unassigned.delete(signal);\n      \n      // Find related signals\n      unassigned.forEach(other => {\n        if (this.areSignalsRelated(signal, other)) {\n          group.signals.push(other);\n          unassigned.delete(other);\n          \n          // Update group center and time range\n          group.centerLat = (group.centerLat * (group.signals.length - 1) + other.lat) / group.signals.length;\n          group.centerLon = (group.centerLon * (group.signals.length - 1) + other.lon) / group.signals.length;\n          group.timeRange.start = Math.min(group.timeRange.start, other.timestamp);\n          group.timeRange.end = Math.max(group.timeRange.end, other.timestamp);\n        }\n      });\n      \n      groups.push(group);\n    });\n    \n    // Second pass: Merge groups that likely belong to the same drone\n    return this.mergeRelatedGroups(groups);\n  }\n  \n  /**\n   * Check if two signals are likely from the same drone\n   */\n  private areSignalsRelated(s1: SignalMarker, s2: SignalMarker): boolean {\n    // Spatial proximity (within 100m)\n    const distance = this.calculateDistance(s1.lat, s1.lon, s2.lat, s2.lon);\n    if (distance > 100) return false;\n    \n    // Temporal proximity (within 5 seconds)\n    const timeDiff = Math.abs(s1.timestamp - s2.timestamp);\n    if (timeDiff > 5000) return false;\n    \n    // Check if frequencies match known drone patterns\n    const pattern = this.matchDronePattern(s1.frequency, s2.frequency);\n    if (pattern) return true;\n    \n    // Similar signal strength (within 10 dB)\n    const powerDiff = Math.abs(s1.power - s2.power);\n    if (powerDiff > 10) return false;\n    \n    return true;\n  }\n  \n  /**\n   * Match frequencies to known drone patterns\n   */\n  private matchDronePattern(freq1: number, freq2: number): string | null {\n    for (const [manufacturer, pattern] of Object.entries(DRONE_PATTERNS)) {\n      const inControl = pattern.control.some(f => \n        (typeof f === 'number' && Math.abs(freq1 - f) < 50) ||\n        (Array.isArray(f) && freq1 >= f[0] && freq1 <= f[1])\n      );\n      \n      const inVideo = pattern.video.some(f => \n        (typeof f === 'number' && Math.abs(freq2 - f) < 50) ||\n        (Array.isArray(f) && freq2 >= f[0] && freq2 <= f[1])\n      );\n      \n      if ((inControl && inVideo) || (inVideo && inControl)) {\n        return manufacturer;\n      }\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Merge signal groups that belong to the same drone\n   */\n  private mergeRelatedGroups(groups: SignalGroup[]): SignalGroup[] {\n    const merged: SignalGroup[] = [];\n    const used = new Set<number>();\n    \n    groups.forEach((group, i) => {\n      if (used.has(i)) return;\n      \n      const mergedGroup = { ...group };\n      used.add(i);\n      \n      // Check other groups for merging\n      groups.forEach((other, j) => {\n        if (i === j || used.has(j)) return;\n        \n        // Check if groups should be merged\n        const distance = this.calculateDistance(\n          group.centerLat, group.centerLon,\n          other.centerLat, other.centerLon\n        );\n        \n        const timeOverlap = \n          (group.timeRange.start <= other.timeRange.end) &&\n          (other.timeRange.start <= group.timeRange.end);\n        \n        if (distance < 200 && timeOverlap) {\n          // Merge groups\n          mergedGroup.signals.push(...other.signals);\n          used.add(j);\n          \n          // Recalculate center\n          const totalSignals = mergedGroup.signals.length;\n          mergedGroup.centerLat = mergedGroup.signals.reduce((sum, s) => sum + s.lat, 0) / totalSignals;\n          mergedGroup.centerLon = mergedGroup.signals.reduce((sum, s) => sum + s.lon, 0) / totalSignals;\n          \n          // Update time range\n          mergedGroup.timeRange.start = Math.min(mergedGroup.timeRange.start, other.timeRange.start);\n          mergedGroup.timeRange.end = Math.max(mergedGroup.timeRange.end, other.timeRange.end);\n        }\n      });\n      \n      merged.push(mergedGroup);\n    });\n    \n    return merged;\n  }\n  \n  /**\n   * Update or create drone signature from signal group\n   */\n  private updateDroneSignature(group: SignalGroup): void {\n    // Check if this group matches an existing drone\n    let droneId: string | null = null;\n    \n    for (const signal of group.signals) {\n      const existingDroneId = this.signalAssociations.get(signal.id);\n      if (existingDroneId && this.activeDrones.has(existingDroneId)) {\n        droneId = existingDroneId;\n        break;\n      }\n    }\n    \n    if (droneId) {\n      // Update existing drone\n      const drone = this.activeDrones.get(droneId)!;\n      this.updateExistingDrone(drone, group);\n    } else {\n      // Create new drone signature\n      const newDrone = this.createDroneSignature(group);\n      this.activeDrones.set(newDrone.id, newDrone);\n      \n      // Associate signals with drone\n      group.signals.forEach(signal => {\n        this.signalAssociations.set(signal.id, newDrone.id);\n      });\n    }\n  }\n  \n  /**\n   * Create new drone signature from signal group\n   */\n  private createDroneSignature(group: SignalGroup): DroneSignature {\n    const characteristics = this.analyzeDroneCharacteristics(group.signals);\n    \n    return {\n      id: `drone_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      type: this.determineDroneType(group.signals),\n      confidence: this.calculateConfidence(group.signals),\n      signals: group.signals,\n      trajectory: this.calculateTrajectory(group.signals),\n      characteristics,\n      firstSeen: group.timeRange.start,\n      lastSeen: group.timeRange.end,\n      status: 'active'\n    };\n  }\n  \n  /**\n   * Update existing drone with new signals\n   */\n  private updateExistingDrone(drone: DroneSignature, group: SignalGroup): void {\n    // Add new signals\n    drone.signals.push(...group.signals);\n    \n    // Keep only recent signals (last 2 minutes)\n    const cutoff = Date.now() - 120000;\n    drone.signals = drone.signals.filter(s => s.timestamp > cutoff);\n    \n    // Update timestamps\n    drone.lastSeen = group.timeRange.end;\n    \n    // Recalculate confidence\n    drone.confidence = this.calculateConfidence(drone.signals);\n    \n    // Update trajectory\n    if (drone.trajectory) {\n      const newPoints = group.signals.map(s => ({\n        lat: s.lat,\n        lon: s.lon,\n        timestamp: s.timestamp\n      }));\n      drone.trajectory.points.push(...newPoints);\n      \n      // Recalculate trajectory metrics\n      this.updateTrajectoryMetrics(drone.trajectory);\n    }\n    \n    // Update associations\n    group.signals.forEach(signal => {\n      this.signalAssociations.set(signal.id, drone.id);\n    });\n  }\n  \n  /**\n   * Determine drone type based on signal characteristics\n   */\n  private determineDroneType(signals: SignalMarker[]): DroneSignature['type'] {\n    const frequencies = signals.map(s => s.frequency);\n    const uniqueFreqs = new Set(frequencies);\n    \n    // Check for video frequencies (typically 1.2, 2.4, or 5.8 GHz)\n    const hasVideo = Array.from(uniqueFreqs).some(f => \n      (f >= 1200 && f <= 1300) ||\n      (f >= 2400 && f <= 2500) ||\n      (f >= 5725 && f <= 5875)\n    );\n    \n    // Check for control frequencies\n    const hasControl = Array.from(uniqueFreqs).some(f =>\n      (f >= 2400 && f <= 2483) ||\n      (f >= 433 && f <= 435) ||\n      (f >= 900 && f <= 928)\n    );\n    \n    // Check for telemetry (often on 433 or 915 MHz)\n    const hasTelemetry = Array.from(uniqueFreqs).some(f =>\n      (f >= 433 && f <= 435) ||\n      (f >= 902 && f <= 928)\n    );\n    \n    if (hasVideo) return 'video';\n    if (hasControl) return 'controller';\n    if (hasTelemetry) return 'telemetry';\n    return 'unknown';\n  }\n  \n  /**\n   * Calculate detection confidence\n   */\n  private calculateConfidence(signals: SignalMarker[]): number {\n    let confidence = 0;\n    \n    // More signals = higher confidence\n    confidence += Math.min(signals.length / 20, 0.3);\n    \n    // Consistent signal strength\n    const powers = signals.map(s => s.power);\n    const avgPower = powers.reduce((a, b) => a + b, 0) / powers.length;\n    const variance = powers.reduce((sum, p) => sum + Math.pow(p - avgPower, 2), 0) / powers.length;\n    const stdDev = Math.sqrt(variance);\n    confidence += stdDev < 5 ? 0.2 : 0;\n    \n    // Frequency pattern matches known drones\n    const freqs = signals.map(s => s.frequency);\n    const matchesPattern = this.matchesKnownPattern(freqs);\n    confidence += matchesPattern ? 0.3 : 0;\n    \n    // Movement pattern consistency\n    if (signals.length > 5) {\n      const trajectory = this.calculateTrajectory(signals);\n      if (trajectory && trajectory.speed > 0 && trajectory.speed < 50) {\n        confidence += 0.2;\n      }\n    }\n    \n    return Math.min(confidence, 1);\n  }\n  \n  /**\n   * Analyze drone characteristics from signals\n   */\n  private analyzeDroneCharacteristics(signals: SignalMarker[]): DroneCharacteristics {\n    const frequencies = signals.map(s => s.frequency);\n    const powers = signals.map(s => s.power);\n    const avgPower = powers.reduce((a, b) => a + b, 0) / powers.length;\n    \n    // Try to identify manufacturer\n    let manufacturer: string | undefined;\n    let model: string | undefined;\n    \n    for (const [mfr, pattern] of Object.entries(DRONE_PATTERNS)) {\n      const matchesControl = frequencies.some(f => \n        pattern.control.some(range => \n          Array.isArray(range) ? (f >= range[0] && f <= range[1]) : Math.abs(f - range) < 50\n        )\n      );\n      \n      const matchesPower = avgPower >= pattern.powerRange[0] && avgPower <= pattern.powerRange[1];\n      \n      if (matchesControl && matchesPower) {\n        manufacturer = mfr;\n        break;\n      }\n    }\n    \n    // Determine power profile\n    let powerProfile: DroneCharacteristics['powerProfile'] = 'commercial';\n    if (avgPower > -40) powerProfile = 'professional';\n    if (avgPower > -30) powerProfile = 'military';\n    if (!manufacturer) powerProfile = 'custom';\n    \n    // Analyze signal pattern\n    let signalPattern: DroneCharacteristics['signalPattern'] = 'continuous';\n    \n    // Check for frequency hopping\n    const uniqueFreqs = new Set(frequencies);\n    if (uniqueFreqs.size > 5 && signals.length > 10) {\n      signalPattern = 'frequency_hopping';\n    } else {\n      // Check for burst pattern\n      const timeDiffs = [];\n      for (let i = 1; i < signals.length; i++) {\n        timeDiffs.push(signals[i].timestamp - signals[i-1].timestamp);\n      }\n      const avgTimeDiff = timeDiffs.reduce((a, b) => a + b, 0) / timeDiffs.length;\n      if (avgTimeDiff > 100) signalPattern = 'burst';\n    }\n    \n    return {\n      manufacturer,\n      model,\n      controlFreq: frequencies.find(f => f >= 2400 && f <= 2500),\n      videoFreq: frequencies.find(f => f >= 5725 && f <= 5875),\n      signalPattern,\n      powerProfile\n    };\n  }\n  \n  /**\n   * Calculate drone trajectory from signals\n   */\n  private calculateTrajectory(signals: SignalMarker[]): TrajectoryData | undefined {\n    if (signals.length < 2) return undefined;\n    \n    // Sort by timestamp\n    const sorted = [...signals].sort((a, b) => a.timestamp - b.timestamp);\n    \n    const points = sorted.map(s => ({\n      lat: s.lat,\n      lon: s.lon,\n      timestamp: s.timestamp\n    }));\n    \n    // Calculate speed and heading\n    const lastIdx = points.length - 1;\n    const distance = this.calculateDistance(\n      points[0].lat, points[0].lon,\n      points[lastIdx].lat, points[lastIdx].lon\n    );\n    \n    const timeDelta = (points[lastIdx].timestamp - points[0].timestamp) / 1000;\n    const speed = timeDelta > 0 ? distance / timeDelta : 0;\n    \n    const heading = this.calculateHeading(\n      points[lastIdx - 1]?.lat || points[0].lat,\n      points[lastIdx - 1]?.lon || points[0].lon,\n      points[lastIdx].lat,\n      points[lastIdx].lon\n    );\n    \n    return {\n      points,\n      speed,\n      heading,\n      predictedPath: this.predictPath(points, speed, heading)\n    };\n  }\n  \n  /**\n   * Update trajectory metrics\n   */\n  private updateTrajectoryMetrics(trajectory: TrajectoryData): void {\n    if (trajectory.points.length < 2) return;\n    \n    // Keep only recent points (last 30 seconds)\n    const cutoff = Date.now() - 30000;\n    trajectory.points = trajectory.points.filter(p => p.timestamp > cutoff);\n    \n    // Recalculate speed and heading from recent points\n    const recent = trajectory.points.slice(-5); // Last 5 points\n    if (recent.length >= 2) {\n      const distances: number[] = [];\n      const headings: number[] = [];\n      \n      for (let i = 1; i < recent.length; i++) {\n        const dist = this.calculateDistance(\n          recent[i-1].lat, recent[i-1].lon,\n          recent[i].lat, recent[i].lon\n        );\n        const time = (recent[i].timestamp - recent[i-1].timestamp) / 1000;\n        if (time > 0) distances.push(dist / time);\n        \n        const hdg = this.calculateHeading(\n          recent[i-1].lat, recent[i-1].lon,\n          recent[i].lat, recent[i].lon\n        );\n        headings.push(hdg);\n      }\n      \n      // Average speed and heading\n      trajectory.speed = distances.length > 0 ? \n        distances.reduce((a, b) => a + b, 0) / distances.length : 0;\n      \n      trajectory.heading = headings.length > 0 ?\n        this.averageHeading(headings) : 0;\n      \n      // Update predicted path\n      trajectory.predictedPath = this.predictPath(\n        trajectory.points,\n        trajectory.speed,\n        trajectory.heading\n      );\n    }\n  }\n  \n  /**\n   * Predict future path based on current trajectory\n   */\n  private predictPath(\n    points: Array<{ lat: number; lon: number; timestamp: number }>,\n    speed: number,\n    heading: number\n  ): Array<{ lat: number; lon: number; timestamp: number }> {\n    if (points.length === 0 || speed === 0) return [];\n    \n    const lastPoint = points[points.length - 1];\n    const predicted: Array<{ lat: number; lon: number; timestamp: number }> = [];\n    \n    // Predict next 30 seconds (every 5 seconds)\n    for (let i = 1; i <= 6; i++) {\n      const futureTime = lastPoint.timestamp + (i * 5000);\n      const distance = speed * (i * 5); // meters\n      \n      // Calculate new position\n      const headingRad = heading * Math.PI / 180;\n      const R = 6371e3; // Earth's radius\n      const lat1 = lastPoint.lat * Math.PI / 180;\n      const lon1 = lastPoint.lon * Math.PI / 180;\n      \n      const lat2 = Math.asin(\n        Math.sin(lat1) * Math.cos(distance / R) +\n        Math.cos(lat1) * Math.sin(distance / R) * Math.cos(headingRad)\n      );\n      \n      const lon2 = lon1 + Math.atan2(\n        Math.sin(headingRad) * Math.sin(distance / R) * Math.cos(lat1),\n        Math.cos(distance / R) - Math.sin(lat1) * Math.sin(lat2)\n      );\n      \n      predicted.push({\n        lat: lat2 * 180 / Math.PI,\n        lon: lon2 * 180 / Math.PI,\n        timestamp: futureTime\n      });\n    }\n    \n    return predicted;\n  }\n  \n  /**\n   * Clean up inactive drones\n   */\n  private cleanupInactiveDrones(): void {\n    const inactiveTimeout = 30000; // 30 seconds\n    const now = Date.now();\n    \n    this.activeDrones.forEach((drone, id) => {\n      if (now - drone.lastSeen > inactiveTimeout) {\n        drone.status = 'lost';\n        \n        // Move to history\n        const history = this.detectionHistory.get(id) || [];\n        history.push(drone);\n        this.detectionHistory.set(id, history);\n        \n        // Remove from active\n        this.activeDrones.delete(id);\n        \n        // Clean up associations\n        drone.signals.forEach(signal => {\n          this.signalAssociations.delete(signal.id);\n        });\n      }\n    });\n  }\n  \n  /**\n   * Update all drone trajectories\n   */\n  private updateTrajectories(): void {\n    this.activeDrones.forEach(drone => {\n      if (drone.trajectory) {\n        this.updateTrajectoryMetrics(drone.trajectory);\n      }\n    });\n  }\n  \n  /**\n   * Generate alerts for significant drone events\n   */\n  private generateAlerts(): DroneAlert[] {\n    const alerts: DroneAlert[] = [];\n    \n    this.activeDrones.forEach(drone => {\n      // New drone detected\n      if (Date.now() - drone.firstSeen < 5000) {\n        alerts.push({\n          type: 'new_drone',\n          severity: 'medium',\n          drone,\n          message: `New drone detected: ${drone.characteristics.manufacturer || 'Unknown'} at ${drone.confidence * 100}% confidence`,\n          timestamp: Date.now()\n        });\n      }\n      \n      // High-speed drone\n      if (drone.trajectory && drone.trajectory.speed > 20) {\n        alerts.push({\n          type: 'high_speed',\n          severity: 'high',\n          drone,\n          message: `Drone moving at high speed: ${drone.trajectory.speed.toFixed(1)} m/s`,\n          timestamp: Date.now()\n        });\n      }\n      \n      // Military/professional drone\n      if (drone.characteristics.powerProfile === 'military' || \n          drone.characteristics.powerProfile === 'professional') {\n        alerts.push({\n          type: 'professional_drone',\n          severity: 'high',\n          drone,\n          message: `${drone.characteristics.powerProfile} drone detected`,\n          timestamp: Date.now()\n        });\n      }\n      \n      // Frequency hopping (potential security concern)\n      if (drone.characteristics.signalPattern === 'frequency_hopping') {\n        alerts.push({\n          type: 'frequency_hopping',\n          severity: 'medium',\n          drone,\n          message: 'Drone using frequency hopping - possible encrypted communications',\n          timestamp: Date.now()\n        });\n      }\n    });\n    \n    return alerts;\n  }\n  \n  /**\n   * Generate detection statistics\n   */\n  private generateStatistics(): DroneStatistics {\n    const stats: DroneStatistics = {\n      totalActive: this.activeDrones.size,\n      byType: new Map(),\n      byManufacturer: new Map(),\n      avgConfidence: 0,\n      detectionRate: 0\n    };\n    \n    let totalConfidence = 0;\n    \n    this.activeDrones.forEach(drone => {\n      // By type\n      stats.byType.set(drone.type, (stats.byType.get(drone.type) || 0) + 1);\n      \n      // By manufacturer\n      const mfr = drone.characteristics.manufacturer || 'Unknown';\n      stats.byManufacturer.set(mfr, (stats.byManufacturer.get(mfr) || 0) + 1);\n      \n      totalConfidence += drone.confidence;\n    });\n    \n    stats.avgConfidence = this.activeDrones.size > 0 ? \n      totalConfidence / this.activeDrones.size : 0;\n    \n    // Calculate detection rate (detections per minute)\n    const historyCount = Array.from(this.detectionHistory.values())\n      .reduce((sum, history) => sum + history.length, 0);\n    stats.detectionRate = (this.activeDrones.size + historyCount) / 60; // Rough estimate\n    \n    return stats;\n  }\n  \n  /**\n   * Helper methods\n   */\n  \n  private calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n    const R = 6371e3;\n    const φ1 = lat1 * Math.PI / 180;\n    const φ2 = lat2 * Math.PI / 180;\n    const Δφ = (lat2 - lat1) * Math.PI / 180;\n    const Δλ = (lon2 - lon1) * Math.PI / 180;\n    \n    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +\n              Math.cos(φ1) * Math.cos(φ2) *\n              Math.sin(Δλ/2) * Math.sin(Δλ/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n    \n    return R * c;\n  }\n  \n  private calculateHeading(lat1: number, lon1: number, lat2: number, lon2: number): number {\n    const dLon = (lon2 - lon1) * Math.PI / 180;\n    const lat1Rad = lat1 * Math.PI / 180;\n    const lat2Rad = lat2 * Math.PI / 180;\n    \n    const y = Math.sin(dLon) * Math.cos(lat2Rad);\n    const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) -\n              Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);\n    \n    const heading = Math.atan2(y, x) * 180 / Math.PI;\n    return (heading + 360) % 360;\n  }\n  \n  private averageHeading(headings: number[]): number {\n    if (headings.length === 0) return 0;\n    \n    // Convert to unit vectors, average, then convert back\n    let x = 0, y = 0;\n    headings.forEach(h => {\n      const rad = h * Math.PI / 180;\n      x += Math.cos(rad);\n      y += Math.sin(rad);\n    });\n    \n    x /= headings.length;\n    y /= headings.length;\n    \n    const avg = Math.atan2(y, x) * 180 / Math.PI;\n    return (avg + 360) % 360;\n  }\n  \n  private matchesKnownPattern(frequencies: number[]): boolean {\n    for (const pattern of Object.values(DRONE_PATTERNS)) {\n      const matchesControl = frequencies.some(f => \n        pattern.control.some(range => \n          Array.isArray(range) ? (f >= range[0] && f <= range[1]) : Math.abs(f - range) < 50\n        )\n      );\n      \n      const matchesVideo = frequencies.some(f => \n        pattern.video.some(range => \n          Array.isArray(range) ? (f >= range[0] && f <= range[1]) : Math.abs(f - range) < 50\n        )\n      );\n      \n      if (matchesControl || matchesVideo) return true;\n    }\n    \n    return false;\n  }\n}\n\n// Type definitions\n\ninterface SignalGroup {\n  id: string;\n  signals: SignalMarker[];\n  centerLat: number;\n  centerLon: number;\n  timeRange: { start: number; end: number };\n}\n\nexport interface DroneDetectionResult {\n  activeDrones: DroneSignature[];\n  totalSignals: number;\n  filteredSignals: SignalMarker[];\n  alerts: DroneAlert[];\n  statistics: DroneStatistics;\n}\n\nexport interface DroneAlert {\n  type: 'new_drone' | 'high_speed' | 'professional_drone' | 'frequency_hopping' | 'lost_drone';\n  severity: 'low' | 'medium' | 'high';\n  drone: DroneSignature;\n  message: string;\n  timestamp: number;\n}\n\nexport interface DroneStatistics {\n  totalActive: number;\n  byType: Map<string, number>;\n  byManufacturer: Map<string, number>;\n  avgConfidence: number;\n  detectionRate: number; // per minute\n}\n\n// Export singleton instance\nexport const droneDetector = new DroneDetectionService();",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/map/gridProcessor.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 79,
				"column": 15,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 79,
				"endColumn": 60
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
				"line": 83,
				"column": 54,
				"nodeType": "Identifier",
				"messageId": "unsafeArgument",
				"endLine": 83,
				"endColumn": 63
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 85,
				"column": 24,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 85,
				"endColumn": 29
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
				"line": 86,
				"column": 42,
				"nodeType": "Identifier",
				"messageId": "unsafeArgument",
				"endLine": 86,
				"endColumn": 51
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
				"line": 92,
				"column": 52,
				"nodeType": "Identifier",
				"messageId": "unsafeArgument",
				"endLine": 92,
				"endColumn": 61
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
				"line": 95,
				"column": 40,
				"nodeType": "Identifier",
				"messageId": "unsafeArgument",
				"endLine": 95,
				"endColumn": 49
			}
		],
		"suppressedMessages": [],
		"errorCount": 6,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "/**\n * Grid processor service that interfaces with the WebWorker\n */\n\nexport interface GridSignal {\n  lat: number;\n  lon: number;\n  power: number;\n  freq: number;\n  timestamp: number;\n}\n\nexport interface GridBounds {\n  minLat: number;\n  maxLat: number;\n  minLon: number;\n  maxLon: number;\n}\n\nexport interface FrequencyInfo {\n  freq: number;\n  power: number;\n  band: string;\n  count: number;\n}\n\nexport interface GridCell {\n  key: string;\n  bounds: GridBounds;\n  stats: {\n    count: number;\n    avgPower: number;\n    maxPower: number;\n    minPower: number;\n    aggregatedPower: number;\n    stdDev: number;\n    density: number;\n    densityFactor: number;\n    dominantBand: string;\n    freqBands: Record<string, number>;\n    bandCategories: Record<string, number>;\n    strongestFreq: number;\n    strongestFreqPower: number;\n    strongestByCategory: Record<string, FrequencyInfo>;\n    topFrequencies: FrequencyInfo[];\n    timeRange: {\n      start: number;\n      end: number;\n    };\n    confidenceFactor: number;\n    temporalSpanMinutes: number;\n  };\n}\n\nexport interface GridProcessResult {\n  cells: GridCell[];\n  totalSignals: number;\n  totalCells: number;\n  processingTime: number;\n  gridSize: number;\n}\n\nexport class GridProcessor {\n  private worker: Worker | null = null;\n  private pendingCallbacks = new Map<string, (result: GridProcessResult | { error: string }) => void>();\n  private requestId = 0;\n\n  constructor() {\n    if (typeof Worker !== 'undefined') {\n      this.initWorker();\n    }\n  }\n\n  private initWorker() {\n    try {\n      this.worker = new Worker('/workers/gridProcessor.js');\n      \n      this.worker.addEventListener('message', (event) => {\n        const { type, data, error, requestId } = event.data;\n        \n        if (type === 'error') {\n          console.error('Grid processor error:', error);\n          const callback = this.pendingCallbacks.get(requestId);\n          if (callback) {\n            callback({ error });\n            this.pendingCallbacks.delete(requestId);\n          }\n          return;\n        }\n        \n        // Find and execute callback based on requestId\n        const callback = this.pendingCallbacks.get(requestId);\n        if (callback && (type === 'gridProcessed' || type === 'hexGridProcessed' || type === 'statsCalculated')) {\n          callback(data as GridProcessResult);\n          this.pendingCallbacks.delete(requestId);\n        }\n      });\n      \n      this.worker.addEventListener('error', (error) => {\n        console.error('Grid processor worker error:', error);\n      });\n    } catch (error) {\n      console.error('Failed to initialize grid processor worker:', error);\n    }\n  }\n\n  /**\n   * Process signals into grid cells\n   */\n  async processGrid(\n    signals: GridSignal[], \n    gridSize: number, \n    bounds?: GridBounds\n  ): Promise<GridProcessResult> {\n    return new Promise((resolve, reject) => {\n      if (!this.worker) {\n        // Fallback to main thread processing\n        reject(new Error('WebWorker not available'));\n        return;\n      }\n      \n      const id = `grid-${this.requestId++}`;\n      this.pendingCallbacks.set(id, (result) => {\n        if ('error' in result) {\n          reject(new Error(result.error));\n        } else {\n          resolve(result);\n        }\n      });\n      \n      this.worker.postMessage({\n        type: 'processGrid',\n        requestId: id,\n        data: {\n          signals,\n          gridSize,\n          bounds\n        }\n      });\n    });\n  }\n\n  /**\n   * Process signals into hexagonal grid cells\n   */\n  async processHexGrid(\n    signals: GridSignal[], \n    hexSize: number, \n    bounds?: GridBounds\n  ): Promise<GridProcessResult> {\n    return new Promise((resolve, reject) => {\n      if (!this.worker) {\n        reject(new Error('WebWorker not available'));\n        return;\n      }\n      \n      const id = `hex-${this.requestId++}`;\n      this.pendingCallbacks.set(id, (result) => {\n        if ('error' in result) {\n          reject(new Error(result.error));\n        } else {\n          resolve(result);\n        }\n      });\n      \n      this.worker.postMessage({\n        type: 'processHexGrid',\n        requestId: id,\n        data: {\n          signals,\n          hexSize,\n          bounds\n        }\n      });\n    });\n  }\n\n  /**\n   * Calculate overall statistics for signals\n   */\n  async calculateStats(signals: GridSignal[], bounds: GridBounds): Promise<{ totalSignals: number; avgPower: number; maxPower: number; minPower: number; processingTime: number }> {\n    return new Promise((resolve, reject) => {\n      if (!this.worker) {\n        reject(new Error('WebWorker not available'));\n        return;\n      }\n      \n      const id = `stats-${this.requestId++}`;\n      this.pendingCallbacks.set(id, (result) => {\n        if ('error' in result) {\n          reject(new Error(result.error));\n        } else {\n          resolve(result as { totalSignals: number; avgPower: number; maxPower: number; minPower: number; processingTime: number });\n        }\n      });\n      \n      this.worker.postMessage({\n        type: 'calculateStats',\n        requestId: id,\n        data: {\n          signals,\n          bounds\n        }\n      });\n    });\n  }\n\n  /**\n   * Terminate the worker\n   */\n  destroy() {\n    if (this.worker) {\n      this.worker.terminate();\n      this.worker = null;\n    }\n    this.pendingCallbacks.clear();\n  }\n}\n\n// Singleton instance\nlet gridProcessorInstance: GridProcessor | null = null;\n\nexport function getGridProcessor(): GridProcessor {\n  if (!gridProcessorInstance) {\n    gridProcessorInstance = new GridProcessor();\n  }\n  return gridProcessorInstance;\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/map/heatmapService.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/await-thenable",
				"severity": 2,
				"message": "Unexpected `await` of a non-Promise (non-\"Thenable\") value.",
				"line": 87,
				"column": 7,
				"nodeType": "AwaitExpression",
				"messageId": "await",
				"endLine": 87,
				"endColumn": 39,
				"suggestions": [
					{
						"messageId": "removeAwait",
						"fix": { "range": [2596, 2601], "text": "" },
						"desc": "Remove unnecessary `await`."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "/**\n * Dedicated heatmap service for high-performance signal visualization\n * Optimized for real-time drone signal detection\n */\n\nimport type { SignalMarker } from '$lib/stores/map/signals';\nimport { SignalInterpolator, type InterpolationMethod } from './signalInterpolation';\nimport { WebGLHeatmapRenderer } from './webglHeatmapRenderer';\nimport { PerformanceMonitor } from './performanceMonitor';\nimport type { GridCell } from './gridProcessor';\n\nexport interface HeatmapConfig {\n  resolution: number; // Grid resolution in meters\n  interpolationMethod: InterpolationMethod;\n  minOpacity: number;\n  maxOpacity: number;\n  blur: number;\n  radius: number;\n  gradient: Record<number, string>; // Power levels to colors\n  updateInterval: number; // Milliseconds between updates\n  performanceMode: 'quality' | 'balanced' | 'performance';\n}\n\nexport interface HeatmapPoint {\n  lat: number;\n  lon: number;\n  intensity: number; // Normalized 0-1\n  altitude?: number;\n  timestamp: number;\n}\n\nexport interface HeatmapLayer {\n  id: string;\n  name: string;\n  altitudeRange: [number, number]; // [min, max] in meters\n  points: HeatmapPoint[];\n  visible: boolean;\n  opacity: number;\n  config: HeatmapConfig;\n}\n\nexport class HeatmapService {\n  private interpolator: SignalInterpolator;\n  private renderer: WebGLHeatmapRenderer | null = null;\n  private performanceMonitor: PerformanceMonitor;\n  private layers: Map<string, HeatmapLayer> = new Map();\n  private updateTimer: ReturnType<typeof setTimeout> | null = null;\n  private canvas: HTMLCanvasElement | null = null;\n  private lastUpdateTime = 0;\n  private pendingUpdate = false;\n  \n  private defaultConfig: HeatmapConfig = {\n    resolution: 25, // 25m grid\n    interpolationMethod: 'idw',\n    minOpacity: 0.1,\n    maxOpacity: 0.8,\n    blur: 20,\n    radius: 30,\n    gradient: {\n      0.0: '#0000ff', // -100 dBm (very weak)\n      0.2: '#00ffff', // -80 dBm (weak)\n      0.4: '#00ff00', // -70 dBm (fair)\n      0.6: '#ffff00', // -60 dBm (good)\n      0.8: '#ff8800', // -50 dBm (strong)\n      1.0: '#ff0000'  // -40 dBm (very strong)\n    },\n    updateInterval: 100, // 10 FPS minimum\n    performanceMode: 'balanced'\n  };\n\n  constructor() {\n    this.interpolator = new SignalInterpolator();\n    this.performanceMonitor = new PerformanceMonitor();\n    \n    // Initialize default layers\n    this.initializeDefaultLayers();\n  }\n\n  /**\n   * Initialize with a canvas element for WebGL rendering\n   */\n  async initialize(canvas: HTMLCanvasElement): Promise<void> {\n    this.canvas = canvas;\n    \n    try {\n      this.renderer = new WebGLHeatmapRenderer(canvas);\n      await this.renderer.initialize();\n      \n      // Set up performance monitoring\n      this.performanceMonitor.on('performanceWarning', (metrics) => {\n        this.adjustQualitySettings(metrics);\n      });\n      \n      // Heatmap service initialized with WebGL renderer\n    } catch (error) {\n      console.error('Failed to initialize WebGL, falling back to Canvas2D:', error);\n      // Fallback implementation would go here\n    }\n  }\n\n  /**\n   * Initialize default altitude layers\n   */\n  private initializeDefaultLayers(): void {\n    // Ground level (0-100m)\n    this.addLayer({\n      id: 'ground',\n      name: 'Ground Level',\n      altitudeRange: [0, 100],\n      config: { ...this.defaultConfig }\n    });\n\n    // Low altitude (100-400m)\n    this.addLayer({\n      id: 'low',\n      name: 'Low Altitude',\n      altitudeRange: [100, 400],\n      config: { \n        ...this.defaultConfig,\n        gradient: {\n          0.0: '#000080',\n          0.2: '#0080ff',\n          0.4: '#00ff80',\n          0.6: '#ffff00',\n          0.8: '#ff8000',\n          1.0: '#ff0000'\n        }\n      }\n    });\n\n    // High altitude (400m+)\n    this.addLayer({\n      id: 'high',\n      name: 'High Altitude',\n      altitudeRange: [400, 10000],\n      config: { \n        ...this.defaultConfig,\n        gradient: {\n          0.0: '#4b0082',\n          0.2: '#8b00ff',\n          0.4: '#ff00ff',\n          0.6: '#ff0080',\n          0.8: '#ff4040',\n          1.0: '#ff0000'\n        }\n      }\n    });\n  }\n\n  /**\n   * Add a new heatmap layer\n   */\n  addLayer(options: {\n    id: string;\n    name: string;\n    altitudeRange: [number, number];\n    config?: Partial<HeatmapConfig>;\n  }): void {\n    const layer: HeatmapLayer = {\n      id: options.id,\n      name: options.name,\n      altitudeRange: options.altitudeRange,\n      points: [],\n      visible: true,\n      opacity: 1,\n      config: { ...this.defaultConfig, ...options.config }\n    };\n    \n    this.layers.set(options.id, layer);\n  }\n\n  /**\n   * Process aggregated grid cells for optimized heatmap rendering\n   */\n  processGridCells(\n    gridCells: GridCell[],\n    bounds: { minLat: number; maxLat: number; minLon: number; maxLon: number }\n  ): void {\n    const startTime = performance.now();\n\n    // Convert grid cells to heatmap points with enhanced weighting\n    const aggregatedPoints: HeatmapPoint[] = [];\n    \n    gridCells.forEach(cell => {\n      // Only process cells within bounds\n      if (cell.bounds.minLat >= bounds.minLat &&\n          cell.bounds.maxLat <= bounds.maxLat &&\n          cell.bounds.minLon >= bounds.minLon &&\n          cell.bounds.maxLon <= bounds.maxLon) {\n        \n        const centerLat = (cell.bounds.minLat + cell.bounds.maxLat) / 2;\n        const centerLon = (cell.bounds.minLon + cell.bounds.maxLon) / 2;\n        \n        // Use aggregated power normalized to intensity\n        const intensity = this.normalizeSignalPower(cell.stats.aggregatedPower);\n        \n        // Create weighted points based on signal density\n        // Higher density cells get multiple points for better visual representation\n        const pointWeight = Math.min(5, Math.ceil(cell.stats.densityFactor * 5));\n        \n        for (let i = 0; i < pointWeight; i++) {\n          // Add slight jitter for multiple points to avoid exact overlap\n          const jitterLat = (Math.random() - 0.5) * 0.0001;\n          const jitterLon = (Math.random() - 0.5) * 0.0001;\n          \n          aggregatedPoints.push({\n            lat: centerLat + jitterLat,\n            lon: centerLon + jitterLon,\n            intensity: intensity * cell.stats.confidenceFactor, // Weight by confidence\n            timestamp: cell.stats.timeRange.end\n          });\n        }\n      }\n    });\n\n    // Update all layers with aggregated data\n    for (const [_layerId, layer] of this.layers) {\n      if (!layer.visible) continue;\n      \n      // For grid aggregation, we don't filter by altitude\n      // The grid already contains mixed altitude signals\n      layer.points = aggregatedPoints;\n    }\n\n    const processingTime = performance.now() - startTime;\n    this.performanceMonitor.recordMetric('gridProcessingTime', processingTime);\n    this.performanceMonitor.updatePointCount(aggregatedPoints.length);\n\n    // Schedule render update\n    this.scheduleUpdate();\n  }\n\n  /**\n   * Process signals into heatmap points with interpolation\n   */\n  async processSignals(\n    signals: SignalMarker[],\n    bounds: { minLat: number; maxLat: number; minLon: number; maxLon: number }\n  ): Promise<void> {\n    const startTime = performance.now();\n    \n    // Clear existing points\n    this.layers.forEach(layer => {\n      layer.points = [];\n    });\n\n    // Group signals by altitude\n    const signalsByAltitude = this.groupSignalsByAltitude(signals);\n\n    // Process each layer\n    for (const [layerId, layerSignals] of signalsByAltitude) {\n      const layer = this.layers.get(layerId);\n      if (!layer || !layer.visible) continue;\n\n      // Convert signals to heatmap points\n      const points = layerSignals.map(signal => ({\n        lat: signal.lat,\n        lon: signal.lon,\n        intensity: this.normalizeSignalPower(signal.power),\n        altitude: signal.altitude,\n        timestamp: signal.timestamp\n      }));\n\n      // Interpolate points based on configuration\n      if (layer.config.interpolationMethod !== 'none') {\n        const interpolatedPoints = await this.interpolator.interpolate(\n          points,\n          bounds,\n          layer.config.resolution,\n          layer.config.interpolationMethod\n        );\n        layer.points = interpolatedPoints;\n      } else {\n        layer.points = points;\n      }\n    }\n\n    const processingTime = performance.now() - startTime;\n    this.performanceMonitor.recordMetric('interpolationTime', processingTime);\n\n    // Schedule render update\n    this.scheduleUpdate();\n  }\n\n  /**\n   * Group signals by altitude layers\n   */\n  private groupSignalsByAltitude(signals: SignalMarker[]): Map<string, SignalMarker[]> {\n    const grouped = new Map<string, SignalMarker[]>();\n\n    signals.forEach(signal => {\n      const altitude = signal.altitude || 0;\n      \n      // Find appropriate layer\n      for (const [layerId, layer] of this.layers) {\n        const [minAlt, maxAlt] = layer.altitudeRange;\n        if (altitude >= minAlt && altitude < maxAlt) {\n          if (!grouped.has(layerId)) {\n            grouped.set(layerId, []);\n          }\n          grouped.get(layerId)?.push(signal);\n          break;\n        }\n      }\n    });\n\n    return grouped;\n  }\n\n  /**\n   * Normalize signal power to 0-1 intensity\n   */\n  private normalizeSignalPower(power: number): number {\n    // Map -100 to -30 dBm to 0-1\n    const normalized = (power + 100) / 70;\n    return Math.max(0, Math.min(1, normalized));\n  }\n\n  /**\n   * Schedule a render update with throttling\n   */\n  private scheduleUpdate(): void {\n    if (this.pendingUpdate) return;\n\n    const now = Date.now();\n    const timeSinceLastUpdate = now - this.lastUpdateTime;\n    const minInterval = this.getMinUpdateInterval();\n\n    if (timeSinceLastUpdate >= minInterval) {\n      this.update();\n    } else {\n      this.pendingUpdate = true;\n      if (this.updateTimer !== null) clearTimeout(this.updateTimer);\n      \n      this.updateTimer = setTimeout(() => {\n        this.pendingUpdate = false;\n        this.update();\n      }, minInterval - timeSinceLastUpdate);\n    }\n  }\n\n  /**\n   * Get minimum update interval based on performance mode\n   */\n  private getMinUpdateInterval(): number {\n    const baseInterval = this.defaultConfig.updateInterval;\n    \n    switch (this.getCurrentPerformanceMode()) {\n      case 'quality':\n        return baseInterval * 0.5; // 20 FPS max\n      case 'balanced':\n        return baseInterval; // 10 FPS max\n      case 'performance':\n        return baseInterval * 2; // 5 FPS max\n      default:\n        return baseInterval;\n    }\n  }\n\n  /**\n   * Get current performance mode based on metrics\n   */\n  private getCurrentPerformanceMode(): 'quality' | 'balanced' | 'performance' {\n    const metrics = this.performanceMonitor.getMetrics();\n    \n    // Auto-adjust based on frame rate\n    if (metrics.fps < 30) {\n      return 'performance';\n    } else if (metrics.fps < 50) {\n      return 'balanced';\n    } else {\n      return 'quality';\n    }\n  }\n\n  /**\n   * Render the heatmap\n   */\n  private update(): void {\n    if (!this.renderer) return;\n\n    const startTime = performance.now();\n    this.performanceMonitor.startFrame();\n\n    try {\n      // Clear canvas\n      this.renderer.clear();\n\n      // Render each visible layer\n      const visibleLayers = Array.from(this.layers.values())\n        .filter(layer => layer.visible && layer.points.length > 0)\n        .sort((a, b) => a.altitudeRange[0] - b.altitudeRange[0]); // Bottom to top\n\n      visibleLayers.forEach(layer => {\n        this.renderer?.renderLayer(layer);\n      });\n\n      this.lastUpdateTime = Date.now();\n    } catch (error) {\n      console.error('Heatmap render error:', error);\n    }\n\n    const renderTime = performance.now() - startTime;\n    this.performanceMonitor.endFrame();\n    this.performanceMonitor.recordMetric('renderTime', renderTime);\n  }\n\n  /**\n   * Adjust quality settings based on performance\n   */\n  private adjustQualitySettings(metrics: { fps: number }): void {\n    if (metrics.fps < 30) {\n      // Reduce quality for better performance\n      this.layers.forEach(layer => {\n        layer.config.resolution = Math.min(layer.config.resolution * 1.5, 100);\n        layer.config.blur = Math.max(layer.config.blur * 0.8, 10);\n      });\n    } else if (metrics.fps > 50) {\n      // Increase quality if performance allows\n      this.layers.forEach(layer => {\n        layer.config.resolution = Math.max(layer.config.resolution * 0.9, 10);\n        layer.config.blur = Math.min(layer.config.blur * 1.2, 40);\n      });\n    }\n  }\n\n  /**\n   * Set layer visibility\n   */\n  setLayerVisibility(layerId: string, visible: boolean): void {\n    const layer = this.layers.get(layerId);\n    if (layer) {\n      layer.visible = visible;\n      this.scheduleUpdate();\n    }\n  }\n\n  /**\n   * Set layer opacity\n   */\n  setLayerOpacity(layerId: string, opacity: number): void {\n    const layer = this.layers.get(layerId);\n    if (layer) {\n      layer.opacity = Math.max(0, Math.min(1, opacity));\n      this.scheduleUpdate();\n    }\n  }\n\n  /**\n   * Update layer configuration\n   */\n  updateLayerConfig(layerId: string, config: Partial<HeatmapConfig>): void {\n    const layer = this.layers.get(layerId);\n    if (layer) {\n      layer.config = { ...layer.config, ...config };\n      this.scheduleUpdate();\n    }\n  }\n\n  /**\n   * Get all layers\n   */\n  getLayers(): HeatmapLayer[] {\n    return Array.from(this.layers.values());\n  }\n\n  /**\n   * Get performance metrics\n   */\n  getPerformanceMetrics(): { fps: number; renderTime: number; interpolationTime: number; pointCount: number } {\n    return this.performanceMonitor.getMetrics();\n  }\n\n  /**\n   * Destroy the service and clean up resources\n   */\n  destroy(): void {\n    if (this.updateTimer !== null) {\n      clearTimeout(this.updateTimer);\n    }\n    \n    if (this.renderer) {\n      this.renderer.destroy();\n    }\n    \n    this.performanceMonitor.destroy();\n    this.interpolator.destroy();\n    this.layers.clear();\n  }\n}\n\n// Singleton instance\nlet heatmapServiceInstance: HeatmapService | null = null;\n\nexport function getHeatmapService(): HeatmapService {\n  if (!heatmapServiceInstance) {\n    heatmapServiceInstance = new HeatmapService();\n  }\n  return heatmapServiceInstance;\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/map/mapUtils.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/map/networkAnalyzer.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'freq' is assigned a value but never used. Allowed unused vars must match /^_/u.",
				"line": 117,
				"column": 9,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 117,
				"endColumn": 13
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 268,
				"column": 20,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 268,
				"endColumn": 32
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 274,
				"column": 18,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 274,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 298,
				"column": 18,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 298,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 368,
				"column": 22,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 368,
				"endColumn": 48
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 369,
				"column": 22,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 369,
				"endColumn": 48
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 379,
				"column": 9,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 379,
				"endColumn": 32,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [10527, 10528], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 380,
				"column": 9,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 380,
				"endColumn": 32,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [10569, 10570], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 381,
				"column": 9,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 381,
				"endColumn": 32,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [10611, 10612], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 382,
				"column": 9,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 382,
				"endColumn": 32,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [10653, 10654], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 388,
				"column": 20,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 388,
				"endColumn": 47
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 389,
				"column": 20,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 389,
				"endColumn": 47
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 399,
				"column": 7,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 399,
				"endColumn": 31,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [11170, 11171], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 400,
				"column": 7,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 400,
				"endColumn": 31,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [11211, 11212], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 401,
				"column": 7,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 401,
				"endColumn": 31,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [11252, 11253], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 402,
				"column": 7,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 402,
				"endColumn": 31,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [11293, 11294], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 407,
				"column": 21,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 407,
				"endColumn": 40
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 16,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "/**\n * Network relationship analyzer for RF signals\n * Detects connections and relationships between devices\n */\n\nimport type { SignalMarker } from '$lib/stores/map/signals';\n\nexport interface NetworkNode {\n  id: string;\n  signal: SignalMarker;\n  type: 'ap' | 'client' | 'peer' | 'unknown';\n  connections: string[]; // IDs of connected nodes\n  metadata: {\n    ssid?: string;\n    manufacturer?: string;\n    protocol?: string;\n    channel?: number;\n  };\n}\n\nexport interface NetworkEdge {\n  id: string;\n  source: string;\n  target: string;\n  type: 'wifi' | 'bluetooth' | 'direct' | 'inferred';\n  strength: number; // 0-1 normalized\n  metadata: {\n    frequency?: number;\n    distance?: number;\n    lastSeen: number;\n  };\n}\n\nexport interface NetworkGraph {\n  nodes: Map<string, NetworkNode>;\n  edges: Map<string, NetworkEdge>;\n  clusters: NetworkCluster[];\n}\n\nexport interface NetworkCluster {\n  id: string;\n  name: string;\n  type: 'wifi_network' | 'bluetooth_group' | 'device_cluster';\n  nodeIds: string[];\n  center: { lat: number; lon: number };\n  radius: number;\n}\n\n/**\n * Analyze signals to build network relationships\n */\nexport function analyzeNetworkRelationships(signals: SignalMarker[]): NetworkGraph {\n  const nodes = new Map<string, NetworkNode>();\n  const edges = new Map<string, NetworkEdge>();\n  const clusters: NetworkCluster[] = [];\n  \n  // First pass: Create nodes and detect device types\n  signals.forEach(signal => {\n    const node: NetworkNode = {\n      id: signal.id,\n      signal,\n      type: detectNodeType(signal),\n      connections: [],\n      metadata: extractMetadata(signal)\n    };\n    nodes.set(signal.id, node);\n  });\n  \n  // Second pass: Detect relationships\n  const nodeArray = Array.from(nodes.values());\n  \n  for (let i = 0; i < nodeArray.length; i++) {\n    for (let j = i + 1; j < nodeArray.length; j++) {\n      const node1 = nodeArray[i];\n      const node2 = nodeArray[j];\n      \n      const relationship = detectRelationship(node1, node2);\n      if (relationship) {\n        const edge: NetworkEdge = {\n          id: `${node1.id}-${node2.id}`,\n          source: node1.id,\n          target: node2.id,\n          type: relationship.type,\n          strength: relationship.strength,\n          metadata: {\n            frequency: relationship.frequency,\n            distance: calculateDistance(\n              node1.signal.lat,\n              node1.signal.lon,\n              node2.signal.lat,\n              node2.signal.lon\n            ),\n            lastSeen: Math.max(node1.signal.timestamp, node2.signal.timestamp)\n          }\n        };\n        \n        edges.set(edge.id, edge);\n        node1.connections.push(node2.id);\n        node2.connections.push(node1.id);\n      }\n    }\n  }\n  \n  // Third pass: Identify clusters\n  const identifiedClusters = identifyNetworkClusters(nodes, edges);\n  clusters.push(...identifiedClusters);\n  \n  return { nodes, edges, clusters };\n}\n\n/**\n * Detect node type based on signal characteristics\n */\nfunction detectNodeType(signal: SignalMarker): 'ap' | 'client' | 'peer' | 'unknown' {\n  const signalType = signal.metadata?.signalType || '';\n  const power = signal.power;\n  const freq = signal.frequency;\n  \n  // Access points typically have stronger, consistent signals\n  if (signalType.includes('wifi') && power > -60) {\n    return 'ap';\n  }\n  \n  // Clients have weaker signals\n  if (signalType.includes('wifi') && power < -70) {\n    return 'client';\n  }\n  \n  // Bluetooth devices are peers\n  if (signalType === 'bluetooth') {\n    return 'peer';\n  }\n  \n  return 'unknown';\n}\n\n/**\n * Extract metadata from signal\n */\nfunction extractMetadata(signal: SignalMarker): NetworkNode['metadata'] {\n  const metadata: NetworkNode['metadata'] = {};\n  \n  // Extract WiFi channel from frequency\n  if (signal.frequency >= 2412 && signal.frequency <= 2484) {\n    metadata.channel = Math.round((signal.frequency - 2412) / 5) + 1;\n    metadata.protocol = 'wifi_2.4';\n  } else if (signal.frequency >= 5180 && signal.frequency <= 5825) {\n    metadata.protocol = 'wifi_5';\n    // 5GHz channel calculation is more complex\n    metadata.channel = Math.round((signal.frequency - 5180) / 5) + 36;\n  }\n  \n  // TODO: Extract SSID from signal data if available\n  // TODO: Extract manufacturer from MAC address OUI\n  \n  return metadata;\n}\n\n/**\n * Detect relationship between two nodes\n */\nfunction detectRelationship(\n  node1: NetworkNode, \n  node2: NetworkNode\n): { type: NetworkEdge['type']; strength: number; frequency?: number } | null {\n  const signal1 = node1.signal;\n  const signal2 = node2.signal;\n  \n  // Check temporal correlation (signals appear at similar times)\n  const timeDiff = Math.abs(signal1.timestamp - signal2.timestamp);\n  if (timeDiff > 5000) return null; // More than 5 seconds apart\n  \n  // Check spatial proximity\n  const distance = calculateDistance(\n    signal1.lat,\n    signal1.lon,\n    signal2.lat,\n    signal2.lon\n  );\n  \n  if (distance > 100) return null; // More than 100m apart\n  \n  // Check frequency relationships\n  if (node1.metadata.channel && node2.metadata.channel) {\n    if (node1.metadata.channel === node2.metadata.channel) {\n      // Same WiFi channel - likely same network\n      if (node1.type === 'ap' && node2.type === 'client') {\n        return {\n          type: 'wifi',\n          strength: 0.9,\n          frequency: signal1.frequency\n        };\n      }\n      if (node1.type === 'client' && node2.type === 'client') {\n        // Two clients on same channel - possibly same network\n        return {\n          type: 'inferred',\n          strength: 0.5,\n          frequency: signal1.frequency\n        };\n      }\n    }\n  }\n  \n  // Check for Bluetooth relationships\n  if (signal1.metadata?.signalType === 'bluetooth' && signal2.metadata?.signalType === 'bluetooth') {\n    // Bluetooth devices in proximity might be paired\n    if (distance < 10) {\n      return {\n        type: 'bluetooth',\n        strength: 0.7,\n        frequency: 2400\n      };\n    }\n  }\n  \n  // Check for similar signal patterns (might be same device with multiple radios)\n  if (Math.abs(signal1.power - signal2.power) < 5 && distance < 5) {\n    return {\n      type: 'direct',\n      strength: 0.8\n    };\n  }\n  \n  return null;\n}\n\n/**\n * Identify network clusters\n */\nfunction identifyNetworkClusters(\n  nodes: Map<string, NetworkNode>,\n  edges: Map<string, NetworkEdge>\n): NetworkCluster[] {\n  const clusters: NetworkCluster[] = [];\n  const visited = new Set<string>();\n  \n  // Find connected components using DFS\n  nodes.forEach((node, nodeId) => {\n    if (!visited.has(nodeId)) {\n      const cluster = exploreCluster(nodeId, nodes, edges, visited);\n      if (cluster.nodeIds.length > 1) {\n        clusters.push(cluster);\n      }\n    }\n  });\n  \n  return clusters;\n}\n\n/**\n * Explore a cluster using depth-first search\n */\nfunction exploreCluster(\n  startNodeId: string,\n  nodes: Map<string, NetworkNode>,\n  edges: Map<string, NetworkEdge>,\n  visited: Set<string>\n): NetworkCluster {\n  const clusterNodes: string[] = [];\n  const stack = [startNodeId];\n  let latSum = 0;\n  let lonSum = 0;\n  let maxDistance = 0;\n  let clusterType: NetworkCluster['type'] = 'device_cluster';\n  \n  while (stack.length > 0) {\n    const nodeId = stack.pop()!;\n    if (visited.has(nodeId)) continue;\n    \n    visited.add(nodeId);\n    clusterNodes.push(nodeId);\n    \n    const node = nodes.get(nodeId)!;\n    latSum += node.signal.lat;\n    lonSum += node.signal.lon;\n    \n    // Determine cluster type\n    if (node.metadata.protocol?.includes('wifi')) {\n      clusterType = 'wifi_network';\n    } else if (node.metadata.protocol === 'bluetooth' && clusterType !== 'wifi_network') {\n      clusterType = 'bluetooth_group';\n    }\n    \n    // Add connected nodes to stack\n    node.connections.forEach(connectedId => {\n      if (!visited.has(connectedId)) {\n        stack.push(connectedId);\n      }\n    });\n  }\n  \n  const centerLat = latSum / clusterNodes.length;\n  const centerLon = lonSum / clusterNodes.length;\n  \n  // Calculate radius\n  clusterNodes.forEach(nodeId => {\n    const node = nodes.get(nodeId)!;\n    const dist = calculateDistance(\n      centerLat,\n      centerLon,\n      node.signal.lat,\n      node.signal.lon\n    );\n    maxDistance = Math.max(maxDistance, dist);\n  });\n  \n  return {\n    id: `cluster-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n    name: `${clusterType.replace('_', ' ')} (${clusterNodes.length} devices)`,\n    type: clusterType,\n    nodeIds: clusterNodes,\n    center: { lat: centerLat, lon: centerLon },\n    radius: maxDistance\n  };\n}\n\n/**\n * Calculate distance between two points in meters\n */\nfunction calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n  const R = 6371e3;\n  const φ1 = lat1 * Math.PI / 180;\n  const φ2 = lat2 * Math.PI / 180;\n  const Δφ = (lat2 - lat1) * Math.PI / 180;\n  const Δλ = (lon2 - lon1) * Math.PI / 180;\n\n  const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +\n            Math.cos(φ1) * Math.cos(φ2) *\n            Math.sin(Δλ/2) * Math.sin(Δλ/2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\n  return R * c;\n}\n\n/**\n * Calculate force-directed layout positions\n */\nexport function calculateNetworkLayout(\n  graph: NetworkGraph,\n  bounds: { width: number; height: number; centerLat: number; centerLon: number },\n  iterations: number = 100\n): Map<string, { x: number; y: number }> {\n  const positions = new Map<string, { x: number; y: number }>();\n  const forces = new Map<string, { fx: number; fy: number }>();\n  \n  // Initialize positions randomly\n  graph.nodes.forEach((node, nodeId) => {\n    positions.set(nodeId, {\n      x: Math.random() * bounds.width - bounds.width / 2,\n      y: Math.random() * bounds.height - bounds.height / 2\n    });\n    forces.set(nodeId, { fx: 0, fy: 0 });\n  });\n  \n  // Force-directed layout iterations\n  for (let iter = 0; iter < iterations; iter++) {\n    // Reset forces\n    forces.forEach(force => {\n      force.fx = 0;\n      force.fy = 0;\n    });\n    \n    // Apply repulsive forces between all nodes\n    const nodeIds = Array.from(graph.nodes.keys());\n    for (let i = 0; i < nodeIds.length; i++) {\n      for (let j = i + 1; j < nodeIds.length; j++) {\n        const pos1 = positions.get(nodeIds[i])!;\n        const pos2 = positions.get(nodeIds[j])!;\n        \n        const dx = pos2.x - pos1.x;\n        const dy = pos2.y - pos1.y;\n        const dist = Math.sqrt(dx * dx + dy * dy) + 0.01;\n        \n        const repulsion = 1000 / (dist * dist);\n        const fx = (dx / dist) * repulsion;\n        const fy = (dy / dist) * repulsion;\n        \n        forces.get(nodeIds[i])!.fx -= fx;\n        forces.get(nodeIds[i])!.fy -= fy;\n        forces.get(nodeIds[j])!.fx += fx;\n        forces.get(nodeIds[j])!.fy += fy;\n      }\n    }\n    \n    // Apply attractive forces along edges\n    graph.edges.forEach(edge => {\n      const pos1 = positions.get(edge.source)!;\n      const pos2 = positions.get(edge.target)!;\n      \n      const dx = pos2.x - pos1.x;\n      const dy = pos2.y - pos1.y;\n      const dist = Math.sqrt(dx * dx + dy * dy) + 0.01;\n      \n      const attraction = dist * 0.1 * edge.strength;\n      const fx = (dx / dist) * attraction;\n      const fy = (dy / dist) * attraction;\n      \n      forces.get(edge.source)!.fx += fx;\n      forces.get(edge.source)!.fy += fy;\n      forces.get(edge.target)!.fx -= fx;\n      forces.get(edge.target)!.fy -= fy;\n    });\n    \n    // Update positions\n    positions.forEach((pos, nodeId) => {\n      const force = forces.get(nodeId)!;\n      const damping = 0.8;\n      \n      pos.x += force.fx * damping;\n      pos.y += force.fy * damping;\n      \n      // Keep within bounds\n      pos.x = Math.max(-bounds.width / 2, Math.min(bounds.width / 2, pos.x));\n      pos.y = Math.max(-bounds.height / 2, Math.min(bounds.height / 2, pos.y));\n    });\n  }\n  \n  return positions;\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/map/performanceMonitor.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 149,
				"column": 22,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 149,
				"endColumn": 25,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [3648, 3651], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [3648, 3651], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access [name] on an `any` value.",
				"line": 149,
				"column": 27,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 149,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 172,
				"column": 13,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 172,
				"endColumn": 49
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 172,
				"column": 38,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 172,
				"endColumn": 41,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [4099, 4102], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [4099, 4102], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .memory on an `any` value.",
				"line": 172,
				"column": 43,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 172,
				"endColumn": 49
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 173,
				"column": 7,
				"nodeType": "AssignmentExpression",
				"messageId": "anyAssignment",
				"endLine": 173,
				"endColumn": 55
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .usedJSHeapSize on an `any` value.",
				"line": 173,
				"column": 41,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 173,
				"endColumn": 55
			}
		],
		"suppressedMessages": [],
		"errorCount": 5,
		"fatalErrorCount": 0,
		"warningCount": 2,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "/**\n * Performance monitoring for heatmap rendering\n * Tracks FPS, memory usage, and rendering metrics\n */\n\nexport interface PerformanceMetrics {\n  fps: number;\n  frameTime: number;\n  memoryUsage: number;\n  renderTime: number;\n  interpolationTime: number;\n  pointCount: number;\n  layerCount: number;\n  timestamp: number;\n}\n\nexport interface PerformanceThresholds {\n  minFps: number;\n  maxFrameTime: number;\n  maxMemoryUsage: number;\n  maxRenderTime: number;\n}\n\ntype PerformanceCallback = (metrics: PerformanceMetrics) => void;\n\nexport class PerformanceMonitor {\n  private metrics: PerformanceMetrics = {\n    fps: 0,\n    frameTime: 0,\n    memoryUsage: 0,\n    renderTime: 0,\n    interpolationTime: 0,\n    pointCount: 0,\n    layerCount: 0,\n    timestamp: Date.now()\n  };\n\n  private thresholds: PerformanceThresholds = {\n    minFps: 30,\n    maxFrameTime: 33, // ~30 FPS\n    maxMemoryUsage: 100 * 1024 * 1024, // 100MB\n    maxRenderTime: 16 // Target 60 FPS\n  };\n\n  private frameCount = 0;\n  private lastFrameTime = 0;\n  private frameStartTime = 0;\n  private fpsUpdateInterval = 1000; // Update FPS every second\n  private lastFpsUpdate = 0;\n  \n  private callbacks: Map<string, PerformanceCallback> = new Map();\n  private rafId: number | null = null;\n  private monitoring = false;\n\n  // Ring buffers for averaging\n  private frameTimes: number[] = [];\n  private renderTimes: number[] = [];\n  private bufferSize = 60; // Average over 60 frames\n\n  constructor() {\n    this.startMonitoring();\n  }\n\n  /**\n   * Start performance monitoring\n   */\n  startMonitoring(): void {\n    if (this.monitoring) return;\n    \n    this.monitoring = true;\n    this.lastFrameTime = performance.now();\n    this.lastFpsUpdate = performance.now();\n    this.animate();\n  }\n\n  /**\n   * Stop performance monitoring\n   */\n  stopMonitoring(): void {\n    this.monitoring = false;\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n  }\n\n  /**\n   * Animation loop for FPS calculation\n   */\n  private animate = (): void => {\n    if (!this.monitoring) return;\n\n    const now = performance.now();\n    const deltaTime = now - this.lastFrameTime;\n    this.lastFrameTime = now;\n\n    // Update frame time buffer\n    this.frameTimes.push(deltaTime);\n    if (this.frameTimes.length > this.bufferSize) {\n      this.frameTimes.shift();\n    }\n\n    // Calculate average frame time\n    const avgFrameTime = this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;\n    this.metrics.frameTime = avgFrameTime;\n\n    // Update FPS\n    if (now - this.lastFpsUpdate >= this.fpsUpdateInterval) {\n      this.metrics.fps = this.frameCount * (1000 / (now - this.lastFpsUpdate));\n      this.frameCount = 0;\n      this.lastFpsUpdate = now;\n      \n      // Check thresholds and notify\n      this.checkThresholds();\n    }\n\n    this.frameCount++;\n    this.rafId = requestAnimationFrame(this.animate);\n  };\n\n  /**\n   * Mark the start of a frame\n   */\n  startFrame(): void {\n    this.frameStartTime = performance.now();\n  }\n\n  /**\n   * Mark the end of a frame\n   */\n  endFrame(): void {\n    if (this.frameStartTime > 0) {\n      const frameTime = performance.now() - this.frameStartTime;\n      this.renderTimes.push(frameTime);\n      if (this.renderTimes.length > this.bufferSize) {\n        this.renderTimes.shift();\n      }\n      \n      // Update average render time\n      const avgRenderTime = this.renderTimes.reduce((a, b) => a + b, 0) / this.renderTimes.length;\n      this.metrics.renderTime = avgRenderTime;\n    }\n  }\n\n  /**\n   * Record a specific metric\n   */\n  recordMetric(name: keyof PerformanceMetrics, value: number): void {\n    (this.metrics as any)[name] = value;\n  }\n\n  /**\n   * Update point count\n   */\n  updatePointCount(count: number): void {\n    this.metrics.pointCount = count;\n  }\n\n  /**\n   * Update layer count\n   */\n  updateLayerCount(count: number): void {\n    this.metrics.layerCount = count;\n  }\n\n  /**\n   * Get current metrics\n   */\n  getMetrics(): PerformanceMetrics {\n    // Update memory usage if available\n    if ('memory' in performance) {\n      const memory = (performance as any).memory;\n      this.metrics.memoryUsage = memory.usedJSHeapSize;\n    }\n\n    this.metrics.timestamp = Date.now();\n    return { ...this.metrics };\n  }\n\n  /**\n   * Check performance thresholds\n   */\n  private checkThresholds(): void {\n    const warnings: string[] = [];\n\n    if (this.metrics.fps < this.thresholds.minFps && this.metrics.fps > 0) {\n      warnings.push(`Low FPS: ${this.metrics.fps.toFixed(1)}`);\n    }\n\n    if (this.metrics.frameTime > this.thresholds.maxFrameTime) {\n      warnings.push(`High frame time: ${this.metrics.frameTime.toFixed(1)}ms`);\n    }\n\n    if (this.metrics.renderTime > this.thresholds.maxRenderTime) {\n      warnings.push(`High render time: ${this.metrics.renderTime.toFixed(1)}ms`);\n    }\n\n    if (this.metrics.memoryUsage > this.thresholds.maxMemoryUsage) {\n      const memoryMB = (this.metrics.memoryUsage / 1024 / 1024).toFixed(1);\n      warnings.push(`High memory usage: ${memoryMB}MB`);\n    }\n\n    if (warnings.length > 0) {\n      this.notifyCallbacks('performanceWarning', this.metrics);\n    }\n  }\n\n  /**\n   * Register a callback for events\n   */\n  on(event: string, callback: PerformanceCallback): void {\n    this.callbacks.set(event, callback);\n  }\n\n  /**\n   * Remove a callback\n   */\n  off(event: string): void {\n    this.callbacks.delete(event);\n  }\n\n  /**\n   * Notify all callbacks for an event\n   */\n  private notifyCallbacks(event: string, metrics: PerformanceMetrics): void {\n    const callback = this.callbacks.get(event);\n    if (callback) {\n      callback(metrics);\n    }\n  }\n\n  /**\n   * Set performance thresholds\n   */\n  setThresholds(thresholds: Partial<PerformanceThresholds>): void {\n    this.thresholds = { ...this.thresholds, ...thresholds };\n  }\n\n  /**\n   * Get performance report\n   */\n  getReport(): string {\n    const metrics = this.getMetrics();\n    const memoryMB = (metrics.memoryUsage / 1024 / 1024).toFixed(1);\n    \n    return `Performance Report:\n- FPS: ${metrics.fps.toFixed(1)}\n- Frame Time: ${metrics.frameTime.toFixed(1)}ms\n- Render Time: ${metrics.renderTime.toFixed(1)}ms\n- Interpolation Time: ${metrics.interpolationTime.toFixed(1)}ms\n- Memory Usage: ${memoryMB}MB\n- Point Count: ${metrics.pointCount}\n- Layer Count: ${metrics.layerCount}`;\n  }\n\n  /**\n   * Reset metrics\n   */\n  reset(): void {\n    this.frameTimes = [];\n    this.renderTimes = [];\n    this.frameCount = 0;\n    this.metrics = {\n      fps: 0,\n      frameTime: 0,\n      memoryUsage: 0,\n      renderTime: 0,\n      interpolationTime: 0,\n      pointCount: 0,\n      layerCount: 0,\n      timestamp: Date.now()\n    };\n  }\n\n  /**\n   * Destroy monitor and clean up\n   */\n  destroy(): void {\n    this.stopMonitoring();\n    this.callbacks.clear();\n    this.reset();\n  }\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/map/signalClustering.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/map/signalFiltering.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 248,
				"column": 20,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 248,
				"endColumn": 43
			},
			{
				"ruleId": "no-case-declarations",
				"severity": 2,
				"message": "Unexpected lexical declaration in case block.",
				"line": 317,
				"column": 9,
				"nodeType": "VariableDeclaration",
				"messageId": "unexpected",
				"endLine": 317,
				"endColumn": 51,
				"suggestions": [
					{
						"messageId": "addBrackets",
						"fix": {
							"range": [9891, 10018],
							"text": "{ const age = Date.now() - signal.timestamp;\n        score += Math.max(0, 1 - age / 60000); // Decay over 1 minute\n        break; }"
						},
						"desc": "Add {} brackets around the case block."
					}
				]
			},
			{
				"ruleId": "no-case-declarations",
				"severity": 2,
				"message": "Unexpected lexical declaration in case block.",
				"line": 322,
				"column": 9,
				"nodeType": "VariableDeclaration",
				"messageId": "unexpected",
				"endLine": 322,
				"endColumn": 65,
				"suggestions": [
					{
						"messageId": "addBrackets",
						"fix": {
							"range": [10061, 10183],
							"text": "{ const history = this.signalHistory.get(signal.id) || [];\n        score += Math.min(history.length / 10, 1);\n        break; }"
						},
						"desc": "Add {} brackets around the case block."
					}
				]
			},
			{
				"ruleId": "no-case-declarations",
				"severity": 2,
				"message": "Unexpected lexical declaration in case block.",
				"line": 328,
				"column": 9,
				"nodeType": "VariableDeclaration",
				"messageId": "unexpected",
				"endLine": 328,
				"endColumn": 62,
				"suggestions": [
					{
						"messageId": "addBrackets",
						"fix": {
							"range": [10263, 10526],
							"text": "{ const movement = this.movementTracker.get(signal.id);\n        if (movement && movement.speed > 5) score += 2; // Fast movement\n        if (this.isUnusualFrequency(signal.frequency)) score += 1.5;\n        if (this.isPowerAnomaly(signal)) score += 1;\n        break; }"
						},
						"desc": "Add {} brackets around the case block."
					}
				]
			},
			{
				"ruleId": "no-case-declarations",
				"severity": 2,
				"message": "Unexpected lexical declaration in case block.",
				"line": 413,
				"column": 9,
				"nodeType": "VariableDeclaration",
				"messageId": "unexpected",
				"endLine": 413,
				"endColumn": 29,
				"suggestions": [
					{
						"messageId": "addBrackets",
						"fix": {
							"range": [12898, 13300],
							"text": "{ let weightedSum = 0;\n        let weightSum = 0;\n        signals.forEach(s => {\n          const weight = Math.pow(10, s.power / 10); // Convert dBm to linear\n          weightedSum += s.power * weight;\n          weightSum += weight;\n        });\n        cell.stats.avgPower = weightSum > 0 ? weightedSum / weightSum : 0;\n        cell.stats.maxPower = Math.max(...signals.map(s => s.power));\n        break; }"
						},
						"desc": "Add {} brackets around the case block."
					}
				]
			},
			{
				"ruleId": "no-case-declarations",
				"severity": 2,
				"message": "Unexpected lexical declaration in case block.",
				"line": 414,
				"column": 9,
				"nodeType": "VariableDeclaration",
				"messageId": "unexpected",
				"endLine": 414,
				"endColumn": 27,
				"suggestions": [
					{
						"messageId": "addBrackets",
						"fix": {
							"range": [12898, 13300],
							"text": "{ let weightedSum = 0;\n        let weightSum = 0;\n        signals.forEach(s => {\n          const weight = Math.pow(10, s.power / 10); // Convert dBm to linear\n          weightedSum += s.power * weight;\n          weightSum += weight;\n        });\n        cell.stats.avgPower = weightSum > 0 ? weightedSum / weightSum : 0;\n        cell.stats.maxPower = Math.max(...signals.map(s => s.power));\n        break; }"
						},
						"desc": "Add {} brackets around the case block."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 5,
		"fatalErrorCount": 0,
		"warningCount": 1,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "/**\n * Signal Filtering and Noise Reduction Service\n * Strategies to reduce visual noise when dealing with 1000+ signals\n * Optimized for drone surveillance operations\n */\n\nimport type { SignalMarker } from '$lib/stores/map/signals';\n\nexport interface FilteringOptions {\n  // Signal strength filtering\n  minPower?: number; // Minimum signal strength in dBm\n  maxPower?: number; // Maximum signal strength in dBm\n  \n  // Frequency band filtering\n  frequencyBands?: FrequencyBand[];\n  excludeBands?: FrequencyBand[]; // Bands to exclude (e.g., known friendly signals)\n  \n  // Spatial aggregation\n  gridSize?: number; // Grid cell size in meters\n  aggregationMethod?: 'max' | 'avg' | 'density' | 'weighted';\n  \n  // Temporal filtering\n  timeWindow?: number; // Time window in milliseconds\n  minDuration?: number; // Minimum signal duration to display\n  \n  // Signal prioritization\n  maxSignalsPerArea?: number; // Max signals to show per grid cell\n  priorityMode?: 'strongest' | 'newest' | 'persistent' | 'anomalous';\n  \n  // Drone-specific filters\n  droneFrequencies?: boolean; // Focus on known drone frequencies\n  movingSignalsOnly?: boolean; // Show only signals with position changes\n  altitudeFilter?: { min: number; max: number }; // Filter by estimated altitude\n}\n\nexport interface FrequencyBand {\n  name: string;\n  minFreq: number; // MHz\n  maxFreq: number; // MHz\n  priority?: number; // Higher = more important\n}\n\n// Common drone frequency bands\nexport const DRONE_FREQUENCY_BANDS: FrequencyBand[] = [\n  { name: '900MHz ISM', minFreq: 902, maxFreq: 928, priority: 8 },\n  { name: '2.4GHz Control', minFreq: 2400, maxFreq: 2483.5, priority: 10 },\n  { name: '5.8GHz Video', minFreq: 5725, maxFreq: 5875, priority: 9 },\n  { name: '1.2GHz Video', minFreq: 1200, maxFreq: 1300, priority: 7 },\n  { name: '433MHz Control', minFreq: 433, maxFreq: 435, priority: 8 },\n  { name: 'GPS L1', minFreq: 1574, maxFreq: 1576, priority: 6 },\n  { name: 'GPS L2', minFreq: 1226, maxFreq: 1228, priority: 6 },\n];\n\n// Common interference sources to filter out\nexport const INTERFERENCE_BANDS: FrequencyBand[] = [\n  { name: 'FM Radio', minFreq: 88, maxFreq: 108, priority: 1 },\n  { name: 'Cellular', minFreq: 850, maxFreq: 900, priority: 2 },\n  { name: 'WiFi 2.4GHz', minFreq: 2400, maxFreq: 2483.5, priority: 3 },\n  { name: 'WiFi 5GHz', minFreq: 5150, maxFreq: 5850, priority: 3 },\n];\n\nexport class SignalFilterService {\n  private signalHistory = new Map<string, SignalMarker[]>();\n  private gridCache = new Map<string, GridCell>();\n  private movementTracker = new Map<string, MovementData>();\n  \n  constructor(private options: FilteringOptions = {}) {\n    this.setDefaultOptions();\n  }\n  \n  private setDefaultOptions() {\n    this.options = {\n      minPower: -80, // Filter out very weak signals\n      gridSize: 50, // 50m grid cells\n      aggregationMethod: 'weighted',\n      timeWindow: 30000, // 30 seconds\n      maxSignalsPerArea: 10,\n      priorityMode: 'anomalous',\n      droneFrequencies: true,\n      ...this.options\n    };\n  }\n  \n  /**\n   * Update filtering options\n   */\n  setOptions(newOptions: FilteringOptions): void {\n    this.options = {\n      ...this.options,\n      ...newOptions\n    };\n  }\n  \n  /**\n   * Apply all filtering strategies to reduce signal noise\n   */\n  filterSignals(signals: SignalMarker[]): FilteredResult {\n    let filtered = [...signals];\n    const stats = {\n      original: signals.length,\n      afterStrength: 0,\n      afterFrequency: 0,\n      afterSpatial: 0,\n      afterTemporal: 0,\n      final: 0\n    };\n    \n    // 1. Signal strength filtering\n    filtered = this.filterBySignalStrength(filtered);\n    stats.afterStrength = filtered.length;\n    \n    // 2. Frequency band filtering\n    filtered = this.filterByFrequencyBands(filtered);\n    stats.afterFrequency = filtered.length;\n    \n    // 3. Temporal filtering\n    filtered = this.filterByTemporalPatterns(filtered);\n    stats.afterTemporal = filtered.length;\n    \n    // 4. Spatial aggregation and prioritization\n    const aggregated = this.applySpatialAggregation(filtered);\n    stats.afterSpatial = aggregated.signals.length;\n    \n    // 5. Apply priority-based selection\n    const prioritized = this.prioritizeSignals(aggregated.signals);\n    stats.final = prioritized.length;\n    \n    return {\n      signals: prioritized,\n      gridCells: aggregated.gridCells,\n      statistics: stats,\n      anomalies: this.detectAnomalies(prioritized)\n    };\n  }\n  \n  /**\n   * Filter by signal strength threshold\n   */\n  private filterBySignalStrength(signals: SignalMarker[]): SignalMarker[] {\n    const { minPower = -80, maxPower = 0 } = this.options;\n    \n    return signals.filter(signal => \n      signal.power >= minPower && signal.power <= maxPower\n    );\n  }\n  \n  /**\n   * Filter by frequency bands (include/exclude)\n   */\n  private filterByFrequencyBands(signals: SignalMarker[]): SignalMarker[] {\n    const { frequencyBands, excludeBands, droneFrequencies } = this.options;\n    \n    // Use drone frequencies if specified\n    const includeBands = droneFrequencies ? DRONE_FREQUENCY_BANDS : frequencyBands || [];\n    const excludeList = excludeBands || (droneFrequencies ? INTERFERENCE_BANDS : []);\n    \n    return signals.filter(signal => {\n      const freq = signal.frequency;\n      \n      // Check exclusions first\n      const isExcluded = excludeList.some(band => \n        freq >= band.minFreq && freq <= band.maxFreq\n      );\n      if (isExcluded) return false;\n      \n      // If no include bands specified, include all non-excluded\n      if (includeBands.length === 0) return true;\n      \n      // Check if in any include band\n      return includeBands.some(band => \n        freq >= band.minFreq && freq <= band.maxFreq\n      );\n    });\n  }\n  \n  /**\n   * Filter by temporal patterns (duration, persistence)\n   */\n  private filterByTemporalPatterns(signals: SignalMarker[]): SignalMarker[] {\n    const { timeWindow = 30000, minDuration = 0, movingSignalsOnly = false } = this.options;\n    const now = Date.now();\n    \n    // Update signal history\n    signals.forEach(signal => {\n      const history = this.signalHistory.get(signal.id) || [];\n      history.push(signal);\n      \n      // Keep only recent history\n      const recentHistory = history.filter(s => \n        now - s.timestamp <= timeWindow\n      );\n      this.signalHistory.set(signal.id, recentHistory);\n      \n      // Track movement\n      if (recentHistory.length > 1) {\n        const movement = this.calculateMovement(recentHistory);\n        this.movementTracker.set(signal.id, movement);\n      }\n    });\n    \n    return signals.filter(signal => {\n      const history = this.signalHistory.get(signal.id) || [];\n      \n      // Check minimum duration\n      if (history.length > 0) {\n        const duration = now - history[0].timestamp;\n        if (duration < minDuration) return false;\n      }\n      \n      // Check movement requirement\n      if (movingSignalsOnly) {\n        const movement = this.movementTracker.get(signal.id);\n        if (!movement || movement.speed < 0.5) return false; // 0.5 m/s threshold\n      }\n      \n      return true;\n    });\n  }\n  \n  /**\n   * Apply spatial aggregation to reduce visual clutter\n   */\n  private applySpatialAggregation(signals: SignalMarker[]): AggregatedResult {\n    const { gridSize = 50, aggregationMethod = 'weighted' } = this.options;\n    const gridCells = new Map<string, GridCell>();\n    \n    // Group signals by grid cell\n    signals.forEach(signal => {\n      const gridKey = this.getGridKey(signal.lat, signal.lon, gridSize);\n      \n      if (!gridCells.has(gridKey)) {\n        const [gridLat, gridLon] = gridKey.split(',').map(Number);\n        gridCells.set(gridKey, {\n          key: gridKey,\n          lat: gridLat,\n          lon: gridLon,\n          signals: [],\n          stats: {\n            count: 0,\n            avgPower: 0,\n            maxPower: -100,\n            dominantFreq: 0,\n            priority: 0\n          }\n        });\n      }\n      \n      const cell = gridCells.get(gridKey)!;\n      cell.signals.push(signal);\n    });\n    \n    // Calculate cell statistics\n    gridCells.forEach(cell => {\n      this.calculateCellStats(cell, aggregationMethod);\n    });\n    \n    // Select representative signals from each cell\n    const aggregatedSignals: SignalMarker[] = [];\n    gridCells.forEach(cell => {\n      const representatives = this.selectRepresentativeSignals(cell);\n      aggregatedSignals.push(...representatives);\n    });\n    \n    return {\n      signals: aggregatedSignals,\n      gridCells: Array.from(gridCells.values())\n    };\n  }\n  \n  /**\n   * Prioritize signals based on importance for drone surveillance\n   */\n  private prioritizeSignals(signals: SignalMarker[]): SignalMarker[] {\n    const { priorityMode = 'anomalous' } = this.options;\n    \n    // Calculate priority scores\n    const scoredSignals = signals.map(signal => ({\n      signal,\n      score: this.calculatePriorityScore(signal, priorityMode)\n    }));\n    \n    // Sort by priority score\n    scoredSignals.sort((a, b) => b.score - a.score);\n    \n    // Apply global limit if needed\n    const maxSignals = this.options.maxSignalsPerArea ? \n      this.options.maxSignalsPerArea * 100 : // Rough estimate\n      1000; // Hard limit\n    \n    return scoredSignals\n      .slice(0, maxSignals)\n      .map(item => item.signal);\n  }\n  \n  /**\n   * Calculate priority score for a signal\n   */\n  private calculatePriorityScore(signal: SignalMarker, mode: string): number {\n    let score = 0;\n    \n    // Base score from signal strength\n    score += (signal.power + 100) / 100; // Normalize -100 to 0 dBm\n    \n    // Frequency band priority\n    const band = this.getFrequencyBand(signal.frequency);\n    if (band) {\n      score += (band.priority || 5) / 10;\n    }\n    \n    // Mode-specific scoring\n    switch (mode) {\n      case 'strongest':\n        score += signal.power / 50;\n        break;\n        \n      case 'newest':\n        const age = Date.now() - signal.timestamp;\n        score += Math.max(0, 1 - age / 60000); // Decay over 1 minute\n        break;\n        \n      case 'persistent':\n        const history = this.signalHistory.get(signal.id) || [];\n        score += Math.min(history.length / 10, 1);\n        break;\n        \n      case 'anomalous':\n        // Check for unusual patterns\n        const movement = this.movementTracker.get(signal.id);\n        if (movement && movement.speed > 5) score += 2; // Fast movement\n        if (this.isUnusualFrequency(signal.frequency)) score += 1.5;\n        if (this.isPowerAnomaly(signal)) score += 1;\n        break;\n    }\n    \n    return score;\n  }\n  \n  /**\n   * Detect anomalies in filtered signals\n   */\n  private detectAnomalies(signals: SignalMarker[]): Anomaly[] {\n    const anomalies: Anomaly[] = [];\n    \n    signals.forEach(signal => {\n      // Fast moving signals\n      const movement = this.movementTracker.get(signal.id);\n      if (movement && movement.speed > 10) {\n        anomalies.push({\n          type: 'fast_movement',\n          signal,\n          description: `Signal moving at ${movement.speed.toFixed(1)} m/s`,\n          severity: movement.speed > 20 ? 'high' : 'medium'\n        });\n      }\n      \n      // Unusual frequency\n      if (this.isUnusualFrequency(signal.frequency)) {\n        anomalies.push({\n          type: 'unusual_frequency',\n          signal,\n          description: `Uncommon frequency: ${signal.frequency.toFixed(1)} MHz`,\n          severity: 'medium'\n        });\n      }\n      \n      // Power anomaly\n      if (this.isPowerAnomaly(signal)) {\n        anomalies.push({\n          type: 'power_anomaly',\n          signal,\n          description: `Abnormal power level: ${signal.power} dBm`,\n          severity: signal.power > -30 ? 'high' : 'low'\n        });\n      }\n    });\n    \n    return anomalies;\n  }\n  \n  /**\n   * Helper methods\n   */\n  \n  private getGridKey(lat: number, lon: number, gridSize: number): string {\n    const latMetersPerDegree = 111320;\n    const lonMetersPerDegree = 111320 * Math.cos(lat * Math.PI / 180);\n    \n    const gridLat = Math.floor(lat * latMetersPerDegree / gridSize) * gridSize / latMetersPerDegree;\n    const gridLon = Math.floor(lon * lonMetersPerDegree / gridSize) * gridSize / lonMetersPerDegree;\n    \n    return `${gridLat.toFixed(6)},${gridLon.toFixed(6)}`;\n  }\n  \n  private calculateCellStats(cell: GridCell, method: string): void {\n    const signals = cell.signals;\n    if (signals.length === 0) return;\n    \n    cell.stats.count = signals.length;\n    \n    switch (method) {\n      case 'max':\n        cell.stats.maxPower = Math.max(...signals.map(s => s.power));\n        cell.stats.avgPower = cell.stats.maxPower;\n        break;\n        \n      case 'avg':\n        cell.stats.avgPower = signals.reduce((sum, s) => sum + s.power, 0) / signals.length;\n        cell.stats.maxPower = Math.max(...signals.map(s => s.power));\n        break;\n        \n      case 'weighted':\n        // Weight by signal strength\n        let weightedSum = 0;\n        let weightSum = 0;\n        signals.forEach(s => {\n          const weight = Math.pow(10, s.power / 10); // Convert dBm to linear\n          weightedSum += s.power * weight;\n          weightSum += weight;\n        });\n        cell.stats.avgPower = weightSum > 0 ? weightedSum / weightSum : 0;\n        cell.stats.maxPower = Math.max(...signals.map(s => s.power));\n        break;\n        \n      case 'density':\n        cell.stats.avgPower = signals.reduce((sum, s) => sum + s.power, 0) / signals.length;\n        cell.stats.priority = signals.length; // Prioritize dense areas\n        break;\n    }\n    \n    // Find dominant frequency\n    const freqMap = new Map<number, number>();\n    signals.forEach(s => {\n      const freqBin = Math.round(s.frequency / 10) * 10; // 10 MHz bins\n      freqMap.set(freqBin, (freqMap.get(freqBin) || 0) + 1);\n    });\n    \n    let maxCount = 0;\n    freqMap.forEach((count, freq) => {\n      if (count > maxCount) {\n        maxCount = count;\n        cell.stats.dominantFreq = freq;\n      }\n    });\n  }\n  \n  private selectRepresentativeSignals(cell: GridCell): SignalMarker[] {\n    const { maxSignalsPerArea = 10 } = this.options;\n    \n    // Sort signals by power\n    const sorted = [...cell.signals].sort((a, b) => b.power - a.power);\n    \n    // Take top N signals\n    return sorted.slice(0, maxSignalsPerArea);\n  }\n  \n  private calculateMovement(history: SignalMarker[]): MovementData {\n    if (history.length < 2) {\n      return { speed: 0, direction: 0, distance: 0 };\n    }\n    \n    const recent = history[history.length - 1];\n    const previous = history[history.length - 2];\n    \n    const distance = this.calculateDistance(\n      previous.lat, previous.lon,\n      recent.lat, recent.lon\n    );\n    \n    const timeDelta = (recent.timestamp - previous.timestamp) / 1000; // seconds\n    const speed = timeDelta > 0 ? distance / timeDelta : 0;\n    \n    const direction = Math.atan2(\n      recent.lon - previous.lon,\n      recent.lat - previous.lat\n    ) * 180 / Math.PI;\n    \n    return { speed, direction, distance };\n  }\n  \n  private calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n    const R = 6371e3;\n    const φ1 = lat1 * Math.PI / 180;\n    const φ2 = lat2 * Math.PI / 180;\n    const Δφ = (lat2 - lat1) * Math.PI / 180;\n    const Δλ = (lon2 - lon1) * Math.PI / 180;\n    \n    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +\n              Math.cos(φ1) * Math.cos(φ2) *\n              Math.sin(Δλ/2) * Math.sin(Δλ/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n    \n    return R * c;\n  }\n  \n  private getFrequencyBand(frequency: number): FrequencyBand | null {\n    const allBands = [...DRONE_FREQUENCY_BANDS, ...INTERFERENCE_BANDS];\n    return allBands.find(band => \n      frequency >= band.minFreq && frequency <= band.maxFreq\n    ) || null;\n  }\n  \n  private isUnusualFrequency(frequency: number): boolean {\n    const band = this.getFrequencyBand(frequency);\n    return !band || (band.priority || 0) < 3;\n  }\n  \n  private isPowerAnomaly(signal: SignalMarker): boolean {\n    // Very strong signal\n    if (signal.power > -40) return true;\n    \n    // Check against historical average for this frequency\n    const band = this.getFrequencyBand(signal.frequency);\n    if (band) {\n      // These are rough expected ranges\n      const expectedRanges: Record<string, [number, number]> = {\n        '2.4GHz Control': [-70, -40],\n        '5.8GHz Video': [-80, -50],\n        'WiFi 2.4GHz': [-80, -30],\n        'WiFi 5GHz': [-85, -35],\n      };\n      \n      const range = expectedRanges[band.name];\n      if (range) {\n        return signal.power < range[0] || signal.power > range[1];\n      }\n    }\n    \n    return false;\n  }\n}\n\n// Type definitions\n\ninterface GridCell {\n  key: string;\n  lat: number;\n  lon: number;\n  signals: SignalMarker[];\n  stats: {\n    count: number;\n    avgPower: number;\n    maxPower: number;\n    dominantFreq: number;\n    priority: number;\n  };\n}\n\ninterface MovementData {\n  speed: number; // m/s\n  direction: number; // degrees\n  distance: number; // meters\n}\n\ninterface AggregatedResult {\n  signals: SignalMarker[];\n  gridCells: GridCell[];\n}\n\nexport interface FilteredResult {\n  signals: SignalMarker[];\n  gridCells: GridCell[];\n  statistics: {\n    original: number;\n    afterStrength: number;\n    afterFrequency: number;\n    afterSpatial: number;\n    afterTemporal: number;\n    final: number;\n  };\n  anomalies: Anomaly[];\n}\n\nexport interface Anomaly {\n  type: 'fast_movement' | 'unusual_frequency' | 'power_anomaly' | 'frequency_hopping';\n  signal: SignalMarker;\n  description: string;\n  severity: 'low' | 'medium' | 'high';\n}\n\n// Export singleton instance\nexport const signalFilter = new SignalFilterService();",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/map/signalInterpolation.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'error' is defined but never used.",
				"line": 41,
				"column": 16,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 41,
				"endColumn": 21
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .type on an `any` value.",
				"line": 151,
				"column": 24,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 151,
				"endColumn": 28
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type `any` assigned to a parameter of type `InterpolationPoint[] | PromiseLike<InterpolationPoint[]>`.",
				"line": 153,
				"column": 19,
				"nodeType": "MemberExpression",
				"messageId": "unsafeArgument",
				"endLine": 153,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .result on an `any` value.",
				"line": 153,
				"column": 30,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 153,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .type on an `any` value.",
				"line": 154,
				"column": 31,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 154,
				"endColumn": 35
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.",
				"line": 156,
				"column": 28,
				"nodeType": "MemberExpression",
				"messageId": "unsafeArgument",
				"endLine": 156,
				"endColumn": 44
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .error on an `any` value.",
				"line": 156,
				"column": 39,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 156,
				"endColumn": 44
			},
			{
				"ruleId": "@typescript-eslint/require-await",
				"severity": 2,
				"message": "Async method 'interpolateBilinear' has no 'await' expression.",
				"line": 215,
				"column": 3,
				"nodeType": "FunctionExpression",
				"messageId": "missingAwait",
				"endLine": 215,
				"endColumn": 36,
				"suggestions": [
					{
						"messageId": "removeAsync",
						"fix": {
							"range": [6566, 6797],
							"text": "interpolateBilinear(\n    points: InterpolationPoint[],\n    bounds: { minLat: number; maxLat: number; minLon: number; maxLon: number },\n    resolution: number,\n    config: InterpolationConfig\n  ): InterpolationPoint[]"
						},
						"desc": "Remove 'async'."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'config' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 219,
				"column": 5,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 219,
				"endColumn": 11
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'lat' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 299,
				"column": 5,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 299,
				"endColumn": 8
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'lon' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 300,
				"column": 5,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 300,
				"endColumn": 8
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'grid' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 301,
				"column": 5,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 301,
				"endColumn": 9
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'latStep' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 302,
				"column": 5,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 302,
				"endColumn": 12
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'lonStep' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 303,
				"column": 5,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 303,
				"endColumn": 12
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'lat' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 313,
				"column": 31,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 313,
				"endColumn": 34
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'lon' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 313,
				"column": 44,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 313,
				"endColumn": 47
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'corners' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 313,
				"column": 57,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 313,
				"endColumn": 64
			}
		],
		"suppressedMessages": [],
		"errorCount": 17,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "/**\n * Signal interpolation engine for smooth heatmap generation\n * Implements IDW and Kriging interpolation methods\n */\n\nexport type InterpolationMethod = 'none' | 'idw' | 'kriging' | 'bilinear';\n\nexport interface InterpolationPoint {\n  lat: number;\n  lon: number;\n  intensity: number;\n  weight?: number;\n}\n\nexport interface InterpolationConfig {\n  power: number; // IDW power parameter (typically 2)\n  searchRadius: number; // Maximum distance to consider neighbors (meters)\n  minNeighbors: number; // Minimum neighbors for interpolation\n  maxNeighbors: number; // Maximum neighbors to consider\n  smoothing: number; // Smoothing factor (0-1)\n}\n\nexport class SignalInterpolator {\n  private defaultConfig: InterpolationConfig = {\n    power: 2,\n    searchRadius: 100, // 100 meters\n    minNeighbors: 3,\n    maxNeighbors: 12,\n    smoothing: 0.5\n  };\n\n  private cache: Map<string, InterpolationPoint[]> = new Map();\n  private cacheTimeout = 5000; // 5 seconds\n  private worker: Worker | null = null;\n\n  constructor() {\n    // Try to initialize web worker for heavy calculations\n    if (typeof Worker !== 'undefined') {\n      try {\n        this.worker = new Worker('/workers/interpolationWorker.js');\n      } catch (error) {\n        console.warn('Interpolation worker not available, using main thread');\n      }\n    }\n  }\n\n  /**\n   * Interpolate signal points to create a smooth grid\n   */\n  async interpolate(\n    points: InterpolationPoint[],\n    bounds: { minLat: number; maxLat: number; minLon: number; maxLon: number },\n    resolution: number,\n    method: InterpolationMethod = 'idw',\n    config?: Partial<InterpolationConfig>\n  ): Promise<InterpolationPoint[]> {\n    const finalConfig = { ...this.defaultConfig, ...config };\n    \n    // Check cache\n    const cacheKey = this.getCacheKey(points, bounds, resolution, method);\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    let result: InterpolationPoint[];\n\n    switch (method) {\n      case 'none':\n        result = points;\n        break;\n      case 'idw':\n        result = await this.interpolateIDW(points, bounds, resolution, finalConfig);\n        break;\n      case 'kriging':\n        result = await this.interpolateKriging(points, bounds, resolution, finalConfig);\n        break;\n      case 'bilinear':\n        result = await this.interpolateBilinear(points, bounds, resolution, finalConfig);\n        break;\n      default:\n        result = points;\n    }\n\n    // Cache result\n    this.cache.set(cacheKey, result);\n    setTimeout(() => this.cache.delete(cacheKey), this.cacheTimeout);\n\n    return result;\n  }\n\n  /**\n   * Inverse Distance Weighting interpolation\n   */\n  private async interpolateIDW(\n    points: InterpolationPoint[],\n    bounds: { minLat: number; maxLat: number; minLon: number; maxLon: number },\n    resolution: number,\n    config: InterpolationConfig\n  ): Promise<InterpolationPoint[]> {\n    if (this.worker) {\n      // Use worker for parallel processing\n      return this.interpolateIDWWorker(points, bounds, resolution, config);\n    }\n\n    // Main thread fallback\n    const grid: InterpolationPoint[] = [];\n    const latSteps = Math.ceil(this.getDistance(bounds.minLat, bounds.minLon, bounds.maxLat, bounds.minLon) / resolution);\n    const lonSteps = Math.ceil(this.getDistance(bounds.minLat, bounds.minLon, bounds.minLat, bounds.maxLon) / resolution);\n    \n    const latStep = (bounds.maxLat - bounds.minLat) / latSteps;\n    const lonStep = (bounds.maxLon - bounds.minLon) / lonSteps;\n\n    // Build spatial index for efficient neighbor search\n    const spatialIndex = this.buildSpatialIndex(points);\n\n    for (let i = 0; i <= latSteps; i++) {\n      for (let j = 0; j <= lonSteps; j++) {\n        const lat = bounds.minLat + i * latStep;\n        const lon = bounds.minLon + j * lonStep;\n\n        // Find nearby points\n        const neighbors = this.findNeighbors(lat, lon, points, spatialIndex, config);\n        \n        if (neighbors.length >= config.minNeighbors) {\n          const intensity = this.calculateIDW(lat, lon, neighbors, config.power);\n          grid.push({ lat, lon, intensity });\n        }\n      }\n    }\n\n    return grid;\n  }\n\n  /**\n   * Worker-based IDW interpolation\n   */\n  private interpolateIDWWorker(\n    points: InterpolationPoint[],\n    bounds: { minLat: number; maxLat: number; minLon: number; maxLon: number },\n    resolution: number,\n    config: InterpolationConfig\n  ): Promise<InterpolationPoint[]> {\n    return new Promise((resolve, reject) => {\n      if (!this.worker) {\n        reject(new Error('Worker not available'));\n        return;\n      }\n\n      const messageHandler = (event: MessageEvent) => {\n        if (event.data.type === 'idwComplete') {\n          if (this.worker) this.worker.removeEventListener('message', messageHandler);\n          resolve(event.data.result);\n        } else if (event.data.type === 'error') {\n          if (this.worker) this.worker.removeEventListener('message', messageHandler);\n          reject(new Error(event.data.error));\n        }\n      };\n\n      this.worker.addEventListener('message', messageHandler);\n      this.worker.postMessage({\n        type: 'interpolateIDW',\n        points,\n        bounds,\n        resolution,\n        config\n      });\n    });\n  }\n\n  /**\n   * Calculate IDW value for a single point\n   */\n  private calculateIDW(lat: number, lon: number, neighbors: InterpolationPoint[], power: number): number {\n    let weightedSum = 0;\n    let weightSum = 0;\n\n    for (const neighbor of neighbors) {\n      const distance = this.getDistance(lat, lon, neighbor.lat, neighbor.lon);\n      \n      // Avoid division by zero\n      if (distance < 0.0001) {\n        return neighbor.intensity;\n      }\n\n      const weight = Math.pow(1 / distance, power);\n      weightedSum += neighbor.intensity * weight;\n      weightSum += weight;\n    }\n\n    return weightSum > 0 ? weightedSum / weightSum : 0;\n  }\n\n  /**\n   * Kriging interpolation (simplified ordinary kriging)\n   */\n  private async interpolateKriging(\n    points: InterpolationPoint[],\n    bounds: { minLat: number; maxLat: number; minLon: number; maxLon: number },\n    resolution: number,\n    config: InterpolationConfig\n  ): Promise<InterpolationPoint[]> {\n    // For now, fall back to IDW with adjusted parameters\n    // Full kriging implementation would require variogram modeling\n    return this.interpolateIDW(points, bounds, resolution, {\n      ...config,\n      power: 3, // Higher power for kriging-like behavior\n      smoothing: 0.7\n    });\n  }\n\n  /**\n   * Bilinear interpolation for regular grids\n   */\n  private async interpolateBilinear(\n    points: InterpolationPoint[],\n    bounds: { minLat: number; maxLat: number; minLon: number; maxLon: number },\n    resolution: number,\n    config: InterpolationConfig\n  ): Promise<InterpolationPoint[]> {\n    // Create initial sparse grid from points\n    const sparseGrid = this.createSparseGrid(points, bounds, resolution);\n    \n    // Fill in missing values with bilinear interpolation\n    return this.fillBilinear(sparseGrid, bounds, resolution);\n  }\n\n  /**\n   * Create sparse grid from irregular points\n   */\n  private createSparseGrid(\n    points: InterpolationPoint[],\n    bounds: { minLat: number; maxLat: number; minLon: number; maxLon: number },\n    resolution: number\n  ): Map<string, InterpolationPoint> {\n    const grid = new Map<string, InterpolationPoint>();\n    \n    // Snap points to grid\n    points.forEach(point => {\n      const gridLat = this.snapToGrid(point.lat, bounds.minLat, resolution, true);\n      const gridLon = this.snapToGrid(point.lon, bounds.minLon, resolution, false);\n      const key = `${gridLat},${gridLon}`;\n      \n      // Average if multiple points in same cell\n      const existing = grid.get(key);\n      if (existing) {\n        existing.intensity = (existing.intensity + point.intensity) / 2;\n      } else {\n        grid.set(key, { lat: gridLat, lon: gridLon, intensity: point.intensity });\n      }\n    });\n    \n    return grid;\n  }\n\n  /**\n   * Fill sparse grid using bilinear interpolation\n   */\n  private fillBilinear(\n    sparseGrid: Map<string, InterpolationPoint>,\n    bounds: { minLat: number; maxLat: number; minLon: number; maxLon: number },\n    resolution: number\n  ): InterpolationPoint[] {\n    const filled: InterpolationPoint[] = [];\n    const latSteps = Math.ceil(this.getDistance(bounds.minLat, bounds.minLon, bounds.maxLat, bounds.minLon) / resolution);\n    const lonSteps = Math.ceil(this.getDistance(bounds.minLat, bounds.minLon, bounds.minLat, bounds.maxLon) / resolution);\n    \n    const latStep = (bounds.maxLat - bounds.minLat) / latSteps;\n    const lonStep = (bounds.maxLon - bounds.minLon) / lonSteps;\n\n    for (let i = 0; i <= latSteps; i++) {\n      for (let j = 0; j <= lonSteps; j++) {\n        const lat = bounds.minLat + i * latStep;\n        const lon = bounds.minLon + j * lonStep;\n        const key = `${lat},${lon}`;\n        \n        // Check if we have a value\n        const existing = sparseGrid.get(key);\n        if (existing) {\n          filled.push(existing);\n        } else {\n          // Find surrounding points for bilinear interpolation\n          const corners = this.findBilinearCorners(lat, lon, sparseGrid, latStep, lonStep);\n          if (corners) {\n            const intensity = this.bilinearInterpolate(lat, lon, corners);\n            filled.push({ lat, lon, intensity });\n          }\n        }\n      }\n    }\n\n    return filled;\n  }\n\n  /**\n   * Find corner points for bilinear interpolation\n   */\n  private findBilinearCorners(\n    lat: number,\n    lon: number,\n    grid: Map<string, InterpolationPoint>,\n    latStep: number,\n    lonStep: number\n  ): { q11: InterpolationPoint; q12: InterpolationPoint; q21: InterpolationPoint; q22: InterpolationPoint } | null {\n    // Implementation would find the four surrounding grid points\n    // For now, return null to skip interpolation\n    return null;\n  }\n\n  /**\n   * Perform bilinear interpolation\n   */\n  private bilinearInterpolate(lat: number, lon: number, corners: { q11: InterpolationPoint; q12: InterpolationPoint; q21: InterpolationPoint; q22: InterpolationPoint }): number {\n    // Standard bilinear interpolation formula\n    // Q11, Q12, Q21, Q22 are the four corner values\n    // This is a placeholder - full implementation would calculate weights\n    return 0.5;\n  }\n\n  /**\n   * Build spatial index for efficient neighbor search\n   */\n  private buildSpatialIndex(points: InterpolationPoint[]): Map<string, InterpolationPoint[]> {\n    const index = new Map<string, InterpolationPoint[]>();\n    const cellSize = 0.001; // ~100m at equator\n    \n    points.forEach(point => {\n      const cellLat = Math.floor(point.lat / cellSize);\n      const cellLon = Math.floor(point.lon / cellSize);\n      \n      // Add to multiple cells for overlap\n      for (let i = -1; i <= 1; i++) {\n        for (let j = -1; j <= 1; j++) {\n          const key = `${cellLat + i},${cellLon + j}`;\n          if (!index.has(key)) {\n            index.set(key, []);\n          }\n          const cell = index.get(key);\n          if (cell) cell.push(point);\n        }\n      }\n    });\n    \n    return index;\n  }\n\n  /**\n   * Find neighbors efficiently using spatial index\n   */\n  private findNeighbors(\n    lat: number,\n    lon: number,\n    points: InterpolationPoint[],\n    spatialIndex: Map<string, InterpolationPoint[]>,\n    config: InterpolationConfig\n  ): InterpolationPoint[] {\n    const cellSize = 0.001;\n    const cellLat = Math.floor(lat / cellSize);\n    const cellLon = Math.floor(lon / cellSize);\n    const key = `${cellLat},${cellLon}`;\n    \n    const candidates = spatialIndex.get(key) || [];\n    \n    // Calculate distances and filter\n    const neighbors = candidates\n      .map(point => ({\n        point,\n        distance: this.getDistance(lat, lon, point.lat, point.lon)\n      }))\n      .filter(item => item.distance <= config.searchRadius)\n      .sort((a, b) => a.distance - b.distance)\n      .slice(0, config.maxNeighbors)\n      .map(item => item.point);\n    \n    return neighbors;\n  }\n\n  /**\n   * Calculate distance between two points in meters\n   */\n  private getDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n    const R = 6371e3; // Earth's radius in meters\n    const φ1 = lat1 * Math.PI / 180;\n    const φ2 = lat2 * Math.PI / 180;\n    const Δφ = (lat2 - lat1) * Math.PI / 180;\n    const Δλ = (lon2 - lon1) * Math.PI / 180;\n\n    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +\n              Math.cos(φ1) * Math.cos(φ2) *\n              Math.sin(Δλ/2) * Math.sin(Δλ/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\n    return R * c;\n  }\n\n  /**\n   * Snap coordinate to grid\n   */\n  private snapToGrid(coord: number, min: number, resolution: number, isLat: boolean): number {\n    const metersPerDegree = isLat ? 111320 : 111320 * Math.cos(coord * Math.PI / 180);\n    const step = resolution / metersPerDegree;\n    return min + Math.round((coord - min) / step) * step;\n  }\n\n  /**\n   * Generate cache key\n   */\n  private getCacheKey(\n    points: InterpolationPoint[],\n    bounds: { minLat: number; maxLat: number; minLon: number; maxLon: number },\n    resolution: number,\n    method: string\n  ): string {\n    // Simple hash based on parameters\n    const pointsHash = points.length;\n    const boundsHash = `${bounds.minLat},${bounds.maxLat},${bounds.minLon},${bounds.maxLon}`;\n    return `${method}-${resolution}-${boundsHash}-${pointsHash}`;\n  }\n\n  /**\n   * Clear interpolation cache\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Destroy interpolator and clean up resources\n   */\n  destroy(): void {\n    this.clearCache();\n    if (this.worker) {\n      this.worker.terminate();\n      this.worker = null;\n    }\n  }\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/map/webglHeatmapRenderer.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/monitoring/systemHealth.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/recovery/errorRecovery.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/serviceInitializer.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/streaming/dataStreamManager.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/websocket/base.ts",
		"messages": [],
		"suppressedMessages": [
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 66,
				"column": 17,
				"nodeType": "AssignmentExpression",
				"messageId": "anyAssignment",
				"endLine": 66,
				"endColumn": 96,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe construction of a(n) `any` typed value.",
				"line": 66,
				"column": 27,
				"nodeType": "NewExpression",
				"messageId": "unsafeNew",
				"endLine": 66,
				"endColumn": 96,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 66,
				"column": 52,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 66,
				"endColumn": 55,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [2697, 2700], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [2697, 2700], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				],
				"suppressions": [{ "kind": "directive", "justification": "" }]
			}
		],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/websocket/example-usage.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/websocket/hackrf.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/websocket/index.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/websocket/kismet.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/services/websocket/test-connection.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/stores/connection.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of type `Writable<Map<any, any>>` to a variable of type `Writable<Map<string, ServiceStatus>>`.",
				"line": 57,
				"column": 14,
				"nodeType": "VariableDeclarator",
				"messageId": "unsafeAssignment",
				"endLine": 57,
				"endColumn": 89
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of type `Writable<Map<any, any>>` to a variable of type `Writable<Map<string, number>>`.",
				"line": 60,
				"column": 14,
				"nodeType": "VariableDeclarator",
				"messageId": "unsafeAssignment",
				"endLine": 60,
				"endColumn": 82
			}
		],
		"suppressedMessages": [],
		"errorCount": 2,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { writable, derived } from 'svelte/store';\nimport type { Writable, Readable } from 'svelte/store';\n\n// Types\nexport interface ServiceConnectionStatus {\n    connected: boolean;\n    connecting: boolean;\n    error: string | null;\n    lastConnected?: number;\n    lastError?: string;\n    reconnectAttempts: number;\n}\n\nexport interface SystemHealth {\n    cpu: number;\n    memory: number;\n    disk: number;\n    temperature?: number;\n    uptime: number;\n}\n\nexport interface ServiceStatus {\n    name: string;\n    running: boolean;\n    pid?: number;\n    uptime?: number;\n    memory?: number;\n    cpu?: number;\n}\n\n// Individual service connection stores\nexport const hackrfConnection: Writable<ServiceConnectionStatus> = writable({\n    connected: false,\n    connecting: false,\n    error: null,\n    reconnectAttempts: 0\n});\n\nexport const kismetConnection: Writable<ServiceConnectionStatus> = writable({\n    connected: false,\n    connecting: false,\n    error: null,\n    reconnectAttempts: 0\n});\n\nexport const expressConnection: Writable<ServiceConnectionStatus> = writable({\n    connected: false,\n    connecting: false,\n    error: null,\n    reconnectAttempts: 0\n});\n\n// System health store\nexport const systemHealth: Writable<SystemHealth | null> = writable(null);\n\n// Service statuses\nexport const serviceStatuses: Writable<Map<string, ServiceStatus>> = writable(new Map());\n\n// WebSocket connection states\nexport const webSocketStates: Writable<Map<string, number>> = writable(new Map());\n\n// Derived stores\nexport const allConnected: Readable<boolean> = derived(\n    [hackrfConnection, kismetConnection, expressConnection],\n    ([$hackrf, $kismet, $express]) => \n        $hackrf.connected && $kismet.connected && $express.connected\n);\n\nexport const anyConnecting: Readable<boolean> = derived(\n    [hackrfConnection, kismetConnection, expressConnection],\n    ([$hackrf, $kismet, $express]) => \n        $hackrf.connecting || $kismet.connecting || $express.connecting\n);\n\nexport const connectionErrors: Readable<string[]> = derived(\n    [hackrfConnection, kismetConnection, expressConnection],\n    ([$hackrf, $kismet, $express]) => {\n        const errors: string[] = [];\n        if ($hackrf.error) errors.push(`HackRF: ${$hackrf.error}`);\n        if ($kismet.error) errors.push(`Kismet: ${$kismet.error}`);\n        if ($express.error) errors.push(`Express: ${$express.error}`);\n        return errors;\n    }\n);\n\nexport const totalReconnectAttempts: Readable<number> = derived(\n    [hackrfConnection, kismetConnection, expressConnection],\n    ([$hackrf, $kismet, $express]) => \n        $hackrf.reconnectAttempts + $kismet.reconnectAttempts + $express.reconnectAttempts\n);\n\nexport const systemHealthy: Readable<boolean> = derived(\n    systemHealth,\n    $health => {\n        if (!$health) return false;\n        return $health.cpu < 80 && \n               $health.memory < 80 && \n               $health.disk < 90 &&\n               (!$health.temperature || $health.temperature < 70);\n    }\n);\n\nexport const runningServices: Readable<ServiceStatus[]> = derived(\n    serviceStatuses,\n    $statuses => Array.from($statuses.values()).filter(s => s.running)\n);\n\nexport const stoppedServices: Readable<ServiceStatus[]> = derived(\n    serviceStatuses,\n    $statuses => Array.from($statuses.values()).filter(s => !s.running)\n);\n\n// Helper functions\nexport function updateHackRFConnection(updates: Partial<ServiceConnectionStatus>) {\n    hackrfConnection.update(status => ({ ...status, ...updates }));\n}\n\nexport function updateKismetConnection(updates: Partial<ServiceConnectionStatus>) {\n    kismetConnection.update(status => ({ ...status, ...updates }));\n}\n\nexport function updateExpressConnection(updates: Partial<ServiceConnectionStatus>) {\n    expressConnection.update(status => ({ ...status, ...updates }));\n}\n\nexport function updateSystemHealth(health: SystemHealth | null) {\n    systemHealth.set(health);\n}\n\nexport function updateServiceStatus(name: string, status: ServiceStatus) {\n    serviceStatuses.update(statuses => {\n        const map = new Map(statuses);\n        map.set(name, status);\n        return map;\n    });\n}\n\nexport function removeServiceStatus(name: string) {\n    serviceStatuses.update(statuses => {\n        const map = new Map(statuses);\n        map.delete(name);\n        return map;\n    });\n}\n\nexport function updateWebSocketState(name: string, state: number) {\n    webSocketStates.update(states => {\n        const map = new Map(states);\n        map.set(name, state);\n        return map;\n    });\n}\n\nexport function removeWebSocketState(name: string) {\n    webSocketStates.update(states => {\n        const map = new Map(states);\n        map.delete(name);\n        return map;\n    });\n}\n\nexport function resetConnectionStores() {\n    hackrfConnection.set({\n        connected: false,\n        connecting: false,\n        error: null,\n        reconnectAttempts: 0\n    });\n    kismetConnection.set({\n        connected: false,\n        connecting: false,\n        error: null,\n        reconnectAttempts: 0\n    });\n    expressConnection.set({\n        connected: false,\n        connecting: false,\n        error: null,\n        reconnectAttempts: 0\n    });\n    systemHealth.set(null);\n    serviceStatuses.set(new Map());\n    webSocketStates.set(new Map());\n}\n\n// Utility functions\nexport function getWebSocketStateText(state: number | undefined): string {\n    switch (state) {\n        case 0: return 'Connecting';\n        case 1: return 'Open';\n        case 2: return 'Closing';\n        case 3: return 'Closed';\n        default: return 'Unknown';\n    }\n}\n\nexport function getConnectionStatusClass(status: ServiceConnectionStatus): string {\n    if (status.connected) return 'text-green-600';\n    if (status.connecting) return 'text-yellow-600';\n    if (status.error) return 'text-red-600';\n    return 'text-gray-600';\n}\n\nexport function getHealthStatusClass(value: number, thresholds: { warning: number; danger: number }): string {\n    if (value >= thresholds.danger) return 'text-red-600';\n    if (value >= thresholds.warning) return 'text-yellow-600';\n    return 'text-green-600';\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/stores/drone.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 32,
				"column": 31,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 32,
				"endColumn": 34,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [850, 853], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [850, 853], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 137,
				"column": 10,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 137,
				"endColumn": 13,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [3321, 3324], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [3321, 3324], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 2,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { writable, derived } from 'svelte/store';\nimport type { SignalMarker } from './map/signals';\n\n// Drone mission types\nexport interface DroneMission {\n  id: string;\n  name: string;\n  type: 'survey' | 'patrol' | 'monitoring' | 'mapping';\n  status: 'planned' | 'active' | 'paused' | 'completed';\n  waypoints: Waypoint[];\n  areaOfInterest?: AreaOfInterest;\n  startTime?: number;\n  endTime?: number;\n  flightPath: FlightPoint[];\n  signalCaptures: SignalCapture[];\n  statistics: MissionStatistics;\n  settings: MissionSettings;\n}\n\nexport interface Waypoint {\n  id: string;\n  lat: number;\n  lon: number;\n  altitude: number; // meters AGL\n  speed?: number; // m/s\n  hover?: number; // seconds to hover\n  actions?: WaypointAction[];\n}\n\nexport interface WaypointAction {\n  type: 'scan' | 'photo' | 'video' | 'signal_sweep';\n  parameters?: Record<string, any>;\n}\n\nexport interface AreaOfInterest {\n  id: string;\n  name: string;\n  type: 'polygon' | 'circle' | 'rectangle';\n  coordinates: [number, number][]; // [lat, lon]\n  center?: { lat: number; lon: number };\n  radius?: number; // for circle type\n  scanPattern?: 'grid' | 'spiral' | 'random';\n  flightAltitude: number;\n  overlap?: number; // percentage for grid patterns\n}\n\nexport interface FlightPoint {\n  timestamp: number;\n  lat: number;\n  lon: number;\n  altitude: number;\n  heading: number;\n  speed: number;\n  signalStrength?: number; // aggregate signal strength at this point\n  battery?: number;\n}\n\nexport interface SignalCapture {\n  id: string;\n  timestamp: number;\n  position: { lat: number; lon: number; altitude: number };\n  signals: SignalMarker[];\n  strongestSignal?: SignalMarker;\n  averagePower: number;\n  signalCount: number;\n}\n\nexport interface MissionStatistics {\n  totalDistance: number; // meters\n  totalDuration: number; // seconds\n  averageSpeed: number; // m/s\n  maxAltitude: number;\n  minAltitude: number;\n  signalsCaptured: number;\n  uniqueDevices: number;\n  coverageArea: number; // square meters\n  batteryUsed?: number; // percentage\n}\n\nexport interface MissionSettings {\n  altitudeFilter: { min: number; max: number };\n  signalThreshold: number; // minimum power in dBm\n  scanInterval: number; // seconds between scans\n  autoLand: boolean;\n  returnToHome: boolean;\n  geofence?: { center: { lat: number; lon: number }; radius: number };\n}\n\n// Drone state\nexport interface DroneState {\n  connected: boolean;\n  armed: boolean;\n  flying: boolean;\n  mode: 'manual' | 'auto' | 'guided' | 'rtl';\n  position: {\n    lat: number;\n    lon: number;\n    altitude: number;\n    heading: number;\n  };\n  velocity: {\n    groundSpeed: number;\n    verticalSpeed: number;\n  };\n  battery: {\n    voltage: number;\n    current: number;\n    remaining: number; // percentage\n    timeRemaining?: number; // seconds\n  };\n  gps: {\n    fix: boolean;\n    satellites: number;\n    hdop: number;\n  };\n  sensors: {\n    imu: boolean;\n    compass: boolean;\n    barometer: boolean;\n    rangefinder?: boolean;\n  };\n}\n\n// Flight recorder state\nexport interface FlightRecorder {\n  recording: boolean;\n  startTime?: number;\n  duration: number;\n  points: FlightPoint[];\n  events: FlightEvent[];\n}\n\nexport interface FlightEvent {\n  timestamp: number;\n  type: 'takeoff' | 'landing' | 'mode_change' | 'battery_warning' | 'signal_detection' | 'geofence_breach';\n  description: string;\n  data?: any;\n}\n\n// Create stores\nexport const droneState = writable<DroneState>({\n  connected: false,\n  armed: false,\n  flying: false,\n  mode: 'manual',\n  position: { lat: 0, lon: 0, altitude: 0, heading: 0 },\n  velocity: { groundSpeed: 0, verticalSpeed: 0 },\n  battery: { voltage: 0, current: 0, remaining: 100 },\n  gps: { fix: false, satellites: 0, hdop: 99 },\n  sensors: { imu: false, compass: false, barometer: false }\n});\n\nexport const activeMission = writable<DroneMission | null>(null);\nexport const missionHistory = writable<DroneMission[]>([]);\nexport const flightRecorder = writable<FlightRecorder>({\n  recording: false,\n  duration: 0,\n  points: [],\n  events: []\n});\n\nexport const areasOfInterest = writable<AreaOfInterest[]>([]);\nexport const selectedAOI = writable<AreaOfInterest | null>(null);\n\n// Derived stores for UI\nexport const isOperational = derived(\n  droneState,\n  $state => $state.connected && $state.gps.fix && $state.battery.remaining > 20\n);\n\nexport const missionProgress = derived(\n  [activeMission, droneState],\n  ([$mission, $state]) => {\n    if (!$mission || $mission.status !== 'active') return 0;\n    \n    if ($mission.waypoints.length === 0) return 0;\n    \n    // Calculate progress based on waypoints visited\n    const currentPos = $state.position;\n    let visitedCount = 0;\n    \n    for (const waypoint of $mission.waypoints) {\n      const distance = calculateDistance(\n        currentPos.lat, currentPos.lon,\n        waypoint.lat, waypoint.lon\n      );\n      if (distance < 10) { // Within 10 meters\n        visitedCount++;\n      }\n    }\n    \n    return (visitedCount / $mission.waypoints.length) * 100;\n  }\n);\n\n// Store functions\nexport function startMission(mission: DroneMission) {\n  mission.status = 'active';\n  mission.startTime = Date.now();\n  activeMission.set(mission);\n  \n  // Start flight recording\n  flightRecorder.update(state => ({\n    ...state,\n    recording: true,\n    startTime: Date.now(),\n    points: [],\n    events: [{\n      timestamp: Date.now(),\n      type: 'takeoff',\n      description: `Mission \"${mission.name}\" started`\n    }]\n  }));\n}\n\nexport function pauseMission() {\n  activeMission.update(mission => {\n    if (mission) {\n      mission.status = 'paused';\n      \n      flightRecorder.update(state => ({\n        ...state,\n        recording: false,\n        events: [...state.events, {\n          timestamp: Date.now(),\n          type: 'mode_change',\n          description: 'Mission paused'\n        }]\n      }));\n    }\n    return mission;\n  });\n}\n\nexport function completeMission() {\n  activeMission.update(mission => {\n    if (mission) {\n      mission.status = 'completed';\n      mission.endTime = Date.now();\n      \n      // Add to history\n      missionHistory.update(history => [...history, mission]);\n      \n      // Stop recording\n      flightRecorder.update(state => ({\n        ...state,\n        recording: false,\n        events: [...state.events, {\n          timestamp: Date.now(),\n          type: 'landing',\n          description: 'Mission completed'\n        }]\n      }));\n    }\n    return null;\n  });\n}\n\nexport function addSignalCapture(capture: SignalCapture) {\n  activeMission.update(mission => {\n    if (mission && mission.status === 'active') {\n      mission.signalCaptures.push(capture);\n      mission.statistics.signalsCaptured += capture.signalCount;\n      \n      // Update unique devices count\n      const uniqueIds = new Set(\n        mission.signalCaptures.flatMap(c => c.signals.map(s => s.id))\n      );\n      mission.statistics.uniqueDevices = uniqueIds.size;\n    }\n    return mission;\n  });\n}\n\nexport function recordFlightPoint(point: FlightPoint) {\n  flightRecorder.update(state => {\n    if (state.recording) {\n      state.points.push(point);\n      state.duration = Date.now() - (state.startTime || 0);\n    }\n    return state;\n  });\n  \n  // Update mission flight path\n  activeMission.update(mission => {\n    if (mission && mission.status === 'active') {\n      mission.flightPath.push(point);\n      \n      // Update statistics\n      if (mission.flightPath.length > 1) {\n        const lastPoint = mission.flightPath[mission.flightPath.length - 2];\n        const distance = calculateDistance(\n          lastPoint.lat, lastPoint.lon,\n          point.lat, point.lon\n        );\n        mission.statistics.totalDistance += distance;\n        mission.statistics.totalDuration = Date.now() - (mission.startTime || 0);\n        mission.statistics.maxAltitude = Math.max(mission.statistics.maxAltitude, point.altitude);\n        mission.statistics.minAltitude = Math.min(mission.statistics.minAltitude, point.altitude);\n      }\n    }\n    return mission;\n  });\n}\n\n// Helper functions\nfunction calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n  const R = 6371e3;\n  const φ1 = lat1 * Math.PI / 180;\n  const φ2 = lat2 * Math.PI / 180;\n  const Δφ = (lat2 - lat1) * Math.PI / 180;\n  const Δλ = (lon2 - lon1) * Math.PI / 180;\n\n  const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +\n            Math.cos(φ1) * Math.cos(φ2) *\n            Math.sin(Δλ/2) * Math.sin(Δλ/2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\n  return R * c;\n}\n\n// Export helper to create new missions\nexport function createMission(\n  name: string,\n  type: DroneMission['type'],\n  waypoints: Waypoint[] = [],\n  aoi?: AreaOfInterest,\n  settings?: Partial<MissionSettings>\n): DroneMission {\n  return {\n    id: `mission-${Date.now()}`,\n    name,\n    type,\n    status: 'planned',\n    waypoints,\n    areaOfInterest: aoi,\n    flightPath: [],\n    signalCaptures: [],\n    statistics: {\n      totalDistance: 0,\n      totalDuration: 0,\n      averageSpeed: 0,\n      maxAltitude: 0,\n      minAltitude: Infinity,\n      signalsCaptured: 0,\n      uniqueDevices: 0,\n      coverageArea: 0\n    },\n    settings: {\n      altitudeFilter: { min: 0, max: 400 },\n      signalThreshold: -90,\n      scanInterval: 1,\n      autoLand: true,\n      returnToHome: true,\n      ...settings\n    }\n  };\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/stores/hackrf.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 74,
				"column": 18,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 74,
				"endColumn": 21,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [1589, 1592], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [1589, 1592], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 135,
				"column": 29,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 135,
				"endColumn": 32,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [2979, 2982], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [2979, 2982], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type `any` assigned to a parameter of type `string | number | Timeout | undefined`.",
				"line": 251,
				"column": 23,
				"nodeType": "Identifier",
				"messageId": "unsafeArgument",
				"endLine": 251,
				"endColumn": 45
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 2,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { writable, derived } from 'svelte/store';\nimport type { Writable, Readable } from 'svelte/store';\n\n// Types\nexport interface SpectrumData {\n    frequencies: number[];\n    power: number[];\n    power_levels?: number[]; // Alternative format\n    start_freq?: number;\n    stop_freq?: number;\n    center_freq?: number;\n    peak_power?: number;\n    peak_freq?: number;\n    avg_power?: number;\n    centerFreq: number;\n    sampleRate: number;\n    binSize: number;\n    timestamp: number;\n    sweepId?: string;\n    processed?: boolean;\n}\n\nexport interface FrequencyRange {\n    id: string;\n    start: number;\n    stop: number;\n    step: number;\n}\n\nexport interface SignalHistoryEntry {\n    frequency: number;\n    power: number;\n    timestamp: number;\n}\n\nexport interface SweepStatus {\n    active: boolean;\n    startFreq: number;\n    endFreq: number;\n    currentFreq: number;\n    progress: number;\n    startTime?: number;\n    duration?: number;\n    sweepCount?: number;\n    error?: string;\n}\n\nexport interface CycleStatus {\n    active: boolean;\n    currentCycle: number;\n    totalCycles: number;\n    cycleTime?: number;\n    timeRemaining?: number;\n    startTime?: number;\n    endTime?: number;\n    duration?: number;\n    progress: number;\n}\n\nexport interface EmergencyStopStatus {\n    active: boolean;\n    reason?: string;\n    timestamp?: number;\n}\n\nexport interface ConnectionStatus {\n    connected: boolean;\n    connecting: boolean;\n    error: string | null;\n    reconnectAttempts?: number;\n    lastError?: string;\n    lastConnected?: number;\n    deviceConnected?: boolean;\n    deviceInfo?: any;\n}\n\nexport interface DeviceInfo {\n    serial: string;\n    version: string;\n    board_id: number;\n    board_name: string;\n    firmware_version?: string;\n}\n\nexport interface HackRFConfig {\n    gain: number;\n    lnaGain: number;\n    vgaGain: number;\n    sampleRate: number;\n    centerFreq: number;\n    bandwidth: number;\n}\n\n// Stores\nexport const spectrumData: Writable<SpectrumData | null> = writable(null);\nexport const sweepStatus: Writable<SweepStatus> = writable({\n    active: false,\n    startFreq: 0,\n    endFreq: 0,\n    currentFreq: 0,\n    progress: 0\n});\n\nexport const cycleStatus: Writable<CycleStatus> = writable({\n    active: false,\n    currentCycle: 0,\n    totalCycles: 0,\n    progress: 0\n});\n\nexport const emergencyStopStatus: Writable<EmergencyStopStatus> = writable({\n    active: false\n});\n\nexport const connectionStatus: Writable<ConnectionStatus> = writable({\n    connected: false,\n    connecting: false,\n    error: null\n});\n\nexport const deviceInfo: Writable<DeviceInfo | null> = writable(null);\n\nexport const config: Writable<HackRFConfig> = writable({\n    gain: 30,\n    lnaGain: 20,\n    vgaGain: 20,\n    sampleRate: 20e6,\n    centerFreq: 915e6,\n    bandwidth: 20e6\n});\n\n// History store for spectrum data\nexport const spectrumHistory: Writable<SpectrumData[]> = writable([]);\nconst MAX_HISTORY_SIZE = 50; // Reduced to prevent memory issues\nlet historyCleanupInterval: any = null;\n\n// Frequency configuration\nexport const frequencyRanges: Writable<FrequencyRange[]> = writable([]);\n\n// Signal history\nexport const signalHistory: Writable<SignalHistoryEntry[]> = writable([]);\n\n// Derived stores\nexport const isActive: Readable<boolean> = derived(\n    [sweepStatus, cycleStatus],\n    ([$sweepStatus, $cycleStatus]) => $sweepStatus.active || $cycleStatus.active\n);\n\nexport const sweepProgress: Readable<number> = derived(\n    sweepStatus,\n    $sweepStatus => $sweepStatus.progress\n);\n\nexport const sweepDuration: Readable<number> = derived(\n    sweepStatus,\n    $sweepStatus => $sweepStatus.duration || 0\n);\n\nexport const isEmergencyStopped: Readable<boolean> = derived(\n    emergencyStopStatus,\n    $emergencyStopStatus => $emergencyStopStatus.active\n);\n\nexport const peakFrequency: Readable<number | null> = derived(\n    spectrumData,\n    $spectrumData => {\n        if (!$spectrumData) return null;\n        \n        const maxIndex = $spectrumData.power.indexOf(Math.max(...$spectrumData.power));\n        return $spectrumData.frequencies[maxIndex];\n    }\n);\n\nexport const averagePower: Readable<number | null> = derived(\n    spectrumData,\n    $spectrumData => {\n        if (!$spectrumData || $spectrumData.power.length === 0) return null;\n        \n        const sum = $spectrumData.power.reduce((acc, val) => acc + val, 0);\n        return sum / $spectrumData.power.length;\n    }\n);\n\nexport const signalStrength: Readable<number> = derived(\n    spectrumData,\n    $spectrumData => {\n        if (!$spectrumData) return -100;\n        \n        const max = Math.max(...$spectrumData.power);\n        return Math.max(-100, Math.min(0, max));\n    }\n);\n\n// Helper functions\nexport function updateSpectrumData(data: SpectrumData | null) {\n    spectrumData.set(data);\n    \n    // Add to history if not null\n    if (data) {\n        spectrumHistory.update(history => {\n            const newHistory = [...history, data];\n            // Keep only the last MAX_HISTORY_SIZE entries\n            if (newHistory.length > MAX_HISTORY_SIZE) {\n                return newHistory.slice(-MAX_HISTORY_SIZE);\n            }\n            return newHistory;\n        });\n    }\n    \n    // Start periodic cleanup if not already running\n    if (!historyCleanupInterval) {\n        historyCleanupInterval = setInterval(() => {\n            spectrumHistory.update(history => {\n                // Remove old entries older than 5 minutes\n                const fiveMinutesAgo = Date.now() - 5 * 60 * 1000;\n                return history.filter(entry => entry.timestamp > fiveMinutesAgo);\n            });\n        }, 60000); // Cleanup every minute\n    }\n}\n\nexport function updateSweepStatus(updates: Partial<SweepStatus>) {\n    sweepStatus.update(status => ({ ...status, ...updates }));\n}\n\nexport function updateCycleStatus(updates: Partial<CycleStatus>) {\n    cycleStatus.update(status => ({ ...status, ...updates }));\n}\n\nexport function updateEmergencyStopStatus(updates: Partial<EmergencyStopStatus>) {\n    emergencyStopStatus.update(status => ({ ...status, ...updates }));\n}\n\nexport function updateConnectionStatus(updates: Partial<ConnectionStatus>) {\n    connectionStatus.update(status => ({ ...status, ...updates }));\n}\n\nexport function updateDeviceInfo(info: DeviceInfo | null) {\n    deviceInfo.set(info);\n}\n\nexport function updateConfig(updates: Partial<HackRFConfig>) {\n    config.update(cfg => ({ ...cfg, ...updates }));\n}\n\nexport function clearSpectrumHistory() {\n    spectrumHistory.set([]);\n    \n    // Stop cleanup interval\n    if (historyCleanupInterval) {\n        clearInterval(historyCleanupInterval);\n        historyCleanupInterval = null;\n    }\n}\n\nexport function updateSignalHistory(entry: SignalHistoryEntry) {\n    signalHistory.update(history => {\n        const newHistory = [...history, entry];\n        // Keep only the last 50 entries\n        if (newHistory.length > 50) {\n            return newHistory.slice(-50);\n        }\n        return newHistory;\n    });\n}\n\nexport function resetStores() {\n    spectrumData.set(null);\n    sweepStatus.set({\n        active: false,\n        startFreq: 0,\n        endFreq: 0,\n        currentFreq: 0,\n        progress: 0\n    });\n    cycleStatus.set({\n        active: false,\n        currentCycle: 0,\n        totalCycles: 0,\n        progress: 0\n    });\n    emergencyStopStatus.set({\n        active: false\n    });\n    connectionStatus.set({\n        connected: false,\n        connecting: false,\n        error: null\n    });\n    deviceInfo.set(null);\n    clearSpectrumHistory();\n}\n\n// Utility functions for frequency formatting\nexport function formatFrequency(freq: number): string {\n    if (freq >= 1e9) {\n        return `${(freq / 1e9).toFixed(3)} GHz`;\n    } else if (freq >= 1e6) {\n        return `${(freq / 1e6).toFixed(3)} MHz`;\n    } else if (freq >= 1e3) {\n        return `${(freq / 1e3).toFixed(3)} kHz`;\n    } else {\n        return `${freq.toFixed(0)} Hz`;\n    }\n}\n\nexport function formatPower(power: number): string {\n    return `${power.toFixed(1)} dBm`;\n}\n\nexport function formatSampleRate(rate: number): string {\n    if (rate >= 1e6) {\n        return `${(rate / 1e6).toFixed(1)} MS/s`;\n    } else if (rate >= 1e3) {\n        return `${(rate / 1e3).toFixed(1)} kS/s`;\n    } else {\n        return `${rate.toFixed(0)} S/s`;\n    }\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/stores/kismet.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 98,
				"column": 5,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 98,
				"endColumn": 8
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 112,
				"column": 29,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 112,
				"endColumn": 32,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [2227, 2230], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [2227, 2230], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .devices on an `any` value.",
				"line": 117,
				"column": 14,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 117,
				"endColumn": 21
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 118,
				"column": 6,
				"nodeType": "AssignmentExpression",
				"messageId": "anyAssignment",
				"endLine": 118,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .devices on an `any` value.",
				"line": 118,
				"column": 30,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 118,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 122,
				"column": 6,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 122,
				"endColumn": 26
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .devices on an `any` value.",
				"line": 122,
				"column": 11,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 122,
				"endColumn": 18
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .networks on an `any` value.",
				"line": 145,
				"column": 14,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 145,
				"endColumn": 22
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 146,
				"column": 6,
				"nodeType": "AssignmentExpression",
				"messageId": "anyAssignment",
				"endLine": 146,
				"endColumn": 39
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .networks on an `any` value.",
				"line": 146,
				"column": 31,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 146,
				"endColumn": 39
			}
		],
		"suppressedMessages": [],
		"errorCount": 9,
		"fatalErrorCount": 0,
		"warningCount": 1,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { writable, derived, get } from 'svelte/store';\nimport type { Writable } from 'svelte/store';\nimport type { KismetStore, KismetDevice, KismetNetwork, KismetAlert, KismetStatus } from '$lib/types/kismet';\n\nfunction createKismetStore() {\n\tconst store: Writable<KismetStore> = writable({\n\t\tdevices: [],\n\t\tnetworks: [],\n\t\talerts: [],\n\t\tstatus: {\n\t\t\tkismet_running: false,\n\t\t\twigle_running: false,\n\t\t\tgps_running: false\n\t\t},\n\t\tgps: {\n\t\t\tstatus: 'No Fix',\n\t\t\tlat: 'N/A',\n\t\t\tlon: 'N/A',\n\t\t\talt: 'N/A',\n\t\t\ttime: 'N/A'\n\t\t},\n\t\tlastUpdate: null,\n\t\tstartTime: null\n\t});\n\n\tlet alertIdCounter = 0;\n\n\treturn {\n\t\tsubscribe: store.subscribe,\n\t\t\n\t\t// Update entire store\n\t\tset: store.set,\n\t\t\n\t\t// Update devices\n\t\tupdateDevices: (devices: KismetDevice[]) => {\n\t\t\tstore.update(s => ({\n\t\t\t\t...s,\n\t\t\t\tdevices,\n\t\t\t\tlastUpdate: Date.now()\n\t\t\t}));\n\t\t},\n\t\t\n\t\t// Update networks\n\t\tupdateNetworks: (networks: KismetNetwork[]) => {\n\t\t\tstore.update(s => ({\n\t\t\t\t...s,\n\t\t\t\tnetworks,\n\t\t\t\tlastUpdate: Date.now()\n\t\t\t}));\n\t\t},\n\t\t\n\t\t// Add alert\n\t\taddAlert: (alert: Omit<KismetAlert, 'id'>) => {\n\t\t\tconst newAlert: KismetAlert = {\n\t\t\t\t...alert,\n\t\t\t\tid: `alert-${++alertIdCounter}-${Date.now()}`\n\t\t\t};\n\t\t\t\n\t\t\tstore.update(s => ({\n\t\t\t\t...s,\n\t\t\t\talerts: [...s.alerts, newAlert]\n\t\t\t}));\n\t\t},\n\t\t\n\t\t// Clear alerts\n\t\tclearAlerts: () => {\n\t\t\tstore.update(s => ({\n\t\t\t\t...s,\n\t\t\t\talerts: []\n\t\t\t}));\n\t\t},\n\t\t\n\t\t// Update status\n\t\tupdateStatus: (status: Partial<KismetStatus>) => {\n\t\t\tstore.update(s => {\n\t\t\t\tconst newStatus = { ...s.status, ...status };\n\t\t\t\t\n\t\t\t\t// Track start time when Kismet starts\n\t\t\t\tlet startTime = s.startTime;\n\t\t\t\tif (newStatus.kismet_running && !s.status.kismet_running) {\n\t\t\t\t\tstartTime = Date.now();\n\t\t\t\t} else if (!newStatus.kismet_running && s.status.kismet_running) {\n\t\t\t\t\tstartTime = null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\t...s,\n\t\t\t\t\tstatus: newStatus,\n\t\t\t\t\tstartTime\n\t\t\t\t};\n\t\t\t});\n\t\t},\n\t\t\n\t\t// Update GPS\n\t\tupdateGPS: (gps: typeof KismetStore.prototype.gps) => {\n\t\t\tstore.update(s => ({\n\t\t\t\t...s,\n\t\t\t\tgps\n\t\t\t}));\n\t\t},\n\t\t\n\t\t// Get current status\n\t\tgetStatus: () => {\n\t\t\tconst current = get(store);\n\t\t\treturn {\n\t\t\t\t...current.status,\n\t\t\t\tstartTime: current.startTime\n\t\t\t};\n\t\t},\n\t\t\n\t\t// Process Kismet data update\n\t\tprocessKismetData: (data: any) => {\n\t\t\tstore.update(s => {\n\t\t\t\tconst newState = { ...s };\n\t\t\t\t\n\t\t\t\t// Process devices\n\t\t\t\tif (data.devices) {\n\t\t\t\t\tnewState.devices = data.devices;\n\t\t\t\t\t\n\t\t\t\t\t// Check for new devices and create alerts\n\t\t\t\t\tconst existingMacs = new Set(s.devices.map(d => d.mac));\n\t\t\t\t\tdata.devices.forEach((device: KismetDevice) => {\n\t\t\t\t\t\tif (!existingMacs.has(device.mac)) {\n\t\t\t\t\t\t\t// New device detected\n\t\t\t\t\t\t\tconst alert: Omit<KismetAlert, 'id'> = {\n\t\t\t\t\t\t\t\ttype: 'new_device',\n\t\t\t\t\t\t\t\tseverity: 'low',\n\t\t\t\t\t\t\t\tmessage: `New device detected: ${device.manufacturer || 'Unknown'} (${device.mac})`,\n\t\t\t\t\t\t\t\ttimestamp: Date.now() / 1000,\n\t\t\t\t\t\t\t\tdetails: {\n\t\t\t\t\t\t\t\t\tmac: device.mac,\n\t\t\t\t\t\t\t\t\tsignal: device.signal.last_signal,\n\t\t\t\t\t\t\t\t\tchannel: device.channel\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tnewState.alerts = [...newState.alerts, {\n\t\t\t\t\t\t\t\t...alert,\n\t\t\t\t\t\t\t\tid: `alert-${++alertIdCounter}-${Date.now()}`\n\t\t\t\t\t\t\t}];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Process networks\n\t\t\t\tif (data.networks) {\n\t\t\t\t\tnewState.networks = data.networks;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Update last update time\n\t\t\t\tnewState.lastUpdate = Date.now();\n\t\t\t\t\n\t\t\t\treturn newState;\n\t\t\t});\n\t\t}\n\t};\n}\n\nexport const kismetStore = createKismetStore();\n\n// Derived stores for filtered data\nexport const activeDevices = derived(kismetStore, $store => {\n\tconst fiveMinutesAgo = Date.now() / 1000 - 300;\n\treturn $store.devices.filter(d => d.last_seen > fiveMinutesAgo);\n});\n\nexport const recentAlerts = derived(kismetStore, $store => {\n\tconst oneHourAgo = Date.now() / 1000 - 3600;\n\treturn $store.alerts.filter(a => a.timestamp > oneHourAgo);\n});\n\nexport const devicesByType = derived(kismetStore, $store => {\n\tconst types: Record<string, number> = {};\n\t$store.devices.forEach(device => {\n\t\ttypes[device.type] = (types[device.type] || 0) + 1;\n\t});\n\treturn types;\n});\n\nexport const channelDistribution = derived(kismetStore, $store => {\n\tconst channels: Record<number, number> = {};\n\t$store.devices.forEach(device => {\n\t\tif (device.channel > 0) {\n\t\t\tchannels[device.channel] = (channels[device.channel] || 0) + 1;\n\t\t}\n\t});\n\treturn channels;\n});",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/stores/map/signals.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/stores/notifications.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/types/kismet.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 45,
				"column": 18,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 45,
				"endColumn": 21,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [834, 837], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [834, 837], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 1,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "export interface KismetDevice {\n\tmac: string;\n\tlast_seen: number;\n\tsignal: {\n\t\tlast_signal?: number;\n\t\tmax_signal?: number;\n\t\tmin_signal?: number;\n\t};\n\tmanufacturer?: string;\n\ttype: string;\n\tchannel: number;\n\tfrequency: number;\n\tpackets: number;\n\tdatasize: number;\n\tlocation?: {\n\t\tlat: number;\n\t\tlon: number;\n\t};\n}\n\nexport interface KismetNetwork {\n\tssid: string;\n\tbssid: string;\n\tchannel: number;\n\tfrequency: number;\n\tencryption: string;\n\tlast_seen: number;\n\tsignal: {\n\t\tlast_signal?: number;\n\t};\n\tclients: number;\n}\n\nexport interface KismetAlert {\n\tid: string;\n\ttype: 'new_device' | 'security' | 'deauth' | 'probe' | 'handshake' | 'suspicious' | 'info';\n\tseverity: 'low' | 'medium' | 'high';\n\tmessage: string;\n\ttimestamp: number;\n\tdetails?: {\n\t\tmac?: string;\n\t\tssid?: string;\n\t\tchannel?: number;\n\t\tsignal?: number;\n\t\t[key: string]: any;\n\t};\n}\n\nexport interface KismetStatus {\n\tkismet_running: boolean;\n\twigle_running: boolean;\n\tgps_running: boolean;\n}\n\nexport interface KismetGPS {\n\tstatus: string;\n\tlat: string;\n\tlon: string;\n\talt: string;\n\ttime: string;\n}\n\nexport interface KismetStore {\n\tdevices: KismetDevice[];\n\tnetworks: KismetNetwork[];\n\talerts: KismetAlert[];\n\tstatus: KismetStatus;\n\tgps: KismetGPS;\n\tlastUpdate: number | null;\n\tstartTime: number | null;\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/types/leaflet-extensions.d.ts",
		"messages": [
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'L' is not defined.",
				"line": 5,
				"column": 54,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 5,
				"endColumn": 55
			},
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'L' is not defined.",
				"line": 13,
				"column": 54,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 13,
				"endColumn": 55
			},
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'L' is not defined.",
				"line": 16,
				"column": 42,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 16,
				"endColumn": 43
			},
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'L' is not defined.",
				"line": 17,
				"column": 27,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 17,
				"endColumn": 28
			},
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'L' is not defined.",
				"line": 19,
				"column": 18,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 19,
				"endColumn": 19
			},
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'L' is not defined.",
				"line": 22,
				"column": 47,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 22,
				"endColumn": 48
			},
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'L' is not defined.",
				"line": 24,
				"column": 21,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 24,
				"endColumn": 22
			},
			{
				"ruleId": "no-undef",
				"severity": 2,
				"message": "'L' is not defined.",
				"line": 25,
				"column": 24,
				"nodeType": "Identifier",
				"messageId": "undef",
				"endLine": 25,
				"endColumn": 25
			}
		],
		"suppressedMessages": [],
		"errorCount": 8,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "/// <reference types=\"leaflet\" />\n/// <reference types=\"leaflet.markercluster\" />\n\ndeclare module 'leaflet' {\n  export interface MarkerClusterGroupOptions extends L.LayerOptions {\n    maxClusterRadius?: number;\n    disableClusteringAtZoom?: number;\n    spiderfyOnMaxZoom?: boolean;\n    showCoverageOnHover?: boolean;\n    zoomToBoundsOnClick?: boolean;\n    singleMarkerMode?: boolean;\n    animateAddingMarkers?: boolean;\n    iconCreateFunction?: (cluster: MarkerCluster) => L.DivIcon;\n  }\n\n  export interface MarkerCluster extends L.Layer {\n    getAllChildMarkers(): L.Marker[];\n    getChildCount(): number;\n    getLatLng(): L.LatLng;\n  }\n\n  export interface MarkerClusterGroup extends L.FeatureGroup {\n    refreshClusters(): void;\n    addLayer(layer: L.Layer): this;\n    removeLayer(layer: L.Layer): this;\n    clearLayers(): this;\n    options: MarkerClusterGroupOptions;\n  }\n\n  export function markerClusterGroup(options?: MarkerClusterGroupOptions): MarkerClusterGroup;\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/utils/countryDetector.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/utils/hackrf/signalAnalysis.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/utils/logger.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 17,
				"column": 13,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 17,
				"endColumn": 16,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [283, 286], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [283, 286], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 123,
				"column": 59,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 123,
				"endColumn": 62,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [2843, 2846], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [2843, 2846], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 135,
				"column": 7,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 135,
				"endColumn": 14
			},
			{
				"ruleId": "no-console",
				"severity": 1,
				"message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
				"line": 152,
				"column": 11,
				"nodeType": "MemberExpression",
				"messageId": "limited",
				"endLine": 152,
				"endColumn": 23,
				"suggestions": [
					{
						"fix": { "range": [3576, 3621], "text": "" },
						"messageId": "removeConsole",
						"data": { "propertyName": "info" },
						"desc": "Remove the console.info()."
					}
				]
			},
			{
				"ruleId": "no-console",
				"severity": 1,
				"message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
				"line": 156,
				"column": 13,
				"nodeType": "MemberExpression",
				"messageId": "limited",
				"endLine": 156,
				"endColumn": 24,
				"suggestions": [
					{
						"fix": { "range": [3716, 3760], "text": "" },
						"messageId": "removeConsole",
						"data": { "propertyName": "log" },
						"desc": "Remove the console.log()."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 163,
				"column": 36,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 163,
				"endColumn": 39,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [3844, 3847], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [3844, 3847], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 167,
				"column": 35,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 167,
				"endColumn": 38,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [3971, 3974], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [3971, 3974], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 171,
				"column": 35,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 171,
				"endColumn": 38,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [4097, 4100], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [4097, 4100], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 175,
				"column": 36,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 175,
				"endColumn": 39,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [4224, 4227], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [4224, 4227], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 201,
				"column": 53,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 201,
				"endColumn": 56,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [4835, 4838], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [4835, 4838], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 204,
				"column": 52,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 204,
				"endColumn": 55,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [4957, 4960], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [4957, 4960], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 207,
				"column": 52,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 207,
				"endColumn": 55,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [5078, 5081], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [5078, 5081], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 210,
				"column": 53,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 210,
				"endColumn": 56,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [5200, 5203], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [5200, 5203], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 12,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "/**\n * Lightweight logger with memory-efficient circular buffer\n * Prevents memory issues from excessive logging\n */\n\nexport enum LogLevel {\n  ERROR = 0,\n  WARN = 1,\n  INFO = 2,\n  DEBUG = 3\n}\n\ninterface LogEntry {\n  timestamp: Date;\n  level: LogLevel;\n  message: string;\n  context?: any;\n}\n\nclass CircularLogBuffer {\n  private buffer: LogEntry[] = [];\n  private maxSize: number;\n  private pointer: number = 0;\n\n  constructor(maxSize: number = 1000) {\n    this.maxSize = maxSize;\n  }\n\n  add(entry: LogEntry): void {\n    if (this.buffer.length < this.maxSize) {\n      this.buffer.push(entry);\n    } else {\n      this.buffer[this.pointer] = entry;\n      this.pointer = (this.pointer + 1) % this.maxSize;\n    }\n  }\n\n  getRecent(count: number = 100): LogEntry[] {\n    const entries = [...this.buffer];\n    return entries.slice(-count);\n  }\n\n  clear(): void {\n    this.buffer = [];\n    this.pointer = 0;\n  }\n\n  getStats(): { totalLogged: number; currentSize: number } {\n    return {\n      totalLogged: this.buffer.length + (this.pointer > 0 ? this.maxSize : 0),\n      currentSize: this.buffer.length\n    };\n  }\n}\n\nclass Logger {\n  private static instance: Logger;\n  private buffer: CircularLogBuffer;\n  private currentLevel: LogLevel = LogLevel.INFO;\n  private isDevelopment: boolean;\n  private logToConsole: boolean = true;\n  private rateLimits: Map<string, { count: number; resetTime: number }> = new Map();\n\n  private constructor() {\n    this.buffer = new CircularLogBuffer(1000);\n    this.isDevelopment = process.env.NODE_ENV === 'development';\n    \n    // In production, default to less verbose logging\n    if (!this.isDevelopment) {\n      this.currentLevel = LogLevel.WARN;\n    }\n\n    // Periodically clean up rate limit map\n    setInterval(() => {\n      const now = Date.now();\n      for (const [key, limit] of this.rateLimits.entries()) {\n        if (limit.resetTime < now) {\n          this.rateLimits.delete(key);\n        }\n      }\n    }, 60000); // Every minute\n  }\n\n  static getInstance(): Logger {\n    if (!Logger.instance) {\n      Logger.instance = new Logger();\n    }\n    return Logger.instance;\n  }\n\n  setLevel(level: LogLevel): void {\n    this.currentLevel = level;\n  }\n\n  setConsoleOutput(enabled: boolean): void {\n    this.logToConsole = enabled;\n  }\n\n  private shouldLog(level: LogLevel): boolean {\n    return level <= this.currentLevel;\n  }\n\n  private checkRateLimit(key: string, maxPerMinute: number = 60): boolean {\n    const now = Date.now();\n    const limit = this.rateLimits.get(key);\n\n    if (!limit || limit.resetTime < now) {\n      this.rateLimits.set(key, {\n        count: 1,\n        resetTime: now + 60000 // 1 minute\n      });\n      return true;\n    }\n\n    if (limit.count >= maxPerMinute) {\n      return false;\n    }\n\n    limit.count++;\n    return true;\n  }\n\n  private log(level: LogLevel, message: string, context?: any, rateKey?: string): void {\n    if (!this.shouldLog(level)) return;\n\n    // Apply rate limiting if key provided\n    if (rateKey && !this.checkRateLimit(rateKey)) {\n      return;\n    }\n\n    const entry: LogEntry = {\n      timestamp: new Date(),\n      level,\n      message,\n      context\n    };\n\n    this.buffer.add(entry);\n\n    if (this.logToConsole) {\n      const levelStr = LogLevel[level];\n      const prefix = `[${levelStr}] ${entry.timestamp.toISOString()}:`;\n\n      switch (level) {\n        case LogLevel.ERROR:\n          console.error(prefix, message, context || '');\n          break;\n        case LogLevel.WARN:\n          console.warn(prefix, message, context || '');\n          break;\n        case LogLevel.INFO:\n          console.info(prefix, message, context || '');\n          break;\n        case LogLevel.DEBUG:\n          if (this.isDevelopment) {\n            console.log(prefix, message, context || '');\n          }\n          break;\n      }\n    }\n  }\n\n  error(message: string, context?: any, rateKey?: string): void {\n    this.log(LogLevel.ERROR, message, context, rateKey);\n  }\n\n  warn(message: string, context?: any, rateKey?: string): void {\n    this.log(LogLevel.WARN, message, context, rateKey);\n  }\n\n  info(message: string, context?: any, rateKey?: string): void {\n    this.log(LogLevel.INFO, message, context, rateKey);\n  }\n\n  debug(message: string, context?: any, rateKey?: string): void {\n    this.log(LogLevel.DEBUG, message, context, rateKey);\n  }\n\n  getRecentLogs(count: number = 100): LogEntry[] {\n    return this.buffer.getRecent(count);\n  }\n\n  getStats() {\n    return {\n      ...this.buffer.getStats(),\n      currentLevel: this.currentLevel,\n      currentLevelName: LogLevel[this.currentLevel],\n      rateLimitedKeys: this.rateLimits.size\n    };\n  }\n\n  clearLogs(): void {\n    this.buffer.clear();\n  }\n}\n\n// Export singleton instance\nexport const logger = Logger.getInstance();\n\n// Export convenience functions\nexport const logError = (message: string, context?: any, rateKey?: string) => \n  logger.error(message, context, rateKey);\n\nexport const logWarn = (message: string, context?: any, rateKey?: string) => \n  logger.warn(message, context, rateKey);\n\nexport const logInfo = (message: string, context?: any, rateKey?: string) => \n  logger.info(message, context, rateKey);\n\nexport const logDebug = (message: string, context?: any, rateKey?: string) => \n  logger.debug(message, context, rateKey);",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/lib/utils/mgrsConverter.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'MGRS_LETTERS' is assigned a value but never used. Allowed unused vars must match /^_/u.",
				"line": 7,
				"column": 7,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 7,
				"endColumn": 19
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'MGRSComponents' is defined but never used. Allowed unused vars must match /^_/u.",
				"line": 9,
				"column": 11,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 9,
				"endColumn": 25
			}
		],
		"suppressedMessages": [],
		"errorCount": 2,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "// MGRS (Military Grid Reference System) converter\n// Converts lat/lon to 8-digit MGRS format (100m precision)\n\n// Manual MGRS conversion implementation since package install is having issues\n// This provides the core functionality needed for the tactical map\n\nconst MGRS_LETTERS = 'ABCDEFGHJKLMNPQRSTUVWXYZ'; // Note: I and O are omitted\n\ninterface MGRSComponents {\n  zone: number;\n  band: string;\n  square1: string;\n  square2: string;\n  easting: string;\n  northing: string;\n}\n\n/**\n * Convert latitude/longitude to 8-digit MGRS\n * Format: 31U FT 1234 5678 (100m precision)\n */\nexport function latLonToMGRS(lat: number, lon: number): string {\n  try {\n    // Get UTM zone\n    const zone = Math.floor((lon + 180) / 6) + 1;\n    \n    // Get latitude band\n    const band = getLatitudeBand(lat);\n    \n    // Convert to UTM coordinates\n    const utm = latLonToUTM(lat, lon, zone);\n    \n    // Get 100km square identifier\n    const squares = get100kmSquare(zone, utm.easting, utm.northing, lat);\n    \n    // Format easting and northing to 4 digits each (100m precision)\n    const eastingStr = Math.floor(utm.easting % 100000 / 100).toString().padStart(4, '0');\n    const northingStr = Math.floor(utm.northing % 100000 / 100).toString().padStart(4, '0');\n    \n    // Format: 31U FT 1234 5678\n    return `${zone}${band} ${squares} ${eastingStr} ${northingStr}`;\n  } catch (error) {\n    console.error('Error converting to MGRS:', error);\n    return 'Invalid';\n  }\n}\n\n/**\n * Get latitude band letter\n */\nfunction getLatitudeBand(lat: number): string {\n  // MGRS latitude bands from C to X (excluding I and O)\n  const bands = 'CDEFGHJKLMNPQRSTUVWX';\n  \n  if (lat < -80) return 'Invalid';\n  if (lat >= 84) return 'Invalid';\n  \n  // Special case for Norway\n  if (lat >= 72 && lat < 84) return 'X';\n  \n  // Calculate band index\n  const index = Math.floor((lat + 80) / 8);\n  return bands[index] || 'Invalid';\n}\n\n/**\n * Convert lat/lon to UTM coordinates\n */\nfunction latLonToUTM(lat: number, lon: number, zone: number): { easting: number; northing: number } {\n  const a = 6378137.0; // WGS84 major axis\n  const f = 1 / 298.257223563; // WGS84 flattening\n  const k0 = 0.9996; // UTM scale factor\n  \n  const latRad = lat * Math.PI / 180;\n  const lonRad = lon * Math.PI / 180;\n  \n  // Calculate meridian\n  const lonOrigin = (zone - 1) * 6 - 180 + 3;\n  const lonOriginRad = lonOrigin * Math.PI / 180;\n  \n  const e = Math.sqrt(2 * f - f * f);\n  const e2 = e * e;\n  const e4 = e2 * e2;\n  const e6 = e4 * e2;\n  \n  const N = a / Math.sqrt(1 - e2 * Math.sin(latRad) * Math.sin(latRad));\n  const T = Math.tan(latRad) * Math.tan(latRad);\n  const C = e2 * Math.cos(latRad) * Math.cos(latRad) / (1 - e2);\n  const A = Math.cos(latRad) * (lonRad - lonOriginRad);\n  \n  const M = a * ((1 - e2 / 4 - 3 * e4 / 64 - 5 * e6 / 256) * latRad\n    - (3 * e2 / 8 + 3 * e4 / 32 + 45 * e6 / 1024) * Math.sin(2 * latRad)\n    + (15 * e4 / 256 + 45 * e6 / 1024) * Math.sin(4 * latRad)\n    - (35 * e6 / 3072) * Math.sin(6 * latRad));\n  \n  const easting = k0 * N * (A + (1 - T + C) * A * A * A / 6\n    + (5 - 18 * T + T * T + 72 * C - 58 * e2) * A * A * A * A * A / 120) + 500000;\n  \n  let northing = k0 * (M + N * Math.tan(latRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24\n    + (61 - 58 * T + T * T + 600 * C - 330 * e2) * A * A * A * A * A * A / 720));\n  \n  // Adjust for southern hemisphere\n  if (lat < 0) {\n    northing += 10000000;\n  }\n  \n  return { easting, northing };\n}\n\n/**\n * Get 100km square identifier\n */\nfunction get100kmSquare(zone: number, easting: number, northing: number, lat: number): string {\n  // Simplified 100km square calculation\n  // This is a basic implementation - full MGRS requires more complex logic\n  \n  const set = ((zone - 1) % 6) + 1;\n  let eastingIndex = Math.floor(easting / 100000);\n  let northingIndex = Math.floor((northing % 2000000) / 100000);\n  \n  // Column letters repeat every 3 zones\n  const colLetters = 'ABCDEFGHJKLMNPQRSTUV';\n  const col = (eastingIndex + (set - 1) * 8 - 1) % 24;\n  \n  // Row letters\n  const rowLetters = lat >= 0 ? 'ABCDEFGHJKLMNPQRSTUV' : 'VWXYZABCDEFGHJKLMNPQRSTU';\n  const row = northingIndex % 20;\n  \n  return colLetters[col] + rowLetters[row];\n}\n\n/**\n * Format MGRS for display with proper spacing\n */\nexport function formatMGRS(mgrs: string): string {\n  // Ensure proper spacing: 31U FT 1234 5678\n  return mgrs.replace(/(\\d+[A-Z])\\s*([A-Z]{2})\\s*(\\d{4})\\s*(\\d{4})/, '$1 $2 $3 $4');\n}\n\n/**\n * Get precision description for MGRS\n */\nexport function getMGRSPrecision(digits: number): string {\n  switch (digits) {\n    case 0: return '100km';\n    case 2: return '10km';\n    case 4: return '1km';\n    case 6: return '100m';\n    case 8: return '10m';\n    case 10: return '1m';\n    default: return 'Unknown';\n  }\n}// Test comment\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/+layout.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/+page.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/db/cleanup/+server.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/await-thenable",
				"severity": 2,
				"message": "Unexpected `await` of a non-Promise (non-\"Thenable\") value.",
				"line": 60,
				"column": 30,
				"nodeType": "AwaitExpression",
				"messageId": "await",
				"endLine": 60,
				"endColumn": 63,
				"suggestions": [
					{
						"messageId": "removeAwait",
						"fix": { "range": [1760, 1765], "text": "" },
						"desc": "Remove unnecessary `await`."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/await-thenable",
				"severity": 2,
				"message": "Unexpected `await` of a non-Promise (non-\"Thenable\") value.",
				"line": 111,
				"column": 9,
				"nodeType": "AwaitExpression",
				"messageId": "await",
				"endLine": 111,
				"endColumn": 46,
				"suggestions": [
					{
						"messageId": "removeAwait",
						"fix": { "range": [3054, 3059], "text": "" },
						"desc": "Remove unnecessary `await`."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 2,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { json } from '@sveltejs/kit';\nimport type { RequestHandler } from './$types';\nimport { getRFDatabase } from '$lib/server/db/database';\nimport { DatabaseCleanupService } from '$lib/server/db/cleanupService';\nimport { DatabaseOptimizer } from '$lib/server/db/dbOptimizer';\n\nlet optimizer: DatabaseOptimizer | null = null;\n\n// Get cleanup service from database instance\nfunction getCleanupService(): DatabaseCleanupService {\n  const db = getRFDatabase();\n  let cleanupService = db.getCleanupService();\n  \n  if (!cleanupService) {\n    throw new Error('Cleanup service not initialized');\n  }\n  \n  return cleanupService;\n}\n\n// Initialize optimizer\nfunction initializeOptimizer() {\n  if (!optimizer) {\n    const db = getRFDatabase();\n    optimizer = new DatabaseOptimizer(db['db'], {\n      cacheSize: -2000,                          // 2MB cache for Pi\n      walMode: true,\n      synchronous: 'NORMAL',\n      mmapSize: 30000000,                        // 30MB memory map\n      memoryLimit: 50 * 1024 * 1024             // 50MB memory limit\n    });\n  }\n}\n\nexport const GET: RequestHandler = async ({ url }) => {\n  try {\n    initializeOptimizer();\n    const cleanupService = getCleanupService();\n    \n    const action = url.searchParams.get('action') || 'status';\n    \n    switch (action) {\n      case 'status': {\n        // Get cleanup statistics\n        const stats = cleanupService.getStats();\n        const growth = cleanupService.getGrowthTrends(24);\n        const health = optimizer?.getHealthReport();\n        \n        return json({\n          success: true,\n          stats,\n          growth,\n          health,\n          timestamp: Date.now()\n        });\n      }\n        \n      case 'manual': {\n        // Run manual cleanup\n        const cleanupStats = await cleanupService.runCleanup();\n        \n        return json({\n          success: true,\n          message: 'Manual cleanup completed',\n          stats: cleanupStats,\n          timestamp: Date.now()\n        });\n      }\n        \n      case 'vacuum': {\n        // Run VACUUM\n        const vacuumResult = cleanupService.vacuum();\n        \n        return json({\n          success: true,\n          message: 'VACUUM completed',\n          result: vacuumResult,\n          timestamp: Date.now()\n        });\n      }\n        \n      case 'analyze': {\n        // Update statistics\n        cleanupService.analyze();\n        optimizer?.analyze();\n        \n        return json({\n          success: true,\n          message: 'Database statistics updated',\n          timestamp: Date.now()\n        });\n      }\n        \n      case 'optimize': {\n        // Get optimization suggestions\n        const indexAnalysis = optimizer?.getIndexAnalysis();\n        const slowQueries = optimizer?.getSlowQueries();\n        const pragmas = optimizer?.getPragmaSettings();\n        \n        return json({\n          success: true,\n          indexAnalysis,\n          slowQueries,\n          pragmas,\n          timestamp: Date.now()\n        });\n      }\n        \n      case 'aggregate': {\n        // Run aggregation manually\n        await cleanupService.runAggregation();\n        \n        return json({\n          success: true,\n          message: 'Aggregation completed',\n          timestamp: Date.now()\n        });\n      }\n        \n      case 'export': {\n        // Export aggregated data\n        const days = parseInt(url.searchParams.get('days') || '7');\n        const endTime = Date.now();\n        const startTime = endTime - (days * 24 * 60 * 60 * 1000);\n        \n        const exportData = cleanupService.exportAggregatedData(startTime, endTime);\n        \n        return json({\n          success: true,\n          data: exportData,\n          period: { startTime, endTime, days },\n          timestamp: Date.now()\n        });\n      }\n        \n      default:\n        return json({\n          success: false,\n          error: 'Invalid action'\n        }, { status: 400 });\n    }\n  } catch (error: unknown) {\n    console.error('Database cleanup error:', error);\n    return json({\n      success: false,\n      error: error instanceof Error ? error.message : 'Database cleanup failed'\n    }, { status: 500 });\n  }\n};\n\nexport const POST: RequestHandler = async ({ request }) => {\n  try {\n    initializeOptimizer();\n    const cleanupService = getCleanupService();\n    \n    const body = await request.json() as Record<string, unknown>;\n    const { action, config } = body;\n    \n    switch (action) {\n      case 'configure':\n        // Update cleanup configuration\n        if (config) {\n          // Note: Configuration update not supported through API\n          // Cleanup service is initialized with database instance\n          return json({\n            success: false,\n            message: 'Configuration must be updated in database initialization',\n            timestamp: Date.now()\n          });\n        }\n        \n        return json({\n          success: true,\n          message: 'Configuration updated',\n          timestamp: Date.now()\n        });\n        \n      case 'optimize-workload': {\n        // Optimize for specific workload\n        const workload = body.workload as 'read_heavy' | 'write_heavy' | 'mixed';\n        optimizer?.optimizeForWorkload(workload);\n        \n        return json({\n          success: true,\n          message: `Optimized for ${workload} workload`,\n          timestamp: Date.now()\n        });\n      }\n        \n      case 'cleanup-aggregated': {\n        // Cleanup old aggregated data\n        const daysToKeep = (body.daysToKeep as number) || 30;\n        cleanupService.cleanupAggregatedData(daysToKeep);\n        \n        return json({\n          success: true,\n          message: `Cleaned up aggregated data older than ${daysToKeep} days`,\n          timestamp: Date.now()\n        });\n      }\n        \n      default:\n        return json({\n          success: false,\n          error: 'Invalid action'\n        }, { status: 400 });\n    }\n  } catch (error: unknown) {\n    console.error('Database cleanup error:', error);\n    return json({\n      success: false,\n      error: error instanceof Error ? error.message : 'Database cleanup failed'\n    }, { status: 500 });\n  }\n};\n\n// Note: Cleanup service lifecycle is managed by the database instance",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/devices/area/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/gps/position/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/hackrf/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/hackrf/[...path]/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/hackrf/cleanup/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/hackrf/cycle-status/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/hackrf/data-stream/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/hackrf/debug-start/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/hackrf/emergency-stop/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/hackrf/force-cleanup/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/hackrf/health/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/hackrf/reset-state/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/hackrf/start-sweep/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/hackrf/status/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/hackrf/stop-sweep/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/hackrf/test-device/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/hackrf/test-sweep/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/kismet/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/kismet/config/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/kismet/control/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/kismet/devices/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/kismet/devices/list/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/kismet/devices/stats/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/kismet/proxy/[...path]/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/kismet/scripts/execute/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/kismet/scripts/list/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/kismet/service/restart/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/kismet/service/start/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/kismet/service/status/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/kismet/service/stop/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/kismet/ws/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/logs/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/relationships/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/signals/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/signals/batch/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/signals/cleanup/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/signals/statistics/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/system/info/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/system/metrics/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/test-db/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/api/test/+server.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/hackrf/+page.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/hackrfsweep/+page.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/kismet-dashboard/+page.svelte",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 4,
				"column": 16,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 4,
				"endColumn": 19,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [84, 87], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [84, 87], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 5,
				"column": 14,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 5,
				"endColumn": 17,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [109, 112], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [109, 112], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-floating-promises",
				"severity": 2,
				"message": "Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.",
				"line": 11,
				"column": 5,
				"nodeType": "ExpressionStatement",
				"messageId": "floatingVoid",
				"endLine": 11,
				"endColumn": 16,
				"suggestions": [
					{
						"messageId": "floatingFixVoid",
						"fix": { "range": [243, 243], "text": "void " },
						"desc": "Add void operator to ignore."
					},
					{
						"messageId": "floatingFixAwait",
						"fix": { "range": [243, 243], "text": "await " },
						"desc": "Add await operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-misused-promises",
				"severity": 2,
				"message": "Promise returned in function argument where a void return was expected.",
				"line": 12,
				"column": 35,
				"nodeType": "Identifier",
				"messageId": "voidReturnArgument",
				"endLine": 12,
				"endColumn": 43
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 26,
				"column": 9,
				"nodeType": "AssignmentExpression",
				"messageId": "anyAssignment",
				"endLine": 26,
				"endColumn": 42
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 32,
				"column": 9,
				"nodeType": "AssignmentExpression",
				"messageId": "anyAssignment",
				"endLine": 32,
				"endColumn": 38
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'getSignalStrength' is defined but never used. Allowed unused vars must match /^_/u.",
				"line": 43,
				"column": 12,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 43,
				"endColumn": 29
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .total on an `any` value.",
				"line": 90,
				"column": 62,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 90,
				"endColumn": 67
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .byType on an `any` value.",
				"line": 94,
				"column": 63,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 94,
				"endColumn": 69
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .byType on an `any` value.",
				"line": 98,
				"column": 62,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 98,
				"endColumn": 68
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .activeInLast5Min on an `any` value.",
				"line": 102,
				"column": 64,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 102,
				"endColumn": 80
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .mac on an `any` value.",
				"line": 130,
				"column": 27,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 130,
				"endColumn": 30
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .ssid on an `any` value.",
				"line": 133,
				"column": 27,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 133,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .type on an `any` value.",
				"line": 136,
				"column": 71,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 136,
				"endColumn": 75
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .type on an `any` value.",
				"line": 136,
				"column": 129,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 136,
				"endColumn": 133
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .type on an `any` value.",
				"line": 137,
				"column": 29,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 137,
				"endColumn": 33
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .channel on an `any` value.",
				"line": 141,
				"column": 27,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 141,
				"endColumn": 34
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type `any` assigned to a parameter of type `number`.",
				"line": 143,
				"column": 80,
				"nodeType": "MemberExpression",
				"messageId": "unsafeArgument",
				"endLine": 143,
				"endColumn": 93
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .signal on an `any` value.",
				"line": 143,
				"column": 87,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 143,
				"endColumn": 93
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .signal on an `any` value.",
				"line": 144,
				"column": 27,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 144,
				"endColumn": 33
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .signal on an `any` value.",
				"line": 144,
				"column": 46,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 144,
				"endColumn": 52
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 147,
				"column": 20,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 147,
				"endColumn": 47
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .encryptionType on an `any` value.",
				"line": 147,
				"column": 27,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 147,
				"endColumn": 41
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type `any` assigned to a parameter of type `string | number | Date`.",
				"line": 150,
				"column": 29,
				"nodeType": "MemberExpression",
				"messageId": "unsafeArgument",
				"endLine": 150,
				"endColumn": 44
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .lastSeen on an `any` value.",
				"line": 150,
				"column": 36,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 150,
				"endColumn": 44
			}
		],
		"suppressedMessages": [],
		"errorCount": 23,
		"fatalErrorCount": 0,
		"warningCount": 2,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "<script lang=\"ts\">\n  import { onMount, onDestroy } from 'svelte';\n  \n  let devices: any[] = [];\n  let stats: any = null;\n  let isLoading = true;\n  let error = '';\n  let refreshInterval: ReturnType<typeof setInterval>;\n  \n  onMount(() => {\n    loadData();\n    refreshInterval = setInterval(loadData, 5000);\n  });\n  \n  onDestroy(() => {\n    if (refreshInterval) {\n      clearInterval(refreshInterval);\n    }\n  });\n  \n  async function loadData() {\n    try {\n      // Fetch devices\n      const devicesRes = await fetch('/api/kismet/devices');\n      if (devicesRes.ok) {\n        devices = await devicesRes.json();\n      }\n      \n      // Fetch stats\n      const statsRes = await fetch('/api/kismet/devices/stats');\n      if (statsRes.ok) {\n        stats = await statsRes.json();\n      }\n      \n      isLoading = false;\n      error = '';\n    } catch (err) {\n      error = 'Failed to load Kismet data';\n      console.error('Error loading Kismet data:', err);\n    }\n  }\n  \n  function getSignalStrength(signal: number): string {\n    if (signal > -50) return 'Excellent';\n    if (signal > -70) return 'Good';\n    if (signal > -85) return 'Fair';\n    return 'Poor';\n  }\n  \n  function getSignalColor(signal: number): string {\n    if (signal > -50) return 'text-green-500';\n    if (signal > -70) return 'text-yellow-500';\n    if (signal > -85) return 'text-orange-500';\n    return 'text-red-500';\n  }\n</script>\n\n<div class=\"min-h-screen bg-black p-6\">\n  <!-- Header -->\n  <header class=\"mb-8\">\n    <div class=\"flex items-center justify-between\">\n      <div class=\"flex items-center gap-4\">\n        <a href=\"/\" class=\"text-cyan-500 hover:text-cyan-400 transition-colors\">\n          ← Back to Console\n        </a>\n        <h1 class=\"text-2xl font-bold text-white\">Kismet Dashboard</h1>\n      </div>\n      <a href=\"/kismet\" class=\"px-4 py-2 bg-gray-800 hover:bg-gray-700 text-white rounded transition-colors\">\n        Full Kismet UI →\n      </a>\n    </div>\n  </header>\n  \n  {#if error}\n    <div class=\"bg-red-900/20 border border-red-700 rounded-lg p-4 mb-6\">\n      <p class=\"text-red-400\">{error}</p>\n    </div>\n  {/if}\n  \n  {#if isLoading}\n    <div class=\"flex items-center justify-center h-64\">\n      <div class=\"animate-spin rounded-full h-12 w-12 border-b-2 border-cyan-500\"></div>\n    </div>\n  {:else}\n    <!-- Stats Grid -->\n    {#if stats}\n      <div class=\"grid grid-cols-1 md:grid-cols-4 gap-4 mb-8\">\n        <div class=\"bg-gray-900 border border-gray-800 rounded-lg p-4\">\n          <h3 class=\"text-gray-400 text-sm mb-2\">Total Devices</h3>\n          <p class=\"text-2xl font-bold text-cyan-500\">{stats.total}</p>\n        </div>\n        <div class=\"bg-gray-900 border border-gray-800 rounded-lg p-4\">\n          <h3 class=\"text-gray-400 text-sm mb-2\">Access Points</h3>\n          <p class=\"text-2xl font-bold text-green-500\">{stats.byType.AP || 0}</p>\n        </div>\n        <div class=\"bg-gray-900 border border-gray-800 rounded-lg p-4\">\n          <h3 class=\"text-gray-400 text-sm mb-2\">Clients</h3>\n          <p class=\"text-2xl font-bold text-blue-500\">{stats.byType.Client || 0}</p>\n        </div>\n        <div class=\"bg-gray-900 border border-gray-800 rounded-lg p-4\">\n          <h3 class=\"text-gray-400 text-sm mb-2\">Active (5m)</h3>\n          <p class=\"text-2xl font-bold text-yellow-500\">{stats.activeInLast5Min}</p>\n        </div>\n      </div>\n    {/if}\n    \n    <!-- Devices Table -->\n    <div class=\"bg-gray-900 border border-gray-800 rounded-lg overflow-hidden\">\n      <div class=\"px-6 py-4 border-b border-gray-800\">\n        <h2 class=\"text-lg font-semibold text-white\">Detected Devices</h2>\n      </div>\n      \n      <div class=\"overflow-x-auto\">\n        <table class=\"w-full\">\n          <thead>\n            <tr class=\"border-b border-gray-800\">\n              <th class=\"px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider\">MAC Address</th>\n              <th class=\"px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider\">SSID/Name</th>\n              <th class=\"px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider\">Type</th>\n              <th class=\"px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider\">Channel</th>\n              <th class=\"px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider\">Signal</th>\n              <th class=\"px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider\">Encryption</th>\n              <th class=\"px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider\">Last Seen</th>\n            </tr>\n          </thead>\n          <tbody class=\"divide-y divide-gray-800\">\n            {#each devices as device}\n              <tr class=\"hover:bg-gray-800/50 transition-colors\">\n                <td class=\"px-6 py-4 whitespace-nowrap text-sm font-mono text-gray-300\">\n                  {device.mac}\n                </td>\n                <td class=\"px-6 py-4 whitespace-nowrap text-sm text-gray-300\">\n                  {device.ssid || '-'}\n                </td>\n                <td class=\"px-6 py-4 whitespace-nowrap text-sm\">\n                  <span class=\"px-2 py-1 text-xs rounded-full {device.type === 'AP' ? 'bg-green-900/50 text-green-400' : device.type === 'Client' ? 'bg-blue-900/50 text-blue-400' : 'bg-gray-700 text-gray-400'}\">\n                    {device.type}\n                  </span>\n                </td>\n                <td class=\"px-6 py-4 whitespace-nowrap text-sm text-gray-300\">\n                  {device.channel || '-'}\n                </td>\n                <td class=\"px-6 py-4 whitespace-nowrap text-sm {getSignalColor(device.signal)}\">\n                  {device.signal ? `${device.signal} dBm` : '-'}\n                </td>\n                <td class=\"px-6 py-4 whitespace-nowrap text-sm text-gray-300\">\n                  {device.encryptionType?.join(', ') || 'Open'}\n                </td>\n                <td class=\"px-6 py-4 whitespace-nowrap text-sm text-gray-400\">\n                  {new Date(device.lastSeen).toLocaleTimeString()}\n                </td>\n              </tr>\n            {/each}\n          </tbody>\n        </table>\n      </div>\n    </div>\n  {/if}\n</div>",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/kismet/+page.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/tactical-map-simple/+page.svelte",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 267,
				"column": 7,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 267,
				"endColumn": 32
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 267,
				"column": 15,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 267,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [7901, 7904], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [7901, 7904], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .removeLayer on an `any` value.",
				"line": 267,
				"column": 21,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 267,
				"endColumn": 32
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 277,
				"column": 7,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 277,
				"endColumn": 32
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 277,
				"column": 15,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 277,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [8221, 8224], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [8221, 8224], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .removeLayer on an `any` value.",
				"line": 277,
				"column": 21,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 277,
				"endColumn": 32
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 377,
				"column": 7,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 377,
				"endColumn": 42
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 377,
				"column": 22,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 377,
				"endColumn": 25,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [11217, 11220], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [11217, 11220], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .setPopupContent on an `any` value.",
				"line": 377,
				"column": 27,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 377,
				"endColumn": 42
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 378,
				"column": 7,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 378,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 378,
				"column": 22,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 378,
				"endColumn": 25,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [11320, 11323], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [11320, 11323], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .openPopup on an `any` value.",
				"line": 378,
				"column": 27,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 378,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 488,
				"column": 5,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 488,
				"endColumn": 40
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 488,
				"column": 20,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 488,
				"endColumn": 23,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [15959, 15962], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [15959, 15962], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .setPopupContent on an `any` value.",
				"line": 488,
				"column": 25,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 488,
				"endColumn": 40
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 489,
				"column": 5,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 489,
				"endColumn": 34
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 489,
				"column": 20,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 489,
				"endColumn": 23,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [16014, 16017], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [16014, 16017], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .openPopup on an `any` value.",
				"line": 489,
				"column": 25,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 489,
				"endColumn": 34
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 605,
				"column": 13,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 605,
				"endColumn": 42
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 605,
				"column": 28,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 605,
				"endColumn": 31,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [21243, 21246], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [21243, 21246], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .setLatLng on an `any` value.",
				"line": 605,
				"column": 33,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 605,
				"endColumn": 42
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 608,
				"column": 19,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 613,
				"endColumn": 15
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 608,
				"column": 30,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 608,
				"endColumn": 48
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 608,
				"column": 36,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 608,
				"endColumn": 39,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [21410, 21413], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [21410, 21413], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .divIcon on an `any` value.",
				"line": 608,
				"column": 41,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 608,
				"endColumn": 48
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 614,
				"column": 13,
				"nodeType": "AssignmentExpression",
				"messageId": "anyAssignment",
				"endLine": 614,
				"endColumn": 112
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 614,
				"column": 26,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 614,
				"endColumn": 107
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 614,
				"column": 26,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 614,
				"endColumn": 43
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 614,
				"column": 32,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 614,
				"endColumn": 35,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [21716, 21719], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [21716, 21719], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .marker on an `any` value.",
				"line": 614,
				"column": 37,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 614,
				"endColumn": 43
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 614,
				"column": 84,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 614,
				"endColumn": 98
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .addTo on an `any` value.",
				"line": 614,
				"column": 102,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 614,
				"endColumn": 107
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-member-access').",
				"line": 617,
				"column": 13,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [21932, 21976], "text": "" }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-call' or '@typescript-eslint/no-unsafe-member-access').",
				"line": 623,
				"column": 13,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [22143, 22248], "text": " " }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-call' or '@typescript-eslint/no-unsafe-member-access').",
				"line": 631,
				"column": 13,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [22461, 22566], "text": " " }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-call' or '@typescript-eslint/no-unsafe-member-access').",
				"line": 637,
				"column": 13,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [22747, 22852], "text": " " }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-call' or '@typescript-eslint/no-unsafe-member-access').",
				"line": 639,
				"column": 13,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [22941, 23046], "text": " " }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-assignment', '@typescript-eslint/no-unsafe-call', or '@typescript-eslint/no-unsafe-member-access').",
				"line": 642,
				"column": 13,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [23144, 23290], "text": " " }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-member-access').",
				"line": 649,
				"column": 13,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [23538, 23608], "text": " " }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-assignment').",
				"line": 710,
				"column": 11,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [25406, 25473], "text": " " }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-assignment', '@typescript-eslint/no-unsafe-call', or '@typescript-eslint/no-unsafe-member-access').",
				"line": 718,
				"column": 13,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [25795, 25941], "text": " " }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-assignment', '@typescript-eslint/no-unsafe-call', or '@typescript-eslint/no-unsafe-member-access').",
				"line": 720,
				"column": 15,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [26074, 26220], "text": " " }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-call' or '@typescript-eslint/no-unsafe-member-access').",
				"line": 770,
				"column": 13,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [28658, 28763], "text": " " }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-member-access').",
				"line": 778,
				"column": 13,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [29047, 29091], "text": "" }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-call' or '@typescript-eslint/no-unsafe-member-access').",
				"line": 784,
				"column": 13,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [29329, 29434], "text": " " }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-member-access').",
				"line": 792,
				"column": 13,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [29811, 29855], "text": "" }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-member-access').",
				"line": 841,
				"column": 13,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [32339, 32383], "text": "" }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-member-access').",
				"line": 843,
				"column": 15,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [32499, 32543], "text": "" }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-call' or '@typescript-eslint/no-unsafe-member-access').",
				"line": 859,
				"column": 13,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [33235, 33340], "text": " " }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-member-access').",
				"line": 920,
				"column": 9,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [35502, 35546], "text": "" }
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type error typed assigned to a parameter of type `LeafletMarker`.",
				"line": 991,
				"column": 37,
				"nodeType": "Identifier",
				"messageId": "unsafeArgument",
				"endLine": 991,
				"endColumn": 43
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-assignment').",
				"line": 999,
				"column": 9,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [38933, 39000], "text": " " }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-member-access').",
				"line": 1002,
				"column": 11,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [39146, 39190], "text": "" }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-member-access').",
				"line": 1009,
				"column": 11,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [39470, 39514], "text": "" }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-call' or '@typescript-eslint/no-unsafe-member-access').",
				"line": 1011,
				"column": 13,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [39563, 39668], "text": " " }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-member-access').",
				"line": 1065,
				"column": 11,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [42058, 42102], "text": "" }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-member-access').",
				"line": 1067,
				"column": 13,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [42214, 42258], "text": "" }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-assignment').",
				"line": 1087,
				"column": 9,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [42969, 43036], "text": " " }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-call' or '@typescript-eslint/no-unsafe-member-access').",
				"line": 1090,
				"column": 11,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [43115, 43220], "text": " " }
			},
			{
				"ruleId": null,
				"message": "Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unsafe-member-access').",
				"line": 1158,
				"column": 7,
				"severity": 1,
				"nodeType": null,
				"fix": { "range": [45332, 45376], "text": "" }
			}
		],
		"suppressedMessages": [
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 568,
				"column": 13,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 568,
				"endColumn": 43,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .success on an `any` value.",
				"line": 571,
				"column": 18,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 571,
				"endColumn": 25,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .data on an `any` value.",
				"line": 571,
				"column": 36,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 571,
				"endColumn": 40,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 575,
				"column": 11,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 575,
				"endColumn": 36,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .data on an `any` value.",
				"line": 575,
				"column": 23,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 575,
				"endColumn": 27,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 577,
				"column": 11,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 577,
				"endColumn": 37,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .data on an `any` value.",
				"line": 577,
				"column": 23,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 577,
				"endColumn": 27,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 580,
				"column": 9,
				"nodeType": "AssignmentExpression",
				"messageId": "anyAssignment",
				"endLine": 580,
				"endColumn": 40,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .data on an `any` value.",
				"line": 580,
				"column": 27,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 580,
				"endColumn": 31,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 582,
				"column": 9,
				"nodeType": "AssignmentExpression",
				"messageId": "anyAssignment",
				"endLine": 582,
				"endColumn": 49,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .data on an `any` value.",
				"line": 582,
				"column": 29,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 582,
				"endColumn": 33,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 584,
				"column": 15,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 584,
				"endColumn": 36,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .data on an `any` value.",
				"line": 584,
				"column": 28,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 584,
				"endColumn": 32,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 618,
				"column": 13,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 618,
				"endColumn": 26,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "no-console",
				"severity": 1,
				"message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
				"line": 665,
				"column": 5,
				"nodeType": "MemberExpression",
				"messageId": "limited",
				"endLine": 665,
				"endColumn": 16,
				"suggestions": [
					{
						"fix": { "range": [23944, 23983], "text": "" },
						"messageId": "removeConsole",
						"data": { "propertyName": "log" },
						"desc": "Remove the console.log()."
					}
				],
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "no-console",
				"severity": 1,
				"message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
				"line": 681,
				"column": 5,
				"nodeType": "MemberExpression",
				"messageId": "limited",
				"endLine": 681,
				"endColumn": 16,
				"suggestions": [
					{
						"fix": { "range": [24369, 24413], "text": "" },
						"messageId": "removeConsole",
						"data": { "propertyName": "log" },
						"desc": "Remove the console.log()."
					}
				],
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 700,
				"column": 15,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 700,
				"endColumn": 43,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an `any` value.",
				"line": 704,
				"column": 15,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 704,
				"endColumn": 37,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .devices on an `any` value.",
				"line": 704,
				"column": 30,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 704,
				"endColumn": 37,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 706,
				"column": 9,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 706,
				"endColumn": 24,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .forEach on an `any` value.",
				"line": 706,
				"column": 17,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 706,
				"endColumn": 24,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 779,
				"column": 13,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 779,
				"endColumn": 22,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 781,
				"column": 15,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 781,
				"endColumn": 29,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .openPopup on an `any` value.",
				"line": 781,
				"column": 20,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 781,
				"endColumn": 29,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 793,
				"column": 13,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 793,
				"endColumn": 27,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 842,
				"column": 17,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 842,
				"endColumn": 35,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 844,
				"column": 15,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 844,
				"endColumn": 37,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 847,
				"column": 15,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 847,
				"endColumn": 43,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 847,
				"column": 15,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 847,
				"endColumn": 30,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .setContent on an `error` typed value.",
				"line": 847,
				"column": 33,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 847,
				"endColumn": 43,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .devices on an `any` value.",
				"line": 858,
				"column": 22,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 858,
				"endColumn": 29,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 921,
				"column": 15,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 928,
				"endColumn": 11,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 921,
				"column": 24,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 921,
				"endColumn": 38,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 972,
				"column": 9,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 972,
				"endColumn": 25,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .bindPopup on an `error` typed value.",
				"line": 972,
				"column": 16,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 972,
				"endColumn": 25,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 984,
				"column": 9,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 984,
				"endColumn": 18,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .on on an `error` typed value.",
				"line": 984,
				"column": 16,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 984,
				"endColumn": 18,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `any` typed value.",
				"line": 986,
				"column": 11,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 986,
				"endColumn": 25,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .openPopup on an `any` value.",
				"line": 986,
				"column": 16,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 986,
				"endColumn": 25,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 990,
				"column": 9,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 990,
				"endColumn": 21,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .addTo on an `error` typed value.",
				"line": 990,
				"column": 16,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 990,
				"endColumn": 21,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 1003,
				"column": 11,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 1003,
				"endColumn": 26,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 1010,
				"column": 16,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 1010,
				"endColumn": 31,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 1066,
				"column": 15,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 1066,
				"endColumn": 33,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 1068,
				"column": 13,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 1068,
				"endColumn": 35,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 1072,
				"column": 13,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 1072,
				"endColumn": 41,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 1072,
				"column": 13,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 1072,
				"endColumn": 28,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .setContent on an `error` typed value.",
				"line": 1072,
				"column": 31,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 1072,
				"endColumn": 41,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type error typed assigned to a parameter of type `string | number | Timeout | undefined`.",
				"line": 1114,
				"column": 20,
				"nodeType": "MemberExpression",
				"messageId": "unsafeArgument",
				"endLine": 1114,
				"endColumn": 47,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 1159,
				"column": 7,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 1159,
				"endColumn": 17,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			}
		],
		"errorCount": 24,
		"fatalErrorCount": 0,
		"warningCount": 36,
		"fixableErrorCount": 0,
		"fixableWarningCount": 27,
		"source": "<script lang=\"ts\">\n  import { onMount, onDestroy } from 'svelte';\n  import { hackrfAPI } from '$lib/services/hackrf/api';\n  import { spectrumData } from '$lib/stores/hackrf';\n  import { SignalAggregator } from './SignalAggregator';\n  import { detectCountry, formatCoordinates } from '$lib/utils/countryDetector';\n  import { latLonToMGRS } from '$lib/utils/mgrsConverter';\n  // Define SystemInfo interface to match the API response\n  interface SystemInfo {\n    hostname: string;\n    ip: string;\n    wifiInterfaces: Array<{\n      name: string;\n      ip: string;\n      mac: string;\n    }>;\n    cpu: {\n      usage: number;\n      model: string;\n      cores: number;\n    };\n    memory: {\n      total: number;\n      used: number;\n      free: number;\n      percentage: number;\n    };\n    storage: {\n      total: number;\n      used: number;\n      free: number;\n      percentage: number;\n    };\n    temperature: number;\n    uptime: number;\n    battery?: {\n      level: number;\n      charging: boolean;\n    };\n  }\n  import type { KismetDevice } from '$lib/types/kismet';\n  \n  // Import Leaflet only on client side\n  // TypeScript interfaces for Leaflet\n  interface LeafletIcon {\n    Default: {\n      prototype: { _getIconUrl?: unknown };\n      mergeOptions: (options: Record<string, string>) => void;\n    };\n  }\n\n  interface LeafletLibrary {\n    map: (container: HTMLElement) => LeafletMap;\n    tileLayer: (url: string, options?: Record<string, unknown>) => LeafletTileLayer;\n    marker: (latlng: [number, number], options?: Record<string, unknown>) => LeafletMarker;\n    circle: (latlng: [number, number], options?: Record<string, unknown>) => LeafletCircle;\n    divIcon: (options: Record<string, unknown>) => unknown;\n    Icon: LeafletIcon;\n  }\n\n  interface LeafletMap {\n    setView: (center: [number, number], zoom: number) => LeafletMap;\n    attributionControl: {\n      setPrefix: (prefix: string) => void;\n    };\n    addLayer: (layer: LeafletLayer) => void;\n    removeLayer: (layer: LeafletLayer) => void;\n    flyTo: (center: [number, number], zoom: number) => void;\n    getZoom: () => number;\n    getBounds: () => unknown;\n    on: (event: string, handler: (e: LeafletEvent) => void) => void;\n    off: (event: string, handler?: (e: LeafletEvent) => void) => void;\n  }\n\n  interface LeafletTileLayer extends LeafletLayer {\n    addTo: (map: LeafletMap) => LeafletTileLayer;\n  }\n\n  interface LeafletMarker extends LeafletLayer {\n    addTo: (map: LeafletMap) => LeafletMarker;\n    setLatLng: (latlng: [number, number]) => LeafletMarker;\n    remove: () => void;\n    bindPopup: (content: string) => LeafletMarker;\n    openPopup: () => LeafletMarker;\n  }\n\n  interface LeafletCircle extends LeafletLayer {\n    addTo: (map: LeafletMap) => LeafletCircle;\n    setLatLng: (latlng: [number, number]) => LeafletCircle;\n    setRadius: (radius: number) => LeafletCircle;\n    remove: () => void;\n  }\n\n  interface LeafletLayer {\n    addTo: (map: LeafletMap) => LeafletLayer;\n    remove: () => void;\n  }\n\n  interface LeafletEvent {\n    latlng: {\n      lat: number;\n      lng: number;\n    };\n  }\n\n  let L: LeafletLibrary;\n  \n  // Simple signal interface\n  interface SimplifiedSignal {\n    id: string;\n    frequency: number;  // MHz\n    power: number;      // dBm\n    timestamp: number;\n    persistence: number; // seconds detected\n    position: {\n      lat: number;\n      lon: number;\n    };\n  }\n  \n  // Component state\n  let map: LeafletMap | null = null;\n  let mapContainer: HTMLDivElement;\n  let searchFrequencies = ['', '', ''];\n  let targetFrequency = 0;\n  let isSearching = false;\n  let kismetWhitelistMAC = '';\n  let connectionStatus = 'Disconnected';\n  let signalCount = 0;\n  let currentSignal: SimplifiedSignal | null = null;\n  \n  // GPS position and status\n  let userPosition = {\n    lat: 0,\n    lon: 0\n  };\n  let hasGPSFix = false;\n  let userMarker: LeafletMarker | null = null;\n  let accuracyCircle: LeafletCircle | null = null;\n  let gpsStatus = 'Requesting GPS...';\n  let accuracy = 0;\n  let satellites = 0;\n  let fixType = 'No';\n  let positionInterval: number | null = null;\n  let currentCountry = { name: 'Unknown', flag: '🌍' };\n  let formattedCoords = { lat: '0.000000°N', lon: '0.000000°E' };\n  let mgrsCoord = 'Invalid';\n  \n  // System info for Pi popup\n  let systemInfo: SystemInfo | null = null;\n  let _systemInfoInterval: number | null = null;\n  \n  // Signal storage\n  const signals = new Map<string, SimplifiedSignal>();\n  const signalMarkers = new Map<string, LeafletMarker>();\n  const aggregator = new SignalAggregator();\n  \n  // Kismet device storage\n  const kismetDevices = new Map<string, KismetDevice>();\n  const kismetMarkers = new Map<string, LeafletMarker>();\n  let kismetInterval: number | null = null;\n  let kismetDeviceCount = 0; // Reactive counter for Kismet devices\n  let whitelistedMACs = new Set<string>(); // Store whitelisted MAC addresses\n  let whitelistedDeviceCount = 0; // Reactive counter for whitelisted devices\n  \n  // Signal strength distribution\n  let signalDistribution = {\n    veryStrong: 0,  // > -50 dBm\n    strong: 0,      // -50 to -60 dBm\n    good: 0,        // -60 to -70 dBm\n    fair: 0,        // -70 to -80 dBm\n    weak: 0         // < -80 dBm\n  };\n  \n  // Device type distribution\n  let deviceTypeDistribution = {\n    ap: 0,\n    client: 0,\n    unknown: 0\n  };\n  \n  // Subscriptions\n  let spectrumUnsubscribe: (() => void) | null = null;\n  let updateInterval: number | null = null;\n  \n  // Constants\n  const _MAX_SIGNALS_PER_FREQUENCY = 1; // Maximum 1 signal per unique frequency\n  const UPDATE_RATE = 500; // 2Hz update rate\n  \n  // Initialize map\n  function initializeMap() {\n    if (!mapContainer || map || !hasGPSFix || !L) return;\n    \n    map = L.map(mapContainer).setView([userPosition.lat, userPosition.lon], 15);\n    \n    // Add map tiles\n    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n      attribution: '',  // Remove attribution text\n      maxZoom: 18\n    }).addTo(map);\n    \n    // Remove Leaflet attribution control\n    map.attributionControl.setPrefix('');\n  }\n  \n  // Handle frequency search\n  function handleSearch() {\n    // Get all valid frequencies\n    const validFreqs = searchFrequencies\n      .map(f => parseFloat(f))\n      .filter(f => !isNaN(f) && f > 0);\n    \n    if (validFreqs.length === 0) {\n      alert('Please enter at least one valid frequency in MHz');\n      return;\n    }\n    \n    // For now, search the first valid frequency\n    // TODO: Implement multi-frequency search\n    targetFrequency = validFreqs[0];\n    isSearching = true;\n    \n    // Clear existing signals but preserve targetFrequency display\n    clearSignals();\n    \n    console.warn(`Searching for signals near ${targetFrequency} MHz`);\n  }\n  \n  // Add MAC to whitelist\n  function addToWhitelist() {\n    if (kismetWhitelistMAC.trim()) {\n      const mac = kismetWhitelistMAC.trim().toUpperCase();\n      console.warn('Adding MAC to whitelist:', mac);\n      whitelistedMACs.add(mac);\n      whitelistedDeviceCount = whitelistedMACs.size;\n      kismetWhitelistMAC = '';\n    }\n  }\n  \n  // Load frequencies function (placeholder for now)\n  function loadFrequencies() {\n    console.warn('Load frequencies clicked - implementation pending');\n    // TODO: Implement frequency loading\n  }\n  \n  // Open spectrum analyzer\n  async function openSpectrumAnalyzer() {\n    // Stop the HackRF sweep if it's running\n    if (isSearching) {\n      console.warn('Stopping HackRF sweep before opening spectrum analyzer...');\n      // Stop HackRF sweep through API\n      try {\n        await fetch('/api/hackrf/stop-sweep', { method: 'POST' });\n      } catch (error) {\n        console.error('Error stopping HackRF sweep:', error);\n      }\n      isSearching = false;\n    }\n    \n    // Navigate to spectrum analyzer\n    window.location.href = '/viewspectrum';\n  }\n  \n  // Clear all signals\n  function clearSignals() {\n    signalMarkers.forEach(marker => {\n      (map as any)?.removeLayer(marker);\n    });\n    signalMarkers.clear();\n    signals.clear();\n    signalCount = 0;\n    // Don't clear currentSignal immediately - let processSignals handle it\n    aggregator.flush(); // Clear the aggregator buffer\n    \n    // Clear Kismet devices\n    kismetMarkers.forEach(marker => {\n      (map as any)?.removeLayer(marker);\n    });\n    kismetMarkers.clear();\n    kismetDevices.clear();\n    kismetDeviceCount = 0;\n    \n    // Reset distributions\n    signalDistribution = {\n      veryStrong: 0,\n      strong: 0,\n      good: 0,\n      fair: 0,\n      weak: 0\n    };\n    deviceTypeDistribution = {\n      ap: 0,\n      client: 0,\n      unknown: 0\n    };\n    \n    // Clear whitelist\n    whitelistedMACs.clear();\n    whitelistedDeviceCount = 0;\n  }\n  \n  // Get signal color based on power\n  function getSignalColor(power: number): string {\n    // Note: Higher dBm (closer to 0) = stronger signal\n    if (power > -50) return '#ff0000';  // Red (very strong)\n    if (power > -60) return '#ff8800';  // Orange (strong)\n    if (power > -70) return '#ffff00';  // Yellow (good)\n    if (power > -80) return '#00ff00';  // Green (fair)\n    return '#0088ff';                   // Blue (weak)\n  }\n  \n  // Update signal and device type distributions\n  function updateDistributions() {\n    // Reset distributions\n    signalDistribution = {\n      veryStrong: 0,\n      strong: 0,\n      good: 0,\n      fair: 0,\n      weak: 0\n    };\n    \n    deviceTypeDistribution = {\n      ap: 0,\n      client: 0,\n      unknown: 0\n    };\n    \n    // Count devices by signal strength and type\n    kismetDevices.forEach(device => {\n      // Signal strength distribution\n      const signalStrength = device.signal?.last_signal || -100;\n      if (signalStrength > -50) signalDistribution.veryStrong++;\n      else if (signalStrength > -60) signalDistribution.strong++;\n      else if (signalStrength > -70) signalDistribution.good++;\n      else if (signalStrength > -80) signalDistribution.fair++;\n      else signalDistribution.weak++;\n      \n      // Device type distribution\n      const type = device.type?.toLowerCase() || '';\n      const manufacturer = device.manufacturer?.toLowerCase() || '';\n      \n      if (type.includes('ap') || type.includes('access') || \n          manufacturer.includes('arris') || manufacturer.includes('router') || \n          manufacturer.includes('gateway')) {\n        deviceTypeDistribution.ap++;\n      } else if (type.includes('client') || type.includes('mobile') || \n                 manufacturer.includes('phone') || manufacturer.includes('smartphone') ||\n                 manufacturer.includes('android') || manufacturer.includes('iphone')) {\n        deviceTypeDistribution.client++;\n      } else {\n        deviceTypeDistribution.unknown++;\n      }\n    });\n  }\n  \n  // Fetch system information\n  async function fetchSystemInfo() {\n    try {\n      const response = await fetch('/api/system/info');\n      if (response.ok) {\n        systemInfo = await response.json() as SystemInfo;\n      }\n    } catch (error) {\n      console.error('Error fetching system info:', error);\n    }\n  }\n  \n  // Show Pi popup with system information\n  async function showPiPopup() {\n    if (!userMarker) return;\n    \n    // Fetch latest system info\n    await fetchSystemInfo();\n    \n    if (!systemInfo) {\n      (userMarker as any).setPopupContent('<div style=\"padding: 10px;\">Loading system info...</div>');\n      (userMarker as any).openPopup();\n      return;\n    }\n    \n    // Format uptime\n    const hours = Math.floor(systemInfo.uptime / 3600);\n    const minutes = Math.floor((systemInfo.uptime % 3600) / 60);\n    const uptimeStr = `${hours}h ${minutes}m`;\n    \n    // Format storage sizes\n    const formatBytes = (bytes: number) => {\n      const gb = bytes / (1024 * 1024 * 1024);\n      return gb.toFixed(1) + ' GB';\n    };\n    \n    // Build WiFi interfaces list\n    let wifiInterfacesHtml = '';\n    const wifiInterfaces = systemInfo.wifiInterfaces || [];\n    if (wifiInterfaces.length > 0) {\n      wifiInterfacesHtml = wifiInterfaces.map(iface => `\n        <tr>\n          <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">${iface.name}:</td>\n          <td style=\"padding: 4px 0; font-family: monospace;\">${iface.ip || 'N/A'}</td>\n        </tr>\n      `).join('');\n    }\n    \n     \n    const popupContent = `\n      <div style=\"font-family: sans-serif; min-width: 250px;\">\n        <h4 style=\"margin: 0 0 8px 0; color: #3b82f6;\">\n          Raspberry Pi System Info\n        </h4>\n        <table style=\"width: 100%; border-collapse: collapse;\">\n          <tr>\n            <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Position:</td>\n            <td style=\"padding: 4px 0;\">${formattedCoords.lat}, ${formattedCoords.lon}</td>\n          </tr>\n          <tr>\n            <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">MGRS:</td>\n            <td style=\"padding: 4px 0; font-family: monospace; color: #ffaa00;\">${mgrsCoord}</td>\n          </tr>\n          <tr>\n            <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Hostname:</td>\n            <td style=\"padding: 4px 0;\">${systemInfo.hostname}</td>\n          </tr>\n          <tr>\n            <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Primary IP:</td>\n            <td style=\"padding: 4px 0; font-family: monospace;\">${systemInfo.ip}</td>\n          </tr>\n          ${wifiInterfacesHtml}\n          <tr>\n            <td colspan=\"2\" style=\"padding: 8px 0 4px 0; border-top: 1px solid #333;\">\n              <strong>System Resources:</strong>\n            </td>\n          </tr>\n          <tr>\n            <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">CPU:</td>\n            <td style=\"padding: 4px 0;\">\n              <span style=\"color: ${systemInfo.cpu.usage > 80 ? '#ff4444' : systemInfo.cpu.usage > 60 ? '#ffaa00' : '#00ff00'}\">\n                ${systemInfo.cpu.usage.toFixed(1)}%\n              </span>\n              (${systemInfo.cpu.cores} cores)\n            </td>\n          </tr>\n          <tr>\n            <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Memory:</td>\n            <td style=\"padding: 4px 0;\">\n              <span style=\"color: ${systemInfo.memory.percentage > 80 ? '#ff4444' : systemInfo.memory.percentage > 60 ? '#ffaa00' : '#00ff00'}\">\n                ${systemInfo.memory.percentage.toFixed(1)}%\n              </span>\n              (${formatBytes(systemInfo.memory.used)} / ${formatBytes(systemInfo.memory.total)})\n            </td>\n          </tr>\n          <tr>\n            <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Storage:</td>\n            <td style=\"padding: 4px 0;\">\n              <span style=\"color: ${systemInfo.storage.percentage > 80 ? '#ff4444' : systemInfo.storage.percentage > 60 ? '#ffaa00' : '#00ff00'}\">\n                ${systemInfo.storage.percentage}%\n              </span>\n              (${formatBytes(systemInfo.storage.used)} / ${formatBytes(systemInfo.storage.total)})\n            </td>\n          </tr>\n          <tr>\n            <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Temperature:</td>\n            <td style=\"padding: 4px 0;\">\n              <span style=\"color: ${systemInfo.temperature > 70 ? '#ff4444' : systemInfo.temperature > 60 ? '#ffaa00' : '#00ff00'}\">\n                ${systemInfo.temperature.toFixed(1)}°C\n              </span>\n            </td>\n          </tr>\n          <tr>\n            <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Uptime:</td>\n            <td style=\"padding: 4px 0;\">${uptimeStr}</td>\n          </tr>\n          ${systemInfo.battery ? `\n          <tr>\n            <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Battery:</td>\n            <td style=\"padding: 4px 0;\">\n              <span style=\"color: ${systemInfo.battery.level < 20 ? '#ff4444' : systemInfo.battery.level < 50 ? '#ffaa00' : '#00ff00'}\">\n                ${systemInfo.battery.level}%\n              </span>\n              ${systemInfo.battery.charging ? '(Charging)' : ''}\n            </td>\n          </tr>\n          ` : ''}\n        </table>\n      </div>\n    `;\n    \n    (userMarker as any).setPopupContent(popupContent);\n    (userMarker as any).openPopup();\n  }\n  \n  // Get device icon SVG based on type\n  function getDeviceIconSVG(device: KismetDevice, color: string): string {\n    const type = device.type?.toLowerCase() || '';\n    const manufacturer = device.manufacturer?.toLowerCase() || '';\n    \n    // Access Point / Router icon (antenna with waves)\n    if (type.includes('ap') || type.includes('access') || \n        manufacturer.includes('arris') || manufacturer.includes('router') || \n        manufacturer.includes('gateway')) {\n      return `\n        <svg width=\"40\" height=\"40\" viewBox=\"0 0 30 30\" xmlns=\"http://www.w3.org/2000/svg\">\n          <!-- Router body -->\n          <rect x=\"10\" y=\"20\" width=\"10\" height=\"6\" fill=\"${color}\" stroke=\"#fff\" stroke-width=\"0.5\"/>\n          <!-- Antenna -->\n          <line x1=\"15\" y1=\"20\" x2=\"15\" y2=\"10\" stroke=\"${color}\" stroke-width=\"2\"/>\n          <!-- Signal waves -->\n          <path d=\"M 10 15 Q 15 13 20 15\" fill=\"none\" stroke=\"${color}\" stroke-width=\"1.5\" opacity=\"0.8\"/>\n          <path d=\"M 7 12 Q 15 9 23 12\" fill=\"none\" stroke=\"${color}\" stroke-width=\"1.5\" opacity=\"0.6\"/>\n          <path d=\"M 4 9 Q 15 5 26 9\" fill=\"none\" stroke=\"${color}\" stroke-width=\"1.5\" opacity=\"0.4\"/>\n        </svg>\n      `;\n    }\n    \n    // Mobile/Client device icon (smartphone/laptop outline)\n    if (type.includes('client') || type.includes('mobile') || \n        manufacturer.includes('phone') || manufacturer.includes('smartphone') ||\n        manufacturer.includes('android') || manufacturer.includes('iphone')) {\n      return `\n        <svg width=\"40\" height=\"40\" viewBox=\"0 0 30 30\" xmlns=\"http://www.w3.org/2000/svg\">\n          <!-- Phone body -->\n          <rect x=\"11\" y=\"8\" width=\"8\" height=\"14\" rx=\"1\" fill=\"none\" stroke=\"${color}\" stroke-width=\"2\"/>\n          <!-- Screen -->\n          <rect x=\"12.5\" y=\"10\" width=\"5\" height=\"9\" fill=\"${color}\" opacity=\"0.3\"/>\n          <!-- Home button -->\n          <circle cx=\"15\" cy=\"20.5\" r=\"0.8\" fill=\"${color}\"/>\n        </svg>\n      `;\n    }\n    \n    // Unknown device icon (network node)\n    return `\n      <svg width=\"30\" height=\"30\" viewBox=\"0 0 30 30\" xmlns=\"http://www.w3.org/2000/svg\">\n        <!-- Node circle -->\n        <circle cx=\"15\" cy=\"15\" r=\"8\" fill=\"none\" stroke=\"${color}\" stroke-width=\"2\"/>\n        <!-- Question mark -->\n        <text x=\"15\" y=\"19\" text-anchor=\"middle\" font-size=\"10\" font-weight=\"bold\" fill=\"${color}\">?</text>\n        <!-- Connection points -->\n        <circle cx=\"15\" cy=\"7\" r=\"1.5\" fill=\"${color}\"/>\n        <circle cx=\"23\" cy=\"15\" r=\"1.5\" fill=\"${color}\"/>\n        <circle cx=\"15\" cy=\"23\" r=\"1.5\" fill=\"${color}\"/>\n        <circle cx=\"7\" cy=\"15\" r=\"1.5\" fill=\"${color}\"/>\n      </svg>\n    `;\n  }\n  \n  // Calculate signal position (spiral pattern)\n  function calculateSignalPosition(\n    signalStrength: number,\n    index: number\n  ): {lat: number, lon: number} {\n    // Position based on signal strength\n    // Stronger = closer to center\n    const distance = (100 + signalStrength) * 0.00001;\n    const angle = (index * 137.5) * (Math.PI / 180); // Golden angle\n    \n    return {\n      lat: userPosition.lat + distance * Math.cos(angle),\n      lon: userPosition.lon + distance * Math.sin(angle)\n    };\n  }\n  \n  // Get GPS position from gpsd\n  async function updateGPSPosition() {\n    try {\n      const response = await fetch('/api/gps/position');\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const result = await response.json();\n      \n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (result.success && result.data) {\n         \n        userPosition = {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n          lat: result.data.latitude,\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n          lon: result.data.longitude\n        };\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        accuracy = result.data.accuracy;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        satellites = result.data.satellites || 0;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        const fix = result.data.fix;\n        fixType = fix === 3 ? '3D' : fix === 2 ? '2D' : 'No';\n        gpsStatus = `GPS: ${fixType} Fix (${satellites} sats)`;\n        \n        // Update country and formatted coordinates\n        currentCountry = detectCountry(userPosition.lat, userPosition.lon);\n        formattedCoords = formatCoordinates(userPosition.lat, userPosition.lon);\n        \n        // Update MGRS coordinates\n        mgrsCoord = latLonToMGRS(userPosition.lat, userPosition.lon);\n        \n        // Set GPS fix flag and initialize map if needed\n        if (!hasGPSFix && fix >= 2) {\n          hasGPSFix = true;\n          initializeMap();\n        }\n        \n        // Update map and markers\n        if (map && L) {\n          // Update or create user marker\n          if (userMarker) {\n            (userMarker as any).setLatLng([userPosition.lat, userPosition.lon]);\n          } else {\n            // Create user marker with American flag emoji\n            const userIcon = (L as any).divIcon({\n              className: 'user-marker',\n              html: '<div style=\"font-size: 36px; text-align: center; filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));\">🇺🇸</div>',\n              iconSize: [40, 40],\n              iconAnchor: [20, 20]\n            });\n            userMarker = (L as any).marker([userPosition.lat, userPosition.lon], { icon: userIcon }).addTo(map);\n            \n            // Add click handler to user marker\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            userMarker.on('click', async () => {\n              await showPiPopup();\n            });\n            \n            // Bind popup to user marker\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            userMarker.bindPopup('', {\n              maxWidth: 300,\n              className: 'pi-popup',\n              autoClose: false,\n              closeOnClick: false\n            });\n            \n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            map.setView([userPosition.lat, userPosition.lon], 15);\n          }\n          \n          // Update or create accuracy circle\n          if (accuracyCircle) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            accuracyCircle.setLatLng([userPosition.lat, userPosition.lon]);\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            accuracyCircle.setRadius(accuracy);\n          } else if (accuracy > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            accuracyCircle = L.circle([userPosition.lat, userPosition.lon], {\n              radius: accuracy,\n              color: '#3b82f6',\n              fillColor: '#3b82f6',\n              fillOpacity: 0.15,\n              weight: 1\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            }).addTo(map);\n          }\n        }\n      } else {\n        gpsStatus = 'GPS: No Fix';\n      }\n    } catch (error) {\n      console.error('GPS fetch error:', error);\n      gpsStatus = 'GPS: Error';\n    }\n  }\n  \n  // Connect to HackRF data stream\n  function connectToHackRF() {\n    // eslint-disable-next-line no-console\n    console.log('Connecting to HackRF...');\n    hackrfAPI.connectToDataStream();\n    \n    // Subscribe to spectrum data\n    spectrumUnsubscribe = spectrumData.subscribe(data => {\n      if (data && isSearching) {\n        aggregator.addSpectrumData(data);\n      }\n    });\n    \n    connectionStatus = 'Connected';\n  }\n  \n  // Disconnect from HackRF\n  function disconnectFromHackRF() {\n    // eslint-disable-next-line no-console\n    console.log('Disconnecting from HackRF...');\n    hackrfAPI.disconnect();\n    \n    if (spectrumUnsubscribe) {\n      spectrumUnsubscribe();\n      spectrumUnsubscribe = null;\n    }\n    \n    connectionStatus = 'Disconnected';\n  }\n  \n  // Fetch Kismet devices\n  async function fetchKismetDevices() {\n    if (!map) return;\n    \n    try {\n      const response = await fetch('/api/kismet/devices');\n      if (response.ok) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const data = await response.json();\n        \n        // Update or create markers for each device\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        const devices = data.devices;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n        devices.forEach((device: KismetDevice) => {\n          const markerId = `kismet_${device.mac}`;\n          \n          // Check if marker already exists\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          let marker = kismetMarkers.get(markerId);\n          \n          if (!marker) {\n            // Create new marker with device type icon\n            const iconColor = getSignalColor(device.signal?.last_signal || -100);\n            const deviceIconSVG = getDeviceIconSVG(device, iconColor);\n            \n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            marker = L.marker([device.location?.lat || userPosition.lat, device.location?.lon || userPosition.lon], {\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n              icon: L.divIcon({\n                html: deviceIconSVG,\n                iconSize: [40, 40],\n                iconAnchor: [20, 20],\n                className: 'kismet-marker'\n              })\n            });\n            \n            // Create popup content\n            const popupContent = `\n              <div style=\"font-family: sans-serif; min-width: 200px;\">\n                <h4 style=\"margin: 0 0 8px 0; color: ${getSignalColor(device.signal?.last_signal || -100)}\">\n                  Kismet Device\n                </h4>\n                <table style=\"width: 100%; border-collapse: collapse;\">\n                  <tr>\n                    <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Type:</td>\n                    <td style=\"padding: 4px 0;\">${device.type || 'Unknown'}</td>\n                  </tr>\n                  <tr>\n                    <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">MAC:</td>\n                    <td style=\"padding: 4px 0; font-family: monospace;\">${device.mac}</td>\n                  </tr>\n                  <tr>\n                    <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Signal:</td>\n                    <td style=\"padding: 4px 0; color: ${getSignalColor(device.signal?.last_signal || -100)}\">\n                      ${device.signal?.last_signal || -100} dBm\n                    </td>\n                  </tr>\n                  <tr>\n                    <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Channel:</td>\n                    <td style=\"padding: 4px 0;\">${device.channel || 'Unknown'}</td>\n                  </tr>\n                  <tr>\n                    <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Packets:</td>\n                    <td style=\"padding: 4px 0;\">${device.packets}</td>\n                  </tr>\n                  <tr>\n                    <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Manufacturer:</td>\n                    <td style=\"padding: 4px 0;\">${device.manufacturer}</td>\n                  </tr>\n                  <tr>\n                    <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">MGRS:</td>\n                    <td style=\"padding: 4px 0; font-family: monospace; color: #ffaa00;\">${latLonToMGRS(device.location?.lat || userPosition.lat, device.location?.lon || userPosition.lon)}</td>\n                  </tr>\n                </table>\n              </div>\n            `;\n            \n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            marker.bindPopup(popupContent, {\n              maxWidth: 300,\n              className: 'signal-popup',\n              autoClose: false,\n              closeOnClick: false\n            });\n            \n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            marker.on('click', function() {\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n              this.openPopup();\n            });\n            \n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            marker.addTo(map);\n            kismetMarkers.set(markerId, marker);\n          } else {\n            // Update existing marker\n            const iconColor = getSignalColor(device.signal?.last_signal || -100);\n            const deviceIconSVG = getDeviceIconSVG(device, iconColor);\n            \n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            marker.setIcon(L.divIcon({\n              html: deviceIconSVG,\n              iconSize: [30, 30],\n              iconAnchor: [15, 15],\n              className: 'kismet-marker'\n            }));\n            \n            // Update popup if needed\n            const popupContent = `\n              <div style=\"font-family: sans-serif; min-width: 200px;\">\n                <h4 style=\"margin: 0 0 8px 0; color: ${getSignalColor(device.signal?.last_signal || -100)}\">\n                  Kismet Device\n                </h4>\n                <table style=\"width: 100%; border-collapse: collapse;\">\n                  <tr>\n                    <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Type:</td>\n                    <td style=\"padding: 4px 0;\">${device.type || 'Unknown'}</td>\n                  </tr>\n                  <tr>\n                    <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">MAC:</td>\n                    <td style=\"padding: 4px 0; font-family: monospace;\">${device.mac}</td>\n                  </tr>\n                  <tr>\n                    <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Signal:</td>\n                    <td style=\"padding: 4px 0; color: ${getSignalColor(device.signal?.last_signal || -100)}\">\n                      ${device.signal?.last_signal || -100} dBm\n                    </td>\n                  </tr>\n                  <tr>\n                    <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Channel:</td>\n                    <td style=\"padding: 4px 0;\">${device.channel || 'Unknown'}</td>\n                  </tr>\n                  <tr>\n                    <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Packets:</td>\n                    <td style=\"padding: 4px 0;\">${device.packets}</td>\n                  </tr>\n                  <tr>\n                    <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Manufacturer:</td>\n                    <td style=\"padding: 4px 0;\">${device.manufacturer}</td>\n                  </tr>\n                  <tr>\n                    <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">MGRS:</td>\n                    <td style=\"padding: 4px 0; font-family: monospace; color: #ffaa00;\">${latLonToMGRS(device.location?.lat || userPosition.lat, device.location?.lon || userPosition.lon)}</td>\n                  </tr>\n                </table>\n              </div>\n            `;\n            \n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            if (marker.isPopupOpen()) {\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n              marker.setPopupContent(popupContent);\n            } else {\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n              marker.getPopup().setContent(popupContent);\n            }\n          }\n          \n          // Store device data\n          kismetDevices.set(markerId, device);\n        });\n        \n        // Clean up markers for devices that no longer exist\n        kismetMarkers.forEach((marker, id) => {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          if (!(data.devices as KismetDevice[]).find((d: KismetDevice) => `kismet_${d.id}` === id)) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            map.removeLayer(marker);\n            kismetMarkers.delete(id);\n            kismetDevices.delete(id);\n          }\n        });\n        \n        // Update the reactive counter and distributions\n        kismetDeviceCount = kismetDevices.size;\n        updateDistributions();\n      }\n    } catch (error) {\n      console.error('Error fetching Kismet devices:', error);\n    }\n  }\n  \n  // Process aggregated signals\n  function processSignals() {\n    if (!isSearching || !map) return;\n    \n    // Get aggregated signals matching target frequency\n    const aggregatedSignals = aggregator.getAggregatedSignals(targetFrequency);\n    \n    // Group signals by frequency and keep only the strongest per frequency\n    const frequencyMap = new Map<number, typeof aggregatedSignals[0]>();\n    aggregatedSignals.forEach(signal => {\n      const existing = frequencyMap.get(signal.frequency);\n      if (!existing || signal.power > existing.power) {\n        frequencyMap.set(signal.frequency, signal);\n      }\n    });\n    \n    // Convert map to array and sort by power (strongest first)\n    const uniqueFrequencySignals = Array.from(frequencyMap.values())\n      .sort((a, b) => b.power - a.power);\n    \n    // Keep track of which signals to keep\n    const signalsToKeep = new Set<string>();\n    \n    // Process the strongest signal per unique frequency\n    uniqueFrequencySignals.forEach((aggSignal, index) => {\n      const signalId = `freq_${aggSignal.frequency}`;\n      signalsToKeep.add(signalId);\n      \n      // Check if signal already exists\n      let signal = signals.get(signalId);\n      \n      if (!signal) {\n        // Create new signal\n        const position = calculateSignalPosition(aggSignal.power, index);\n        signal = {\n          id: signalId,\n          frequency: aggSignal.frequency,\n          power: aggSignal.power,\n          timestamp: aggSignal.lastSeen,\n          persistence: aggregator.getSignalPersistence(aggSignal),\n          position\n        };\n        signals.set(signalId, signal);\n        \n        // Create marker with popup\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n        const marker = L.circleMarker([position.lat, position.lon], {\n          radius: 8 + (aggSignal.power + 100) / 10, // Size based on power\n          fillColor: getSignalColor(aggSignal.power),\n          color: '#ffffff',\n          weight: 1,\n          opacity: 1,\n          fillOpacity: 0.8\n        });\n        \n        // Bind popup with signal information\n        const popupContent = `\n          <div style=\"font-family: sans-serif; min-width: 200px;\">\n            <h4 style=\"margin: 0 0 8px 0; color: ${getSignalColor(aggSignal.power)}\">\n              Signal Details\n            </h4>\n            <table style=\"width: 100%; border-collapse: collapse;\">\n              <tr>\n                <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Frequency:</td>\n                <td style=\"padding: 4px 0;\">${aggSignal.frequency.toFixed(2)} MHz</td>\n              </tr>\n              <tr>\n                <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Power:</td>\n                <td style=\"padding: 4px 0; color: ${getSignalColor(aggSignal.power)}\">\n                  ${aggSignal.power.toFixed(1)} dBm\n                </td>\n              </tr>\n              <tr>\n                <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Position:</td>\n                <td style=\"padding: 4px 0;\">\n                  ${position.lat.toFixed(6)}, ${position.lon.toFixed(6)}\n                </td>\n              </tr>\n              <tr>\n                <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">MGRS:</td>\n                <td style=\"padding: 4px 0; font-family: monospace; color: #ffaa00;\">\n                  ${latLonToMGRS(position.lat, position.lon)}\n                </td>\n              </tr>\n              <tr>\n                <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Persistence:</td>\n                <td style=\"padding: 4px 0;\">${signal.persistence.toFixed(1)}s</td>\n              </tr>\n              <tr>\n                <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Detections:</td>\n                <td style=\"padding: 4px 0;\">${aggSignal.count}</td>\n              </tr>\n            </table>\n          </div>\n        `;\n        \n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n        marker.bindPopup(popupContent, {\n          maxWidth: 300,\n          className: 'signal-popup',\n          autoClose: false,\n          closeOnClick: false,\n          closeOnEscapeKey: false,\n          autoPan: false,\n          keepInView: false\n        });\n        \n        // Add click handler to ensure popup stays open\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n        marker.on('click', function() {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n          this.openPopup();\n        });\n        \n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n        marker.addTo(map);\n        signalMarkers.set(signalId, marker);\n      } else {\n        // Update existing signal\n        signal.power = aggSignal.power;\n        signal.timestamp = aggSignal.lastSeen;\n        signal.persistence = aggregator.getSignalPersistence(aggSignal);\n        \n        // Update marker and popup\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const marker = signalMarkers.get(signalId);\n        if (marker) {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n          marker.setStyle({\n            fillColor: getSignalColor(aggSignal.power),\n            radius: 8 + (aggSignal.power + 100) / 10\n          });\n          \n          // Ensure popup has correct options\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n          if (!marker.getPopup()) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            marker.bindPopup('', {\n              maxWidth: 300,\n              className: 'signal-popup',\n              autoClose: false,\n              closeOnClick: false,\n              closeOnEscapeKey: false,\n              autoPan: false,\n              keepInView: false\n            });\n          }\n          \n          // Update popup content\n          const popupContent = `\n            <div style=\"font-family: sans-serif; min-width: 200px;\">\n              <h4 style=\"margin: 0 0 8px 0; color: ${getSignalColor(signal.power)}\">\n                Signal Details\n              </h4>\n              <table style=\"width: 100%; border-collapse: collapse;\">\n                <tr>\n                  <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Frequency:</td>\n                  <td style=\"padding: 4px 0;\">${signal.frequency.toFixed(2)} MHz</td>\n                </tr>\n                <tr>\n                  <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Power:</td>\n                  <td style=\"padding: 4px 0; color: ${getSignalColor(signal.power)}\">\n                    ${signal.power.toFixed(1)} dBm\n                  </td>\n                </tr>\n                <tr>\n                  <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Position:</td>\n                  <td style=\"padding: 4px 0;\">\n                    ${signal.position.lat.toFixed(6)}, ${signal.position.lon.toFixed(6)}\n                  </td>\n                </tr>\n                <tr>\n                  <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">MGRS:</td>\n                  <td style=\"padding: 4px 0; font-family: monospace; color: #ffaa00;\">\n                    ${latLonToMGRS(signal.position.lat, signal.position.lon)}\n                  </td>\n                </tr>\n                <tr>\n                  <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Persistence:</td>\n                  <td style=\"padding: 4px 0;\">${signal.persistence.toFixed(1)}s</td>\n                </tr>\n                <tr>\n                  <td style=\"padding: 4px 8px 4px 0; font-weight: bold;\">Detections:</td>\n                  <td style=\"padding: 4px 0;\">${aggSignal.count}</td>\n                </tr>\n              </table>\n            </div>\n          `;\n          \n          // Only update popup content if it's currently open\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n          if (marker.isPopupOpen()) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            marker.setPopupContent(popupContent);\n          } else {\n            // Update the popup without opening it\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            marker.getPopup().setContent(popupContent);\n          }\n        }\n      }\n      \n      // Update current signal display with the strongest signal\n      if (!currentSignal || signal.power > currentSignal.power) {\n        currentSignal = signal;\n      }\n    });\n    \n    // Remove signals that are no longer being detected (not in signalsToKeep)\n    signals.forEach((signal, id) => {\n      if (!signalsToKeep.has(id)) {\n        // Remove marker from map\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const marker = signalMarkers.get(id);\n        if (marker) {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n          marker.remove();\n          signalMarkers.delete(id);\n        }\n        signals.delete(id);\n      }\n    });\n    \n    // Update signal count\n    signalCount = signals.size;\n    \n    // Only clear currentSignal if no signals exist and we've been searching for a while\n    // This prevents flickering when signals temporarily disappear\n    if (signals.size === 0 && currentSignal) {\n      // Give it a grace period before clearing the display\n      if (!currentSignal._clearTimeout) {\n         \n        currentSignal._clearTimeout = setTimeout(() => {\n          currentSignal = null;\n        }, 2000); // 2 second grace period\n      }\n    } else if (signals.size > 0 && currentSignal?._clearTimeout) {\n      // Cancel the clear timeout if signals are found again\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      clearTimeout(currentSignal._clearTimeout);\n      delete currentSignal._clearTimeout;\n    }\n  }\n  \n  onMount(async () => {\n    // Import Leaflet dynamically on client side\n    const leafletModule = await import('leaflet');\n    L = leafletModule.default;\n    await import('leaflet/dist/leaflet.css');\n    \n    // Start GPS updates (map will initialize after GPS fix)\n    void updateGPSPosition();\n    positionInterval = window.setInterval(() => void updateGPSPosition(), 5000); // Update every 5 seconds\n    \n    connectToHackRF();\n    \n    // Start update interval\n    updateInterval = window.setInterval(processSignals, UPDATE_RATE);\n    \n    // Start fetching Kismet devices every 10 seconds\n    void fetchKismetDevices();\n    kismetInterval = window.setInterval(() => void fetchKismetDevices(), 10000);\n  });\n  \n  onDestroy(() => {\n    disconnectFromHackRF();\n    \n    if (updateInterval) {\n      clearInterval(updateInterval);\n      updateInterval = null;\n    }\n    \n    if (positionInterval) {\n      clearInterval(positionInterval);\n      positionInterval = null;\n    }\n    \n    if (kismetInterval) {\n      clearInterval(kismetInterval);\n      kismetInterval = null;\n    }\n    \n    if (map) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n      map.remove();\n      map = null;\n    }\n  });\n</script>\n\n<div class=\"tactical-map-simple\">\n  <!-- Search Bar -->\n  <div class=\"search-bar\">\n    <div class=\"search-container\">\n      <button class=\"back-console-button\" on:click={() => window.location.href = '/hackrfsweep'}>\n        <svg class=\"w-4 h-4\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n          <path fill-rule=\"evenodd\" d=\"M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L4.414 9H17a1 1 0 110 2H4.414l5.293 5.293a1 1 0 010 1.414z\"/>\n        </svg>\n        Back to Console\n      </button>\n      <div class=\"kismet-whitelist\">\n        <label class=\"mac-label\">MAC Whitelist</label>\n        <input\n          type=\"text\"\n          bind:value={kismetWhitelistMAC}\n          placeholder=\"e.g. FF:FF:FF:FF:FF:FF\"\n          class=\"mac-input\"\n          on:keydown={(e) => e.key === 'Enter' && addToWhitelist()}\n        />\n      </div>\n      <div class=\"frequency-inputs\">\n        {#each searchFrequencies as _freq, idx}\n          <input\n            type=\"number\"\n            bind:value={searchFrequencies[idx]}\n            placeholder=\"Freq {idx + 1}\"\n            on:keydown={(e) => e.key === 'Enter' && handleSearch()}\n            class=\"frequency-input-small\"\n          />\n        {/each}\n      </div>\n      <button \n        on:click={handleSearch}\n        class=\"search-button\"\n        disabled={!searchFrequencies.some(f => f)}\n      >\n        Search\n      </button>\n      <button \n        on:click={clearSignals}\n        class=\"clear-button\"\n        disabled={signalCount === 0 && kismetDeviceCount === 0}\n      >\n        Clear\n      </button>\n    </div>\n    <div class=\"status\">\n      <span class=\"status-item\">\n        <span style=\"color: #ffffff;\">GPS:</span>\n        {#if fixType !== 'No'}\n          <span style=\"color: #00ff00; margin-left: 0.25rem;\">{fixType} Fix</span>\n          <span style=\"color: #888; margin-left: 0.25rem;\">({satellites} sats)</span>\n          <span style=\"color: #ffffff; margin-left: 0.5rem;\">|</span>\n          <span style=\"color: #88ccff; margin-left: 0.5rem;\">{formattedCoords.lat}, {formattedCoords.lon}</span>\n          <span style=\"color: #ffffff; margin-left: 0.5rem;\">|</span>\n          <span style=\"color: #ffaa00; margin-left: 0.5rem; font-family: monospace;\">{mgrsCoord}</span>\n          <span style=\"font-size: 1.2em; margin-left: 0.5rem;\">{currentCountry.flag}</span>\n        {:else}\n          <span style=\"color: #ff4444; margin-left: 0.25rem;\">No Fix</span>\n        {/if}\n      </span>\n    </div>\n  </div>\n  \n  <!-- Map Container -->\n  <div class=\"map-container\" bind:this={mapContainer}>\n    {#if !hasGPSFix}\n      <div class=\"gps-waiting\">\n        <div class=\"gps-waiting-content\">\n          <svg class=\"gps-icon\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n            <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.94-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z\"/>\n          </svg>\n          <h3>Waiting for GPS Fix</h3>\n          <p>{gpsStatus}</p>\n        </div>\n      </div>\n    {/if}\n    \n    <!-- Signal Strength Legend - moved inside map container -->\n    <div class=\"signal-legend\">\n    <span class=\"legend-title\">Signal Strength Legend:</span>\n    <span class=\"legend-item\">\n      <span class=\"legend-color\" style=\"background: #ff0000\"></span>\n      &gt; -50 dBm (Very Strong)\n    </span>\n    <span class=\"legend-item\">\n      <span class=\"legend-color\" style=\"background: #ff8800\"></span>\n      -50 to -60 dBm (Strong)\n    </span>\n    <span class=\"legend-item\">\n      <span class=\"legend-color\" style=\"background: #ffff00\"></span>\n      -60 to -70 dBm (Good)\n    </span>\n    <span class=\"legend-item\">\n      <span class=\"legend-color\" style=\"background: #00ff00\"></span>\n      -70 to -80 dBm (Fair)\n    </span>\n    <span class=\"legend-item\">\n      <span class=\"legend-color\" style=\"background: #0088ff\"></span>\n      &lt; -80 dBm (Weak)\n    </span>\n    </div>\n  </div>\n  \n  <!-- Signal Info Bar (Now Kismet Data) -->\n  <div class=\"signal-info\">\n    <div class=\"footer-section kismet-label\">\n      <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\" style=\"vertical-align: middle;\">\n        <path d=\"M1 9l2 2c4.97-4.97 13.03-4.97 18 0l2-2C16.93 2.93 7.07 2.93 1 9zm8 8l3 3 3-3c-1.65-1.66-4.34-1.66-6 0zm-4-4l2 2c2.76-2.76 7.24-2.76 10 0l2-2C15.14 9.14 8.87 9.14 5 13z\"></path>\n      </svg>\n      <span class=\"kismet-title\">KISMET</span>\n    </div>\n    \n    {#if kismetDeviceCount > 0}\n      \n      <div class=\"footer-section\">\n        <span class=\"footer-label\">Signal Distribution:</span>\n        {#if signalDistribution.veryStrong > 0}\n          <span class=\"signal-stat\">\n            <span class=\"signal-indicator\" style=\"background: #ff0000\"></span>\n            {signalDistribution.veryStrong}\n          </span>\n        {/if}\n        {#if signalDistribution.strong > 0}\n          <span class=\"signal-stat\">\n            <span class=\"signal-indicator\" style=\"background: #ff8800\"></span>\n            {signalDistribution.strong}\n          </span>\n        {/if}\n        {#if signalDistribution.good > 0}\n          <span class=\"signal-stat\">\n            <span class=\"signal-indicator\" style=\"background: #ffff00\"></span>\n            {signalDistribution.good}\n          </span>\n        {/if}\n        {#if signalDistribution.fair > 0}\n          <span class=\"signal-stat\">\n            <span class=\"signal-indicator\" style=\"background: #00ff00\"></span>\n            {signalDistribution.fair}\n          </span>\n        {/if}\n        {#if signalDistribution.weak > 0}\n          <span class=\"signal-stat\">\n            <span class=\"signal-indicator\" style=\"background: #0088ff\"></span>\n            {signalDistribution.weak}\n          </span>\n        {/if}\n      </div>\n      \n      <div class=\"footer-divider\"></div>\n      \n      <div class=\"footer-section\">\n        <span class=\"footer-label\">Device Types:</span>\n        {#if deviceTypeDistribution.ap > 0}\n          <span class=\"device-stat\">\n            <svg width=\"16\" height=\"16\" viewBox=\"0 0 30 30\" style=\"vertical-align: middle;\">\n              <rect x=\"10\" y=\"20\" width=\"10\" height=\"6\" fill=\"#888\" stroke=\"#fff\" stroke-width=\"0.5\"/>\n              <line x1=\"15\" y1=\"20\" x2=\"15\" y2=\"10\" stroke=\"#888\" stroke-width=\"2\"/>\n              <path d=\"M 10 15 Q 15 13 20 15\" fill=\"none\" stroke=\"#888\" stroke-width=\"1.5\" opacity=\"0.8\"/>\n              <path d=\"M 7 12 Q 15 9 23 12\" fill=\"none\" stroke=\"#888\" stroke-width=\"1.5\" opacity=\"0.6\"/>\n            </svg>\n            {deviceTypeDistribution.ap} APs\n          </span>\n        {/if}\n        {#if deviceTypeDistribution.client > 0}\n          <span class=\"device-stat\">\n            <svg width=\"16\" height=\"16\" viewBox=\"0 0 30 30\" style=\"vertical-align: middle;\">\n              <rect x=\"11\" y=\"8\" width=\"8\" height=\"14\" rx=\"1\" fill=\"none\" stroke=\"#888\" stroke-width=\"2\"/>\n              <rect x=\"12.5\" y=\"10\" width=\"5\" height=\"9\" fill=\"#888\" opacity=\"0.3\"/>\n              <circle cx=\"15\" cy=\"20.5\" r=\"0.8\" fill=\"#888\"/>\n            </svg>\n            {deviceTypeDistribution.client} Clients\n          </span>\n        {/if}\n        {#if deviceTypeDistribution.unknown > 0}\n          <span class=\"device-stat\">\n            <svg width=\"16\" height=\"16\" viewBox=\"0 0 30 30\" style=\"vertical-align: middle;\">\n              <circle cx=\"15\" cy=\"15\" r=\"8\" fill=\"none\" stroke=\"#888\" stroke-width=\"2\"/>\n              <text x=\"15\" y=\"19\" text-anchor=\"middle\" font-size=\"10\" font-weight=\"bold\" fill=\"#888\">?</text>\n            </svg>\n            {deviceTypeDistribution.unknown} Unknown\n          </span>\n        {/if}\n      </div>\n      \n      <div class=\"footer-divider\"></div>\n      \n      <div class=\"footer-section\">\n        <span class=\"footer-label\">Total Devices:</span>\n        <span class=\"device-count\">{kismetDeviceCount}</span>\n      </div>\n      \n      <div class=\"footer-divider\"></div>\n      \n      <div class=\"footer-section\">\n        <span class=\"footer-label\">Total Devices Whitelisted:</span>\n        <span class=\"device-count\">{whitelistedDeviceCount}</span>\n      </div>\n    {:else}\n      <div class=\"footer-section\">\n        <span class=\"loading-status\">Pulling data...</span>\n      </div>\n    {/if}\n  </div>\n  \n  <!-- Data Footer (Now HackRF Data) -->\n  <div class=\"data-footer\">\n    <div class=\"footer-section hackrf-label\">\n      <svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"currentColor\" style=\"vertical-align: middle;\">\n        <path d=\"M4 20v-2h2v2H4zm4 0v-5h2v5H8zm4 0V10h2v10h-2zm4 0V4h2v16h-2z\"></path>\n      </svg>\n      <span style=\"font-weight: 600; letter-spacing: 0.05em; font-size: 12px;\">\n        <span style=\"color: #fb923c;\">HACKRF</span>\n        <span style=\"color: #ffffff;\">SWEEP</span>\n      </span>\n    </div>\n    \n    {#if isSearching && signalCount > 0}\n      <div class=\"footer-section\">\n        <span class=\"footer-label\">Target:</span>\n        <span class=\"frequency-value\">{targetFrequency} MHz</span>\n      </div>\n      \n      <div class=\"footer-divider\"></div>\n      \n      <div class=\"footer-section\">\n        <span class=\"footer-label\">Signals:</span>\n        <span class=\"signal-count\">{signalCount}</span>\n      </div>\n      \n      {#if currentSignal}\n        <div class=\"footer-divider\"></div>\n        \n        <div class=\"footer-section\">\n          <span class=\"footer-label\">Strongest:</span>\n          <span class=\"frequency-value\">{currentSignal.frequency.toFixed(2)} MHz</span>\n          <span class=\"power-value\" style=\"color: {getSignalColor(currentSignal.power)}\">\n            @ {currentSignal.power.toFixed(1)} dBm\n          </span>\n        </div>\n      {/if}\n    {:else if isSearching}\n      <div class=\"footer-section\">\n        <span class=\"footer-label\">Searching:</span>\n        <span class=\"frequency-value\">{targetFrequency} MHz</span>\n      </div>\n    {:else}\n      <div class=\"footer-section\" style=\"flex-direction: column; align-items: flex-start; gap: 0.25rem;\">\n        <div>\n          <span style=\"color: #ffffff;\">Device:</span>\n          <span style=\"color: {connectionStatus === 'Connected' ? '#00ff00' : '#ff4444'}; margin-left: 0.25rem;\">\n            {connectionStatus}\n          </span>\n        </div>\n        <div>\n          <span style=\"color: #ffffff;\">Broadcast:</span>\n          <span style=\"color: #ff4444; margin-left: 0.25rem;\">Offline</span>\n        </div>\n      </div>\n      \n      <div class=\"footer-divider\"></div>\n      \n      <div class=\"footer-section\" style=\"flex-direction: column; align-items: flex-start; gap: 0.25rem;\">\n        <div>\n          <span style=\"color: #fb923c;\">Frequencies</span>\n        </div>\n        <div>\n          <span style=\"color: #ffffff;\">Detected:</span>\n          <span style=\"color: #888; font-weight: 600; margin-left: 0.25rem;\">{signalCount}</span>\n        </div>\n      </div>\n    {/if}\n    \n    <div class=\"footer-divider\"></div>\n    \n    <button class=\"saasfly-btn saasfly-btn-load\" on:click={loadFrequencies}>\n      <svg class=\"w-4 h-4\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n        <path fill-rule=\"evenodd\" d=\"M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z\"/>\n      </svg>\n      Load Frequencies\n    </button>\n    \n    <div class=\"footer-divider\"></div>\n    \n    <button class=\"saasfly-btn saasfly-btn-spectrum\" on:click={openSpectrumAnalyzer}>\n      <svg class=\"w-4 h-4\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\n        <path d=\"M2 11a1 1 0 011-1h2a1 1 0 011 1v5a1 1 0 01-1 1H3a1 1 0 01-1-1v-5zM8 7a1 1 0 011-1h2a1 1 0 011 1v9a1 1 0 01-1 1H9a1 1 0 01-1-1V7zM14 4a1 1 0 011-1h2a1 1 0 011 1v12a1 1 0 01-1 1h-2a1 1 0 01-1-1V4z\"/>\n      </svg>\n      View Spectrum\n    </button>\n  </div>\n</div>\n\n<style>\n  :global(body) {\n    margin: 0;\n    padding: 0;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n  }\n  \n  /* Support for iPhone safe areas (notch, dynamic island) */\n  :global(html) {\n    padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);\n  }\n  \n  /* Prevent horizontal scrolling on mobile */\n  :global(html, body) {\n    overflow-x: hidden;\n    -webkit-overflow-scrolling: touch;\n  }\n  \n  .tactical-map-simple {\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n    background: #1a1a1a;\n    color: #ffffff;\n    position: relative;\n  }\n  \n  /* Search Bar */\n  .search-bar {\n    background: #2a2a2a;\n    border-bottom: 1px solid #444;\n    padding: 1rem;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-wrap: wrap;\n    gap: 1rem;\n  }\n  \n  .search-container {\n    display: flex;\n    gap: 0.5rem;\n    flex: 1;\n    min-width: 300px;\n    align-items: center;\n  }\n  \n  .frequency-inputs {\n    display: flex;\n    gap: 0.5rem;\n  }\n  \n  .frequency-input {\n    flex: 1;\n    padding: 0.5rem 1rem;\n    background: #1a1a1a;\n    border: 1px solid #444;\n    border-radius: 4px;\n    color: #ffffff;\n    font-size: 16px;\n  }\n  \n  .frequency-input:focus {\n    outline: none;\n    border-color: #0088ff;\n  }\n  \n  .frequency-input-small {\n    width: 100px;\n    padding: 0.5rem 0.75rem;\n    background: #1a1a1a;\n    border: 1px solid #444;\n    border-radius: 4px;\n    color: #ffffff;\n    font-size: 14px;\n  }\n  \n  .frequency-input-small:focus {\n    outline: none;\n    border-color: #0088ff;\n  }\n  \n  .frequency-input-small::placeholder {\n    color: #666;\n  }\n  \n  .kismet-whitelist {\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    gap: 0.5rem;\n  }\n  \n  .mac-label {\n    font-size: 12px;\n    color: #000000;\n    background: #ffffff;\n    padding: 0.5rem 0.75rem;\n    border-radius: 4px;\n    font-weight: 500;\n    letter-spacing: 0.05em;\n    height: 36px;\n    display: flex;\n    align-items: center;\n  }\n  \n  .mac-input {\n    width: 200px;\n    padding: 0.5rem 0.75rem;\n    background: #1a1a1a;\n    border: 1px solid #444;\n    border-radius: 4px;\n    color: #ffffff;\n    font-size: 14px;\n  }\n  \n  .mac-input:focus {\n    outline: none;\n    border-color: #00d2ff;\n  }\n  \n  .mac-input::placeholder {\n    color: #666;\n    font-size: 12px;\n  }\n\n  .back-console-button {\n    display: inline-flex;\n    align-items: center;\n    gap: 0.5rem;\n    padding: 0.5rem 1rem;\n    background: linear-gradient(135deg, #10b981 0%, #059669 100%);\n    color: white;\n    border: none;\n    border-radius: 4px;\n    font-size: 14px;\n    font-weight: 500;\n    cursor: pointer;\n    transition: all 0.2s;\n    box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3), 0 0 20px rgba(16, 185, 129, 0.1);\n  }\n\n  .back-console-button:hover {\n    background: linear-gradient(135deg, #059669 0%, #047857 100%);\n    box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4), 0 0 30px rgba(16, 185, 129, 0.2);\n    transform: translateY(-1px);\n  }\n\n  .back-console-button svg {\n    width: 16px;\n    height: 16px;\n  }\n  \n  .search-button,\n  .clear-button {\n    padding: 0.5rem 1.5rem;\n    border: none;\n    border-radius: 4px;\n    font-size: 16px;\n    cursor: pointer;\n    transition: background-color 0.2s;\n  }\n  \n  .search-button {\n    background: #0088ff;\n    color: white;\n  }\n  \n  .search-button:hover:not(:disabled) {\n    background: #0066cc;\n  }\n  \n  .search-button:disabled {\n    background: #444;\n    cursor: not-allowed;\n  }\n  \n  .clear-button {\n    background: #ff4444 !important;\n    color: white !important;\n  }\n  \n  .clear-button:hover:not(:disabled) {\n    background: #ff6666 !important;\n  }\n  \n  .clear-button:disabled {\n    background: #333 !important;\n    color: #666 !important;\n    cursor: not-allowed;\n  }\n  \n  /* Status Display */\n  .status {\n    display: flex;\n    gap: 2rem;\n    font-size: 14px;\n  }\n  \n  .status-item {\n    display: flex;\n    gap: 0.5rem;\n    align-items: center;\n  }\n  \n  .status-label {\n    color: #888;\n  }\n  \n  .status-value {\n    font-weight: 500;\n  }\n  \n  .status-value.connected {\n    color: #00ff00;\n  }\n  \n  .status-value.disconnected {\n    color: #ff4444;\n  }\n  \n  /* Map Container */\n  .map-container {\n    flex: 1;\n    position: relative;\n  }\n  \n  /* Signal Legend */\n  .signal-legend {\n    position: absolute;\n    bottom: 10px;\n    right: 10px;\n    background: rgba(42, 42, 42, 0.9);\n    border: 1px solid #444;\n    border-radius: 4px;\n    padding: 0.5rem;\n    font-size: 12px;\n    display: flex;\n    flex-direction: column;\n    gap: 0.25rem;\n    z-index: 1000;\n  }\n  \n  .legend-title {\n    font-weight: 600;\n    margin-bottom: 0.25rem;\n    color: #ccc;\n  }\n  \n  .legend-item {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n  }\n  \n  .legend-color {\n    width: 12px;\n    height: 12px;\n    border-radius: 2px;\n    display: inline-block;\n  }\n  \n  /* Signal Info Bar */\n  .signal-info {\n    background: #2a2a2a;\n    border-top: 1px solid #444;\n    padding: 0.75rem 1rem;\n    display: flex;\n    align-items: center;\n    gap: 2rem;\n    height: 70px; /* Reduced from 80px */\n    font-size: 13px;\n  }\n  \n  /* Data Footer */\n  .data-footer {\n    background: #2a2a2a;\n    border-top: 1px solid #444;\n    padding: 0.75rem 1rem;\n    display: flex;\n    align-items: center;\n    gap: 1.5rem;\n    font-size: 13px;\n    color: #ccc;\n    height: 70px; /* Reduced from 80px */\n  }\n  \n  .kismet-label {\n    padding-right: 2rem;\n    border-right: 1px solid #444;\n  }\n  \n  .kismet-title {\n    font-weight: 600;\n    color: #00d2ff;\n    letter-spacing: 0.05em;\n    font-size: 12px;\n  }\n  \n  .hackrf-label {\n    padding-right: 1.5rem;\n    border-right: 1px solid #444;\n  }\n  \n  .hackrf-title {\n    font-weight: 600;\n    color: #fb923c;\n    letter-spacing: 0.05em;\n    font-size: 12px;\n  }\n  \n  .frequency-value {\n    color: #fb923c;\n    font-weight: 500;\n  }\n  \n  .power-value {\n    font-weight: 600;\n  }\n  \n  .signal-count {\n    color: #00ff00;\n    font-weight: 600;\n  }\n  \n  .device-count {\n    color: #00d2ff;\n    font-weight: 600;\n  }\n  \n  .frequency-count {\n    color: #fb923c;\n    font-weight: 600;\n  }\n  \n  .offline-status {\n    color: #ff4444;\n  }\n  \n  .loading-status {\n    color: #888;\n    font-style: italic;\n  }\n  \n  .footer-button {\n    background: #333;\n    border: 1px solid #555;\n    color: #ccc;\n    padding: 0.35rem 0.75rem;\n    border-radius: 4px;\n    font-size: 12px;\n    cursor: pointer;\n    transition: all 0.2s;\n    white-space: nowrap;\n  }\n  \n  .footer-button:hover {\n    background: #444;\n    border-color: #666;\n    color: #fff;\n  }\n  \n  /* Saasfly button styles */\n  .saasfly-btn {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    gap: 0.5rem;\n    padding: 0.35rem 0.75rem;\n    border-radius: 0.5rem;\n    font-weight: 500;\n    font-size: 12px;\n    transition-property: all;\n    transition-duration: 200ms;\n    border: none;\n    cursor: pointer;\n  }\n  \n  .saasfly-btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    transform: none !important;\n  }\n  \n  .saasfly-btn svg {\n    width: 14px;\n    height: 14px;\n  }\n  \n  /* Load button - Purple gradient */\n  .saasfly-btn-load {\n    background: linear-gradient(135deg, #a855f7 0%, #9333ea 100%);\n    color: white;\n    box-shadow: 0 2px 8px rgba(168, 85, 247, 0.3), 0 0 20px rgba(168, 85, 247, 0.1);\n  }\n  \n  .saasfly-btn-load:hover {\n    background: linear-gradient(135deg, #9333ea 0%, #7c3aed 100%);\n    box-shadow: 0 4px 12px rgba(168, 85, 247, 0.4), 0 0 30px rgba(168, 85, 247, 0.2);\n    transform: translateY(-1px);\n  }\n  \n  /* Spectrum analyzer button - Blue gradient */\n  .saasfly-btn-spectrum {\n    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);\n    color: white;\n    box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3), 0 0 20px rgba(59, 130, 246, 0.1);\n  }\n  \n  .saasfly-btn-spectrum:hover {\n    background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);\n    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4), 0 0 30px rgba(59, 130, 246, 0.2);\n    transform: translateY(-1px);\n  }\n  \n  .w-4 {\n    width: 1rem;\n  }\n  \n  .h-4 {\n    height: 1rem;\n  }\n  \n  .footer-section {\n    display: flex;\n    align-items: center;\n    gap: 1rem;\n  }\n  \n  .footer-label {\n    color: #888;\n    font-weight: 500;\n    margin-right: 0.5rem;\n  }\n  \n  .signal-stat {\n    display: flex;\n    align-items: center;\n    gap: 0.25rem;\n  }\n  \n  .signal-indicator {\n    width: 12px;\n    height: 12px;\n    border-radius: 2px;\n    display: inline-block;\n  }\n  \n  .device-stat {\n    display: flex;\n    align-items: center;\n    gap: 0.35rem;\n    color: #bbb;\n  }\n  \n  .footer-divider {\n    width: 1px;\n    height: 20px;\n    background: #444;\n  }\n  \n  .info-content {\n    display: flex;\n    gap: 1rem;\n    align-items: center;\n  }\n  \n  .info-label {\n    color: #888;\n    font-size: 14px;\n  }\n  \n  .info-value {\n    font-weight: 500;\n    font-size: 14px;\n  }\n  \n  /* GPS Waiting Screen */\n  .gps-waiting {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    background: #1a1a1a;\n  }\n  \n  .gps-waiting-content {\n    text-align: center;\n    color: #888;\n  }\n  \n  .gps-icon {\n    width: 64px;\n    height: 64px;\n    margin-bottom: 1rem;\n    opacity: 0.5;\n    animation: pulse 2s infinite;\n  }\n  \n  .gps-waiting h3 {\n    margin: 0 0 0.5rem 0;\n    font-size: 1.5rem;\n    font-weight: 500;\n    color: #ccc;\n  }\n  \n  .gps-waiting p {\n    margin: 0;\n    font-size: 0.9rem;\n  }\n  \n  /* User Position Marker */\n  :global(.user-marker) {\n    position: relative;\n    background: transparent !important;\n    border: none !important;\n  }\n  \n  @keyframes pulse {\n    0% {\n      transform: scale(1);\n      opacity: 0.3;\n    }\n    50% {\n      transform: scale(1.2);\n      opacity: 0.1;\n    }\n    100% {\n      transform: scale(1);\n      opacity: 0.3;\n    }\n  }\n  \n  /* Leaflet Popup Styling */\n  :global(.signal-popup .leaflet-popup-content-wrapper) {\n    background: #2a2a2a;\n    color: #ffffff;\n    border: 1px solid #444;\n    border-radius: 6px;\n    box-shadow: 0 3px 14px rgba(0, 0, 0, 0.5);\n  }\n  \n  :global(.signal-popup .leaflet-popup-tip) {\n    background: #2a2a2a;\n    border-bottom: 1px solid #444;\n    border-right: 1px solid #444;\n  }\n  \n  :global(.signal-popup .leaflet-popup-content) {\n    margin: 12px;\n    line-height: 1.4;\n  }\n  \n  :global(.signal-popup .leaflet-popup-close-button) {\n    color: #888;\n    font-size: 20px;\n    font-weight: normal;\n    padding: 4px 4px 0 0;\n  }\n  \n  :global(.signal-popup .leaflet-popup-close-button:hover) {\n    color: #fff;\n  }\n  \n  /* Pi System Info Popup - styled like Kismet device boxes */\n  :global(.pi-popup .leaflet-popup-content-wrapper) {\n    background: #2a2a2a;\n    border: 1px solid #444;\n    border-radius: 6px;\n    box-shadow: 0 3px 14px rgba(0, 0, 0, 0.5);\n    color: #fff;\n  }\n  \n  :global(.pi-popup .leaflet-popup-tip) {\n    background: #2a2a2a;\n    border-bottom: 1px solid #444;\n    border-right: 1px solid #444;\n  }\n  \n  :global(.pi-popup .leaflet-popup-content) {\n    margin: 12px;\n  }\n  \n  :global(.pi-popup .leaflet-popup-close-button) {\n    color: #888;\n    font-size: 20px;\n    font-weight: normal;\n  }\n  \n  :global(.pi-popup .leaflet-popup-close-button:hover) {\n    color: #fff;\n  }\n  \n  /* Kismet Device Icons */\n  :global(.kismet-marker) {\n    background: transparent !important;\n    border: none !important;\n  }\n  \n  :global(.kismet-marker svg) {\n    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));\n  }\n\n  /* iPhone Portrait Mode (320px - 428px width) */\n  @media (max-width: 428px) and (orientation: portrait) {\n    .tactical-map-simple {\n      height: 100vh;\n      overflow: hidden;\n    }\n    \n    /* Search Bar - Compact for portrait */\n    .search-bar {\n      padding: 8px;\n      flex-direction: column;\n      gap: 8px;\n      position: sticky;\n      top: 0;\n      z-index: 1000;\n    }\n    \n    .search-container {\n      min-width: auto;\n      width: 100%;\n      flex-direction: column;\n      gap: 8px;\n    }\n    \n    /* Back button - smaller in portrait */\n    .back-console-button {\n      width: 100%;\n      font-size: 12px;\n      padding: 6px 12px;\n    }\n    \n    /* MAC whitelist - full width */\n    .kismet-whitelist {\n      width: 100%;\n      flex-direction: row;\n      gap: 8px;\n    }\n    \n    .mac-label {\n      font-size: 11px;\n      padding: 6px 10px;\n      height: 32px;\n      white-space: nowrap;\n    }\n    \n    .mac-input {\n      flex: 1;\n      width: auto !important;\n      min-width: 0;\n      font-size: 13px;\n      padding: 6px 10px;\n    }\n    \n    /* Frequency inputs - horizontal scroll if needed */\n    .frequency-inputs {\n      width: 100%;\n      display: flex;\n      gap: 6px;\n      overflow-x: auto;\n      -webkit-overflow-scrolling: touch;\n    }\n    \n    .frequency-input-small {\n      min-width: 80px;\n      width: 30%;\n      font-size: 13px;\n      padding: 6px 8px;\n    }\n    \n    /* Buttons - side by side */\n    .search-button,\n    .clear-button {\n      flex: 1;\n      font-size: 14px;\n      padding: 8px 12px;\n    }\n    \n    /* Status - minimal in portrait */\n    .status {\n      width: 100%;\n      font-size: 11px;\n      justify-content: center;\n    }\n    \n    /* Map container - maximize space */\n    .map-container {\n      flex: 1;\n      width: 100%;\n      min-height: 0; /* Allow shrinking */\n      position: relative;\n    }\n    \n    /* Legend - bottom right of map */\n    .signal-legend {\n      position: absolute !important;\n      bottom: 10px !important;\n      right: 10px !important;\n      left: auto !important;\n      width: auto;\n      max-width: 60%;\n      background: rgba(0, 0, 0, 0.9) !important;\n      padding: 8px !important;\n      border-radius: 8px;\n      font-size: 10px;\n      z-index: 999;\n      max-height: 120px;\n      overflow-y: auto;\n    }\n    \n    .legend-title {\n      font-size: 11px;\n      display: block;\n      margin-bottom: 4px;\n    }\n    \n    .legend-item {\n      font-size: 10px;\n      display: inline-block;\n      margin-right: 8px;\n      margin-bottom: 4px;\n    }\n    \n    .legend-color {\n      width: 12px;\n      height: 12px;\n    }\n    \n    /* Footer - hidden in portrait to save space */\n    .footer {\n      display: none;\n    }\n    \n    /* GPS waiting overlay */\n    .gps-waiting {\n      font-size: 14px;\n    }\n    \n    .gps-icon {\n      width: 48px;\n      height: 48px;\n    }\n    \n    /* Reduce footer heights for more map space on portrait */\n    .signal-info {\n      height: 40px !important;\n      padding: 4px 8px !important;\n      font-size: 11px;\n    }\n    \n    .data-footer {\n      height: 40px !important;\n      padding: 4px 8px !important;\n    }\n    \n    /* HackRF footer specific adjustments for 40px height in portrait */\n    .data-footer .footer-section {\n      font-size: 10px !important;\n      gap: 6px !important;\n    }\n    \n    .data-footer .footer-label {\n      font-size: 10px !important;\n      margin-right: 4px !important;\n    }\n    \n    .data-footer .footer-divider {\n      height: 16px !important;\n      margin: 0 6px !important;\n    }\n    \n    /* HackRF buttons - properly sized for 40px container in portrait */\n    .data-footer .saasfly-btn {\n      height: 28px !important;\n      padding: 3px 8px !important;\n      font-size: 10px !important;\n      gap: 4px !important;\n      display: flex !important;\n      align-items: center !important;\n      justify-content: center !important;\n      white-space: nowrap !important;\n    }\n    \n    .data-footer .saasfly-btn svg {\n      width: 14px !important;\n      height: 14px !important;\n      flex-shrink: 0 !important;\n    }\n    \n    /* Ensure proper vertical centering in 40px container */\n    .data-footer {\n      display: flex !important;\n      align-items: center !important;\n    }\n    \n    /* HackRF status text adjustments */\n    .data-footer .frequency-value,\n    .data-footer .signal-count,\n    .data-footer .power-value {\n      font-size: 10px !important;\n    }\n    \n    /* Kismet label compact styling */\n    .kismet-label {\n      font-size: 10px !important;\n      gap: 4px !important;\n    }\n    \n    .kismet-label svg {\n      width: 16px !important;\n      height: 16px !important;\n    }\n    \n    .kismet-title {\n      font-size: 10px !important;\n    }\n  }\n  \n  /* iPhone Landscape Mode (568px - 926px width) */\n  @media (max-height: 428px) and (orientation: landscape) {\n    .tactical-map-simple {\n      height: 100vh;\n      overflow: hidden;\n    }\n    \n    /* Search Bar - Reduced padding by 10px from top/bottom */\n    .search-bar {\n      padding: 2px 12px;\n      flex-direction: row;\n      gap: 8px;\n      flex-wrap: nowrap;\n      height: 40px;  /* Match the footer heights */\n    }\n    \n    .search-container {\n      flex-direction: row;\n      gap: 4px;\n      align-items: center;\n    }\n    \n    /* Back button - more compact */\n    .back-console-button {\n      font-size: 11px;\n      padding: 2px 8px;\n      white-space: nowrap;\n      height: 24px;\n    }\n    \n    .back-console-button svg {\n      width: 12px;\n      height: 12px;\n    }\n    \n    /* MAC whitelist - more compact to prevent overlap */\n    .kismet-whitelist {\n      flex-direction: row;\n      align-items: center;\n      gap: 4px;\n    }\n    \n    .mac-label {\n      font-size: 9px;\n      padding: 2px 6px;\n      height: 24px;\n      white-space: nowrap;\n    }\n    \n    .mac-input {\n      width: 120px !important;\n      font-size: 11px;\n      padding: 2px 6px;\n      height: 24px;\n    }\n    \n    /* Frequency inputs - more compact */\n    .frequency-inputs {\n      flex-direction: row;\n      gap: 3px;\n    }\n    \n    .frequency-input-small {\n      width: 65px !important;\n      font-size: 11px;\n      padding: 2px 4px;\n      height: 24px;\n    }\n    \n    /* Buttons - smaller to prevent overlap */\n    .search-button,\n    .clear-button {\n      font-size: 11px;\n      padding: 2px 10px;\n      height: 24px;\n      white-space: nowrap;\n    }\n    \n    /* Status - more compact */\n    .status {\n      font-size: 9px;\n      gap: 0.5rem;\n    }\n    \n    /* Map container - full remaining space */\n    .map-container {\n      flex: 1;\n      width: 100%;\n      position: relative;\n    }\n    \n    /* Legend - bottom right of map */\n    .signal-legend {\n      position: absolute !important;\n      bottom: 10px !important;\n      right: 10px !important;\n      top: auto !important;\n      left: auto !important;\n      width: 180px;\n      background: rgba(0, 0, 0, 0.9) !important;\n      padding: 4px 6px !important;\n      border-radius: 6px;\n      font-size: 8px;\n      z-index: 999;\n    }\n    \n    .legend-title {\n      font-size: 9px;\n      margin-bottom: 2px;\n    }\n    \n    .legend-item {\n      font-size: 8px;\n      display: block;\n      margin-bottom: 1px;\n    }\n    \n    .legend-color {\n      width: 8px;\n      height: 8px;\n    }\n    \n    /* Footer - hidden in landscape */\n    .footer {\n      display: none;\n    }\n    \n    /* GPS waiting - smaller */\n    .gps-waiting {\n      font-size: 11px;\n    }\n    \n    .gps-icon {\n      width: 32px;\n      height: 32px;\n    }\n    \n    .gps-waiting h3 {\n      font-size: 12px;\n    }\n    \n    /* Signal info popup - compact */\n    .signal-info {\n      font-size: 9px;\n      padding: 3px 6px;\n    }\n    \n    /* Status items - prevent overlap */\n    .status-item {\n      white-space: nowrap;\n    }\n    \n    .status-value {\n      font-size: 9px;\n    }\n    \n    /* Reduce footer heights for more map space */\n    .signal-info {\n      height: 40px !important;\n      padding: 2px 8px !important;\n    }\n    \n    .data-footer {\n      height: 40px !important;\n      padding: 2px 8px !important;\n    }\n    \n    /* HackRF footer specific adjustments for 40px height */\n    .data-footer .footer-section {\n      font-size: 8px !important;\n      gap: 4px !important;\n    }\n    \n    .data-footer .footer-label {\n      font-size: 8px !important;\n      margin-right: 2px !important;\n    }\n    \n    .data-footer .footer-divider {\n      height: 14px !important;\n      margin: 0 4px !important;\n    }\n    \n    /* HackRF buttons - properly sized for 40px container */\n    .data-footer .saasfly-btn {\n      height: 24px !important;\n      padding: 2px 6px !important;\n      font-size: 9px !important;\n      gap: 4px !important;\n      display: flex !important;\n      align-items: center !important;\n      justify-content: center !important;\n      white-space: nowrap !important;\n    }\n    \n    .data-footer .saasfly-btn svg {\n      width: 12px !important;\n      height: 12px !important;\n      flex-shrink: 0 !important;\n    }\n    \n    /* Ensure proper vertical centering in 40px container */\n    .data-footer {\n      display: flex !important;\n      align-items: center !important;\n    }\n    \n    /* HackRF status text adjustments */\n    .data-footer .frequency-value,\n    .data-footer .signal-count,\n    .data-footer .power-value {\n      font-size: 9px !important;\n    }\n    \n    /* Kismet label compact styling */\n    .kismet-label {\n      font-size: 9px !important;\n      gap: 3px !important;\n      padding-right: 10px !important;  /* Reduced padding */\n    }\n    \n    .kismet-label svg {\n      width: 14px !important;\n      height: 14px !important;\n    }\n    \n    .kismet-title {\n      font-size: 9px !important;\n    }\n    \n    /* Kismet footer specific adjustments for landscape */\n    .signal-info .footer-section {\n      font-size: 8px !important;\n      gap: 4px !important;\n      flex-wrap: nowrap !important;\n      white-space: nowrap !important;\n    }\n    \n    .signal-info .footer-label {\n      font-size: 8px !important;\n      margin-right: 2px !important;\n      white-space: nowrap !important;\n    }\n    \n    .signal-info .footer-divider {\n      height: 14px !important;\n      margin: 0 4px !important;\n    }\n    \n    /* Fix text cutoff for \"Total Devices Whitelisted\" in landscape */\n    .signal-info .footer-section:last-child {\n      min-width: 0;\n      flex: 0 1 auto;\n    }\n    \n    .signal-info .footer-section:last-child .footer-label {\n      font-size: 7px !important;  /* Smaller font for the long text */\n    }\n    \n    /* Ensure signal distribution icons don't overflow */\n    .signal-info .signal-stat,\n    .signal-info .device-stat {\n      font-size: 7px !important;\n      gap: 2px !important;\n    }\n    \n    .signal-info .signal-indicator {\n      width: 8px !important;\n      height: 8px !important;\n    }\n    \n    .signal-info svg {\n      width: 12px !important;\n      height: 12px !important;\n    }\n    \n    /* Reduce gap between footer sections */\n    .signal-info {\n      gap: 8px !important;\n    }\n  }\n  \n  /* Tablet and Desktop - General Mobile Responsive */\n  @media (max-width: 768px) {\n    /* Header adjustments */\n    .header {\n      padding: 8px;\n    }\n    \n    h1 {\n      font-size: 1.2em;\n    }\n    \n    /* Search bar - make it fully responsive */\n    .search-bar {\n      padding: 0.75rem;\n      flex-direction: column;\n      gap: 10px;\n    }\n    \n    .search-container {\n      min-width: auto;\n      width: 100%;\n      flex-direction: column;\n      gap: 10px;\n    }\n    \n    /* Frequency inputs - remove fixed width */\n    input[type=\"number\"] {\n      width: 100% !important;\n      min-width: 0;\n    }\n    \n    /* MAC input - full width */\n    input[type=\"text\"] {\n      width: 100% !important;\n      min-width: 0;\n    }\n    \n    /* Search button - full width on mobile */\n    button {\n      width: 100%;\n      margin-top: 8px;\n    }\n    \n    /* Map container - ensure proper sizing */\n    .map-container {\n      width: 100vw;\n      margin-left: -0.75rem;\n      margin-right: -0.75rem;\n      min-height: 400px;\n    }\n    \n    /* Legend - reposition to avoid overlap */\n    .legend {\n      position: relative !important;\n      margin: 10px;\n      right: auto !important;\n      bottom: auto !important;\n      width: calc(100% - 20px);\n      max-width: 100%;\n      background: rgba(0, 12, 28, 0.95);\n    }\n    \n    /* Status section */\n    .status {\n      font-size: 12px;\n      gap: 1rem;\n      flex-wrap: wrap;\n      justify-content: center;\n    }\n    \n    .status-item {\n      min-width: 100px;\n    }\n    \n    /* Signal info */\n    .signal-info {\n      padding: 0.5rem 0.75rem;\n      font-size: 12px;\n    }\n    \n    /* Footer - stack all sections vertically */\n    .footer {\n      grid-template-columns: 1fr !important;\n      gap: 15px;\n      padding: 15px 10px;\n    }\n    \n    .footer-section {\n      border-right: none !important;\n      border-bottom: 1px solid rgba(0, 220, 255, 0.2);\n      padding-right: 0;\n      padding-bottom: 15px;\n    }\n    \n    .footer-section:last-child {\n      border-bottom: none;\n      padding-bottom: 0;\n    }\n    \n    .footer-section h3 {\n      font-size: 0.9em;\n      margin-bottom: 8px;\n    }\n    \n    .footer-section p {\n      font-size: 0.85em;\n      line-height: 1.4;\n    }\n    \n    /* Footer status items */\n    .footer-status {\n      flex-direction: column;\n      gap: 8px;\n      font-size: 0.85em;\n    }\n    \n    .footer-status .status-dot {\n      margin-right: 6px;\n    }\n    \n    /* Footer actions */\n    .footer-actions {\n      flex-direction: column;\n      gap: 8px;\n    }\n    \n    .btn-footer {\n      width: 100%;\n      font-size: 0.85em;\n      padding: 8px 12px;\n    }\n    \n    /* Stats grid */\n    .stats-grid {\n      font-size: 0.85em;\n      gap: 8px;\n    }\n    \n    /* GPS info */\n    .gps-info {\n      font-size: 0.85em;\n      flex-wrap: wrap;\n      justify-content: center;\n    }\n    \n    .gps-stat {\n      min-width: 80px;\n    }\n    \n    /* Distribution charts */\n    .distribution-grid {\n      gap: 10px;\n    }\n    \n    .distribution-chart h4 {\n      font-size: 0.85em;\n    }\n    \n    .chart-bar-label {\n      font-size: 0.7em;\n    }\n    \n    .chart-bar-count {\n      font-size: 0.65em;\n    }\n    \n    /* Device count display */\n    .device-count {\n      font-size: 0.9em;\n    }\n  }\n</style>",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/tactical-map-simple/SignalAggregator.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/test-db-client/+page.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/test-hackrf-stop/+page.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/test-map/+page.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/test-simple/+page.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/test-time-filter/+page.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/test/+page.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/viewspectrum/+page.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/routes/wigletotak/+page.svelte",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/types/leaflet.d.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'L' is defined but never used. Allowed unused vars must match /^_/u.",
				"line": 2,
				"column": 18,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 2,
				"endColumn": 19
			},
			{
				"ruleId": "@typescript-eslint/no-redundant-type-constituents",
				"severity": 2,
				"message": "'Marker' is an 'error' type that acts as 'any' and overrides all other types in this union type.",
				"line": 74,
				"column": 32,
				"nodeType": "TSTypeReference",
				"messageId": "errorTypeOverrides",
				"endLine": 74,
				"endColumn": 40
			}
		],
		"suppressedMessages": [],
		"errorCount": 2,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "// Type definitions for Leaflet extensions and custom implementations\nimport type * as L from 'leaflet';\n\ndeclare module 'leaflet.heat' {\n  import * as L from 'leaflet';\n  \n  export interface HeatLatLngTuple extends Array<number> {\n    0: number; // latitude\n    1: number; // longitude\n    2?: number; // intensity\n  }\n  \n  export interface HeatMapOptions {\n    minOpacity?: number;\n    maxZoom?: number;\n    max?: number;\n    radius?: number;\n    blur?: number;\n    gradient?: { [key: number]: string };\n  }\n  \n  export interface HeatLayer extends L.Layer {\n    setLatLngs(latlngs: HeatLatLngTuple[]): this;\n    addLatLng(latlng: HeatLatLngTuple): this;\n    setOptions(options: HeatMapOptions): this;\n    redraw(): this;\n  }\n  \n  export function heatLayer(\n    latlngs?: HeatLatLngTuple[],\n    options?: HeatMapOptions\n  ): HeatLayer;\n}\n\ndeclare module 'leaflet.markercluster' {\n  import * as L from 'leaflet';\n  \n  export interface MarkerClusterGroupOptions extends L.LayerOptions {\n    maxClusterRadius?: number | ((zoom: number) => number);\n    clusterPane?: string;\n    spiderfyOnMaxZoom?: boolean;\n    showCoverageOnHover?: boolean;\n    zoomToBoundsOnClick?: boolean;\n    singleMarkerMode?: boolean;\n    disableClusteringAtZoom?: number;\n    removeOutsideVisibleBounds?: boolean;\n    animate?: boolean;\n    animateAddingMarkers?: boolean;\n    spiderfyDistanceMultiplier?: number;\n    spiderLegPolylineOptions?: L.PolylineOptions;\n    chunkedLoading?: boolean;\n    chunkInterval?: number;\n    chunkDelay?: number;\n    chunkProgress?: (processed: number, total: number, elapsed: number) => void;\n    polygonOptions?: L.PolylineOptions;\n    iconCreateFunction?: (cluster: MarkerCluster) => L.Icon;\n  }\n  \n  export interface MarkerCluster extends L.Marker {\n    getChildCount(): number;\n    getAllChildMarkers(): L.Marker[];\n    spiderfy(): void;\n    unspiderfy(): void;\n  }\n  \n  export class MarkerClusterGroup extends L.FeatureGroup {\n    constructor(options?: MarkerClusterGroupOptions);\n    addLayer(layer: L.Layer): this;\n    removeLayer(layer: L.Layer): this;\n    addLayers(layers: L.Layer[]): this;\n    removeLayers(layers: L.Layer[]): this;\n    clearLayers(): this;\n    getVisibleParent(marker: L.Marker): MarkerCluster | null;\n    refreshClusters(clusters?: L.Marker | L.Marker[]): this;\n    getChildCount(): number;\n    getAllChildMarkers(): L.Marker[];\n    hasLayer(layer: L.Layer): boolean;\n    zoomToShowLayer(layer: L.Layer, callback?: () => void): this;\n  }\n  \n  export function markerClusterGroup(options?: MarkerClusterGroupOptions): MarkerClusterGroup;\n}\n\n// Extend Leaflet namespace\ndeclare module 'leaflet' {\n  export interface Icon {\n    options: IconOptions;\n  }\n  \n  export interface IconOptions {\n    iconUrl?: string;\n    iconRetinaUrl?: string;\n    iconSize?: [number, number];\n    iconAnchor?: [number, number];\n    popupAnchor?: [number, number];\n    tooltipAnchor?: [number, number];\n    shadowUrl?: string;\n    shadowRetinaUrl?: string;\n    shadowSize?: [number, number];\n    shadowAnchor?: [number, number];\n    className?: string;\n  }\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/types/signals.d.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/src/types/system.d.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/static/api-config.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/static/hackrf/api-config.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/static/hackrf/script.js",
		"messages": [
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'cycleCountdown' is assigned a value but never used.",
				"line": 13,
				"column": 5,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 13,
				"endColumn": 19,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "cycleCountdown" },
						"fix": { "range": [280, 306], "text": "" },
						"desc": "Remove unused variable 'cycleCountdown'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'cycleInterval' is assigned a value but never used.",
				"line": 14,
				"column": 5,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 14,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "cycleInterval" },
						"fix": { "range": [307, 332], "text": "" },
						"desc": "Remove unused variable 'cycleInterval'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'updateRemoveButtons' is defined but never used.",
				"line": 469,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 469,
				"endColumn": 29,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "updateRemoveButtons" },
						"fix": { "range": [18177, 19910], "text": "" },
						"desc": "Remove unused variable 'updateRemoveButtons'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'data' is assigned a value but never used.",
				"line": 1247,
				"column": 19,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 1247,
				"endColumn": 23,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "data" },
						"fix": { "range": [47629, 47665], "text": "" },
						"desc": "Remove unused variable 'data'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'data' is assigned a value but never used.",
				"line": 1263,
				"column": 19,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 1263,
				"endColumn": 23,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "data" },
						"fix": { "range": [48258, 48294], "text": "" },
						"desc": "Remove unused variable 'data'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'data' is assigned a value but never used.",
				"line": 1316,
				"column": 19,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 1316,
				"endColumn": 23,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "data" },
						"fix": { "range": [50051, 50087], "text": "" },
						"desc": "Remove unused variable 'data'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'updateButtonStatesFromServerState' is defined but never used.",
				"line": 1938,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 1938,
				"endColumn": 43,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "updateButtonStatesFromServerState" },
						"fix": { "range": [76765, 78564], "text": "" },
						"desc": "Remove unused variable 'updateButtonStatesFromServerState'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'setCyclingPriority' is defined but never used.",
				"line": 2124,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2124,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "setCyclingPriority" },
						"fix": { "range": [84421, 84864], "text": "" },
						"desc": "Remove unused variable 'setCyclingPriority'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'isCyclingActive' is defined but never used.",
				"line": 2139,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2139,
				"endColumn": 25,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "isCyclingActive" },
						"fix": { "range": [84866, 84944], "text": "" },
						"desc": "Remove unused variable 'isCyclingActive'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'shouldBypassSyncGuards' is defined but never used.",
				"line": 2143,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2143,
				"endColumn": 32,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "shouldBypassSyncGuards" },
						"fix": { "range": [84946, 85393], "text": "" },
						"desc": "Remove unused variable 'shouldBypassSyncGuards'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'stopButton' is assigned a value but never used.",
				"line": 2226,
				"column": 11,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2226,
				"endColumn": 21,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "stopButton" },
						"fix": { "range": [87671, 87728], "text": "" },
						"desc": "Remove unused variable 'stopButton'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'createCopyErrorButton' is defined but never used.",
				"line": 2368,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2368,
				"endColumn": 31,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "createCopyErrorButton" },
						"fix": { "range": [93445, 94261], "text": "" },
						"desc": "Remove unused variable 'createCopyErrorButton'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'clearErrorStates' is defined but never used.",
				"line": 2541,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2541,
				"endColumn": 26,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "clearErrorStates" },
						"fix": { "range": [100099, 100164], "text": "" },
						"desc": "Remove unused variable 'clearErrorStates'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'data' is assigned a value but never used.",
				"line": 2554,
				"column": 19,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2554,
				"endColumn": 23,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "data" },
						"fix": { "range": [100424, 100459], "text": "" },
						"desc": "Remove unused variable 'data'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'error' is defined but never used.",
				"line": 2563,
				"column": 14,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2563,
				"endColumn": 19
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'addDebugPanel' is defined but never used.",
				"line": 2571,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2571,
				"endColumn": 23,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "addDebugPanel" },
						"fix": { "range": [100891, 100946], "text": "" },
						"desc": "Remove unused variable 'addDebugPanel'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'updateDebugInfo' is defined but never used.",
				"line": 2576,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2576,
				"endColumn": 25,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "updateDebugInfo" },
						"fix": { "range": [100986, 101049], "text": "" },
						"desc": "Remove unused variable 'updateDebugInfo'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'copyDebugInfo' is defined but never used.",
				"line": 2581,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2581,
				"endColumn": 23,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "copyDebugInfo" },
						"fix": { "range": [101100, 101159], "text": "" },
						"desc": "Remove unused variable 'copyDebugInfo'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'testConnection' is defined but never used.",
				"line": 2586,
				"column": 16,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2586,
				"endColumn": 30,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "testConnection" },
						"fix": { "range": [101199, 101265], "text": "" },
						"desc": "Remove unused variable 'testConnection'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'getErrorHistory' is defined but never used.",
				"line": 2591,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2591,
				"endColumn": 25,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "getErrorHistory" },
						"fix": { "range": [101316, 101459], "text": "" },
						"desc": "Remove unused variable 'getErrorHistory'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'data' is defined but never used.",
				"line": 2686,
				"column": 47,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2686,
				"endColumn": 51,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "data" },
						"fix": { "range": [104603, 104609], "text": "" },
						"desc": "Remove unused variable 'data'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'data' is defined but never used.",
				"line": 2932,
				"column": 45,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2932,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "data" },
						"fix": { "range": [114019, 114025], "text": "" },
						"desc": "Remove unused variable 'data'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'toggleDebugMode' is defined but never used.",
				"line": 3046,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 3046,
				"endColumn": 25,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "toggleDebugMode" },
						"fix": { "range": [117669, 117732], "text": "" },
						"desc": "Remove unused variable 'toggleDebugMode'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'performEnhancedHealthCheck' is defined but never used.",
				"line": 3187,
				"column": 16,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 3187,
				"endColumn": 42,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "performEnhancedHealthCheck" },
						"fix": { "range": [122719, 124206], "text": "" },
						"desc": "Remove unused variable 'performEnhancedHealthCheck'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'error' is defined but never used.",
				"line": 3222,
				"column": 14,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 3222,
				"endColumn": 19
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'formatDuration' is defined but never used.",
				"line": 3236,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 3236,
				"endColumn": 24,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "formatDuration" },
						"fix": { "range": [124349, 124679], "text": "" },
						"desc": "Remove unused variable 'formatDuration'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'formatFrequency' is defined but never used.",
				"line": 3251,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 3251,
				"endColumn": 25,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "formatFrequency" },
						"fix": { "range": [124734, 124974], "text": "" },
						"desc": "Remove unused variable 'formatFrequency'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'capitalizeFirst' is defined but never used.",
				"line": 3264,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 3264,
				"endColumn": 25,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "capitalizeFirst" },
						"fix": { "range": [125023, 125150], "text": "" },
						"desc": "Remove unused variable 'capitalizeFirst'."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 28,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "// HackRF Monitor Frontend JavaScript\n\n// API Configuration\n// Use local API endpoints within the SvelteKit app\nconst API_BASE_URL = `/api/hackrf`;\n\nconst MAX_FREQUENCIES = 10;\n\nlet eventSource = null;\nlet isScanning = false;\nlet isCycling = false;\nlet currentFrequencyIndex = 0;\nlet cycleCountdown = null;\nlet cycleInterval = null;\nlet cycleTimer = null;\nlet connectionRetryCount = 0;\nlet maxRetryAttempts = 3;\nlet startupTimeout = null;\nlet connectionStatus = 'disconnected';\nlet isSynchronizing = false;  // Prevent sync loops\nlet sseConnectionActive = false;  // Track SSE connection state\nlet globalCycleTime = 30;  // Store cycle time globally for timer sync\nlet globalFrequencies = [];   // Store frequencies globally for next frequency calculation\nlet isRestoringState = false;  // Flag to prevent operations during state restoration\nlet performanceMode = true;   // Reduce verbose tracking for better performance\nlet syncInProgress = false;  // Guard flag to prevent startSweep during sync\nlet activeCyclingOperation = false;  // Flag to track active cycling operations\nlet reducedSyncMode = false;  // Flag to reduce sync frequency during cycling\nlet lastSyncTime = 0;  // Track sync timing for frequency reduction\nlet signalResetInProgress = false;  // Flag to coordinate signal indicator reset timing\n\n// Function to reset all blocking sync flags - emergency recovery\nfunction resetSyncFlags() {\n    console.log('🔄 Resetting all synchronization flags');\n    isSynchronizing = false;\n    syncInProgress = false;\n    isRestoringState = false;\n    signalResetInProgress = false;\n    console.log('✅ All sync flags cleared');\n}\n\n// Enhanced error tracking and operation logging system\nwindow.recentOperations = [];\nwindow.startSweepTracker = {\n    attempts: [],\n    lastUserInitiated: null,\n    lastSystemInitiated: null\n};\n\n// Enhanced operation tracking with call source detection\nfunction trackOperation(operation, context = {}) {\n    // Skip non-critical tracking in performance mode\n    if (performanceMode && context.source && context.source.includes('cycling')) {\n        return; // Skip verbose cycling operations\n    }\n    \n    const timestamp = new Date().toLocaleTimeString();\n    const stackTrace = performanceMode ? [] : getCallStack(); // Skip stack traces in performance mode\n    \n    const operationEntry = {\n        timestamp,\n        operation,\n        context,\n        callSource: context.source || 'unknown',\n        stackTrace: performanceMode ? [] : stackTrace.slice(0, 3)\n    };\n    \n    window.recentOperations.unshift(`[${timestamp}] ${operation} (${context.source || 'unknown'})`);\n    if (window.recentOperations.length > (performanceMode ? 15 : 30)) { // Reduced buffer in performance mode\n        window.recentOperations.pop();\n    }\n    \n    // Store detailed operation for debugging (reduced in performance mode)\n    if (!performanceMode) {\n        if (!window.detailedOperations) window.detailedOperations = [];\n        window.detailedOperations.unshift(operationEntry);\n        if (window.detailedOperations.length > 25) { // Reduced from 50\n            window.detailedOperations.pop();\n        }\n    }\n}\n\n// Get simplified call stack for tracking\nfunction getCallStack() {\n    try {\n        throw new Error();\n    } catch (e) {\n        return e.stack.split('\\n')\n            .slice(2) // Remove getCallStack and Error lines\n            .map(line => line.trim())\n            .filter(line => line.length > 0);\n    }\n}\n\n// Initialize on page load\ndocument.addEventListener('DOMContentLoaded', () => {\n    try {\n        // Reset all sync flags on page load to prevent stuck states\n        resetSyncFlags();\n        \n        trackOperation('Application initialized', { source: 'page_load' });\n        setupEventHandlers();\n        \n        updateButtonStates();\n        updateAddButtonState();\n        // updateRemoveButtons(); // Commented out to prevent duplicate remove buttons\n        updateConnectionStatus();\n        \n        // Initialize cycle status display with defaults (always visible)\n        initializeCycleStatus();\n        \n        // Add validation listener for the initial frequency input\n        const initialInput = document.getElementById('frequencyInput1');\n        if (initialInput) {\n            initialInput.addEventListener('input', function() {\n                validateFrequencyInputById(this.id);\n            });\n        }\n        \n        // Perform startup health check\n        performStartupHealthCheck();\n        \n        // Perform initial health check\n        performHealthCheck();\n        \n        // Synchronize with server state on page load - critical for split brain fix\n        setTimeout(() => {\n            synchronizeWithServerState('initialization');\n        }, 1000);\n        \n        // Start proactive state validation monitoring\n        startProactiveStateValidation();\n        \n        // Also sync state every 30 seconds to catch any drift\n        // Reduced frequency during active cycling to prevent interference\n        setInterval(() => {\n            if (connectionStatus === 'connected') {\n                // Skip periodic sync if cycling and recent sync occurred\n                if (reducedSyncMode && activeCyclingOperation) {\n                    const timeSinceLastSync = Date.now() - lastSyncTime;\n                    if (timeSinceLastSync < 60000) { // Skip if synced within last minute\n                        trackOperation('Periodic sync skipped - cycling mode active', {\n                            source: 'sync_reduction',\n                            timeSinceLastSync\n                        });\n                        return;\n                    }\n                }\n                synchronizeWithServerState('periodic');\n            }\n        }, 30000);\n        \n        showStatus('Application initialized successfully', 'success');\n    } catch (error) {\n        logError('initialization', error, { source: 'page_load' });\n        showStatus('Application initialization failed: ' + error.message, 'error');\n    }\n});\n\n// Setup event handlers\nfunction setupEventHandlers() {\n    document.getElementById('startButton').addEventListener('click', () => {\n        trackOperation('Start button clicked', { source: 'user_click' });\n        startSweep('user_initiated');\n    });\n    document.getElementById('stopButton').addEventListener('click', () => {\n        trackOperation('Stop button clicked', { source: 'user_click' });\n        stopSweep();\n    });\n    \n    // Add frequency button\n    const addFreqBtn = document.getElementById('addFrequencyButton');\n    if (addFreqBtn) {\n        addFreqBtn.addEventListener('click', () => {\n            trackOperation('Add frequency button clicked', { source: 'user_click' });\n            addFrequencyInput();\n        });\n    }\n    \n    // Cycle time input validation\n    const cycleTimeInput = document.getElementById('cycleTimeInput');\n    if (cycleTimeInput) {\n        cycleTimeInput.addEventListener('input', validateCycleTime);\n    }\n}\n\n// Enhanced frequency validation with real-time feedback\nfunction validateFrequencyInputById(inputId) {\n    const frequencyInput = document.getElementById(inputId);\n    if (!frequencyInput) return false;\n    \n    const frequencyItem = frequencyInput.closest('.frequency-item');\n    const unitSelect = frequencyInput.nextElementSibling;\n    const unit = unitSelect ? unitSelect.value : 'MHz';\n    const value = parseFloat(frequencyInput.value);\n    \n    // Remove existing validation messages\n    removeValidationMessage(frequencyItem);\n    \n    // Clear visual indicators\n    frequencyItem.classList.remove('invalid', 'valid');\n    \n    // Empty input validation\n    if (!frequencyInput.value.trim()) {\n        showValidationMessage(frequencyItem, 'Please enter a frequency value', 'error');\n        frequencyInput.setCustomValidity('Please enter a frequency value');\n        frequencyItem.classList.add('invalid');\n        return false;\n    }\n    \n    // Numeric validation\n    if (isNaN(value) || value <= 0) {\n        showValidationMessage(frequencyItem, 'Please enter a valid positive number', 'error');\n        frequencyInput.setCustomValidity('Please enter a valid positive number');\n        frequencyItem.classList.add('invalid');\n        return false;\n    }\n    \n    // Convert to MHz for validation\n    let freqMHz = value;\n    if (unit === 'GHz') {\n        freqMHz = value * 1000;\n    } else if (unit === 'kHz') {\n        freqMHz = value / 1000;\n    }\n    \n    // Range validation with specific guidance\n    if (freqMHz < 1) {\n        showValidationMessage(frequencyItem, \n            `Frequency too low. Minimum: 1 MHz (you entered ${freqMHz.toFixed(3)} MHz)`, 'error');\n        frequencyInput.setCustomValidity('Frequency too low - minimum 1 MHz');\n        frequencyItem.classList.add('invalid');\n        return false;\n    }\n    \n    if (freqMHz > 6000) {\n        showValidationMessage(frequencyItem, \n            `Frequency too high. Maximum: 6 GHz (you entered ${freqMHz.toFixed(3)} MHz)`, 'error');\n        frequencyInput.setCustomValidity('Frequency too high - maximum 6 GHz');\n        frequencyItem.classList.add('invalid');\n        return false;\n    }\n    \n    // All validations passed\n    frequencyInput.setCustomValidity('');\n    frequencyItem.classList.add('valid');\n    \n    return true;\n}\n\n// Show validation message with styling - only for errors\nfunction showValidationMessage(frequencyItem, message, type) {\n    if (type === 'error') {\n        removeValidationMessage(frequencyItem);\n        \n        const messageDiv = document.createElement('div');\n        messageDiv.className = `validation-message validation-${type}`;\n        messageDiv.textContent = message;\n        \n        frequencyItem.appendChild(messageDiv);\n    }\n}\n\n// Remove existing validation message\nfunction removeValidationMessage(frequencyItem) {\n    const existingMessage = frequencyItem.querySelector('.validation-message');\n    if (existingMessage) {\n        existingMessage.remove();\n    }\n}\n\n// Validate all frequency inputs\nfunction validateAllFrequencyInputs() {\n    const frequencyItems = document.querySelectorAll('.frequency-item');\n    let allValid = true;\n    \n    frequencyItems.forEach((item) => {\n        const input = item.querySelector('input[type=\"text\"]');\n        if (input && !validateFrequencyInputById(input.id)) {\n            allValid = false;\n        }\n    });\n    \n    return allValid;\n}\n\n// Enhanced cycle time validation with helpful feedback\nfunction validateCycleTime() {\n    const cycleTimeInput = document.getElementById('cycleTimeInput');\n    if (!cycleTimeInput) return true;\n    \n    const value = parseInt(cycleTimeInput.value);\n    const container = cycleTimeInput.parentElement;\n    \n    // Remove existing validation messages\n    removeCycleTimeValidationMessage(container);\n    \n    // Clear visual indicators\n    cycleTimeInput.classList.remove('invalid', 'valid');\n    \n    // Empty input\n    if (!cycleTimeInput.value.trim()) {\n        showCycleTimeValidationMessage(container, 'Please enter a cycle time', 'error');\n        cycleTimeInput.setCustomValidity('Please enter a cycle time');\n        cycleTimeInput.classList.add('invalid');\n        return false;\n    }\n    \n    // Numeric validation\n    if (isNaN(value) || value <= 0) {\n        showCycleTimeValidationMessage(container, 'Please enter a valid positive number', 'error');\n        cycleTimeInput.setCustomValidity('Please enter a valid positive number');\n        cycleTimeInput.classList.add('invalid');\n        return false;\n    }\n    \n    // Range validation with guidance\n    if (value < 1) {\n        showCycleTimeValidationMessage(container, 'Minimum cycle time is 1 second', 'error');\n        cycleTimeInput.setCustomValidity('Minimum cycle time is 1 second');\n        cycleTimeInput.classList.add('invalid');\n        return false;\n    }\n    \n    if (value > 300) {\n        showCycleTimeValidationMessage(container, 'Maximum cycle time is 300 seconds (5 minutes)', 'error');\n        cycleTimeInput.setCustomValidity('Maximum cycle time is 300 seconds');\n        cycleTimeInput.classList.add('invalid');\n        return false;\n    }\n    \n    // Success validation\n    cycleTimeInput.setCustomValidity('');\n    cycleTimeInput.classList.add('valid');\n    \n    return true;\n}\n\n// Show cycle time validation message - only for errors\nfunction showCycleTimeValidationMessage(container, message, type) {\n    if (type === 'error') {\n        removeCycleTimeValidationMessage(container);\n        \n        const messageDiv = document.createElement('div');\n        messageDiv.className = `cycle-validation-message validation-${type}`;\n        messageDiv.textContent = message;\n        \n        container.appendChild(messageDiv);\n    }\n}\n\n// Remove cycle time validation message\nfunction removeCycleTimeValidationMessage(container) {\n    const existingMessage = container.querySelector('.cycle-validation-message');\n    if (existingMessage) {\n        existingMessage.remove();\n    }\n}\n\n// Add frequency input\nfunction addFrequencyInput() {\n    const currentCount = document.getElementsByClassName('frequency-item').length;\n    \n    if (currentCount >= MAX_FREQUENCIES) {\n        showStatus(`Maximum ${MAX_FREQUENCIES} frequencies allowed`, 'warning');\n        return;\n    }\n    \n    const container = document.getElementById('frequencyList');\n    const newItem = document.createElement('div');\n    const newIndex = currentCount + 1;\n    \n    newItem.className = 'frequency-item saasfly-interactive-card flex items-center gap-3 p-4 bg-gradient-to-r from-bg-card/40 to-bg-card/20 rounded-xl border border-border-primary/40 hover:border-neon-cyan/40 hover:bg-gradient-to-r hover:from-bg-card/60 hover:to-bg-card/40 hover:shadow-md transition-all duration-300';\n    newItem.id = `frequencyItem${newIndex}`;\n    \n    newItem.innerHTML = `\n        <span class=\"font-mono text-sm text-text-muted font-semibold min-w-[24px] text-center bg-neon-cyan/10 rounded-lg px-2 py-1\">${newIndex}</span>\n        <div class=\"flex-1 relative\">\n            <input type=\"text\" id=\"frequencyInput${newIndex}\" placeholder=\"Target\" value=\"\" class=\"font-mono w-full pl-3 pr-12 py-2 bg-bg-input/80 border border-border-primary/60 rounded-lg text-text-primary outline-none focus:border-neon-cyan focus:bg-bg-input focus:shadow-neon-cyan-sm transition-all duration-300 placeholder:text-text-muted/50\">\n            <span class=\"absolute right-3 top-1/2 -translate-y-1/2 font-mono text-sm text-text-secondary font-medium pointer-events-none\">MHz</span>\n        </div>\n        ${newIndex > 1 ? `<button type=\"button\" onclick=\"removeFrequencyInput('frequencyItem${newIndex}')\" style=\"padding: 6px 12px !important; background-color: #ef4444 !important; color: white !important; border: none !important; border-radius: 6px !important; font-size: 14px !important; font-weight: 500 !important; cursor: pointer !important; box-shadow: none !important; text-shadow: none !important; outline: none !important; transition: box-shadow 0.3s ease !important;\" onmouseover=\"this.style.boxShadow='0 0 10px rgba(255, 255, 255, 0.4)'\" onmouseout=\"this.style.boxShadow='none'\">Remove</button>` : ''}\n    `;\n    \n    container.appendChild(newItem);\n    \n    // Add validation listener (skip during state restoration to prevent race conditions)\n    if (!isRestoringState) {\n        document.getElementById(`frequencyInput${newIndex}`).addEventListener('input', function() {\n            validateFrequencyInputById(this.id);\n        });\n        \n        // Add remove button event listener if it exists\n        const removeBtn = newItem.querySelector('.remove-frequency-btn');\n        if (removeBtn) {\n            removeBtn.addEventListener('click', function() {\n                const itemId = this.getAttribute('data-item-id');\n                removeFrequencyInput(itemId);\n            });\n        }\n    }\n    \n    updateAddButtonState();\n    updateNumbering();\n}\n\n// Add event listeners to frequency inputs after state restoration\nfunction addEventListenersToFrequencyInputs() {\n    const frequencyItems = document.querySelectorAll('.frequency-item');\n    frequencyItems.forEach((item, index) => {\n        const input = item.querySelector('input[type=\"text\"]');\n        const removeBtn = item.querySelector('.remove-frequency-btn');\n        \n        if (input) {\n            // Remove existing listeners by cloning\n            const newInput = input.cloneNode(true);\n            input.parentNode.replaceChild(newInput, input);\n            \n            // Add validation listener\n            newInput.addEventListener('input', function() {\n                validateFrequencyInputById(this.id);\n            });\n        }\n        \n        if (removeBtn && index > 0) { // Only add to non-first items\n            // Remove existing listeners by cloning\n            const newRemoveBtn = removeBtn.cloneNode(true);\n            removeBtn.parentNode.replaceChild(newRemoveBtn, removeBtn);\n            \n            // Add remove button event listener\n            newRemoveBtn.addEventListener('click', function() {\n                const itemId = this.getAttribute('data-item-id');\n                removeFrequencyInput(itemId);\n            });\n        }\n    });\n}\n\n// Remove frequency input\nfunction removeFrequencyInput(itemId) {\n    // Don't allow removing the last frequency\n    const frequencyItems = document.querySelectorAll('.frequency-item');\n    if (frequencyItems.length <= 1) {\n        showStatus('At least one frequency is required', 'warning');\n        return;\n    }\n    \n    const item = document.getElementById(itemId);\n    if (item) {\n        item.remove();\n        updateAddButtonState();\n        updateNumbering();\n        // updateRemoveButtons(); // Commented out to prevent duplicate remove buttons\n    }\n}\n\n// Update numbering of frequency items\nfunction updateNumbering() {\n    const frequencyItems = document.querySelectorAll('.frequency-item');\n    frequencyItems.forEach((item, index) => {\n        const numberSpan = item.querySelector('.frequency-number');\n        if (numberSpan) {\n            numberSpan.textContent = index + 1;\n        }\n    });\n}\n\n// Update remove buttons (ensure first frequency item doesn't have remove button)\nfunction updateRemoveButtons() {\n    const frequencyItems = document.querySelectorAll('.frequency-item');\n    frequencyItems.forEach((item, index) => {\n        const removeBtn = item.querySelector('.remove-frequency-btn');\n        \n        if (index === 0) {\n            // First item should not have remove button\n            if (removeBtn) {\n                removeBtn.remove();\n            }\n        } else {\n            // Other items should have remove button\n            if (!removeBtn) {\n                const newRemoveBtn = document.createElement('button');\n                newRemoveBtn.type = 'button';\n                newRemoveBtn.className = 'remove-frequency-btn';\n                newRemoveBtn.textContent = 'Remove';\n                newRemoveBtn.setAttribute('data-item-id', item.id);\n                \n                newRemoveBtn.addEventListener('click', function() {\n                    const itemId = this.getAttribute('data-item-id');\n                    removeFrequencyInput(itemId);\n                });\n                \n                item.appendChild(newRemoveBtn);\n            } else {\n                // Update existing button's data-item-id and event listener\n                removeBtn.setAttribute('data-item-id', item.id);\n                \n                // Remove old event listeners by cloning the element\n                const newRemoveBtn = removeBtn.cloneNode(true);\n                newRemoveBtn.addEventListener('click', function() {\n                    const itemId = this.getAttribute('data-item-id');\n                    removeFrequencyInput(itemId);\n                });\n                \n                removeBtn.parentNode.replaceChild(newRemoveBtn, removeBtn);\n            }\n        }\n    });\n}\n\n// Update add button state\nfunction updateAddButtonState() {\n    const addBtn = document.getElementById('addFrequencyButton');\n    if (addBtn) {\n        const currentCount = document.getElementsByClassName('frequency-item').length;\n        addBtn.disabled = currentCount >= MAX_FREQUENCIES || isScanning;\n        if (currentCount >= MAX_FREQUENCIES) {\n            addBtn.textContent = `Maximum Reached (${MAX_FREQUENCIES})`;\n        } else {\n            addBtn.textContent = '+ Add Frequency';\n        }\n    }\n}\n\n// Collect all frequencies\nfunction collectFrequencies() {\n    const frequencies = [];\n    const frequencyItems = document.querySelectorAll('.frequency-item');\n    \n    frequencyItems.forEach((item) => {\n        const input = item.querySelector('input[type=\"text\"]');\n        \n        if (input && input.value) {\n            frequencies.push({\n                value: parseFloat(input.value),\n                unit: 'MHz'  // Always use MHz since dropdown is removed\n            });\n        }\n    });\n    \n    return frequencies;\n}\n\n// Enhanced startSweep with detailed tracking and error recovery\nasync function startSweep(initiationType = 'unknown') {\n    const attemptId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n    \n    // Track start attempt with detailed context\n    const attemptContext = {\n        attemptId,\n        type: initiationType,\n        timestamp: new Date().toISOString(),\n        source: initiationType === 'user_initiated' ? 'user_click' : 'system_call',\n        callStack: getCallStack().slice(0, 5),\n        currentState: {\n            isScanning,\n            isCycling,\n            connectionStatus,\n            sseConnectionActive\n        }\n    };\n    \n    window.startSweepTracker.attempts.push(attemptContext);\n    if (window.startSweepTracker.attempts.length > 10) {\n        window.startSweepTracker.attempts.shift();\n    }\n    \n    if (initiationType === 'user_initiated') {\n        window.startSweepTracker.lastUserInitiated = attemptContext;\n    } else {\n        window.startSweepTracker.lastSystemInitiated = attemptContext;\n    }\n    \n    trackOperation(`Start sweep initiated (${initiationType})`, {\n        source: attemptContext.source,\n        attemptId,\n        stateCheck: `scanning=${isScanning}, cycling=${isCycling}`\n    });\n    \n    // Synchronization guard flags - prevent start operations during sync or restoration\n    // CYCLING EXCEPTION: Allow cycling operations to bypass certain sync blocks\n    const isCyclingBypass = (initiationType === 'cycling' || activeCyclingOperation);\n    \n    if ((isSynchronizing || syncInProgress || isRestoringState) && !isCyclingBypass) {\n        // Emergency fallback: If sync flags have been stuck for too long, reset them\n        const now = Date.now();\n        if (!window.lastSyncBlockTime) {\n            window.lastSyncBlockTime = now;\n        } else if (now - window.lastSyncBlockTime > 10000) { // 10 seconds\n            console.warn('⚠️ Sync flags stuck for >10s - force resetting');\n            resetSyncFlags();\n            window.lastSyncBlockTime = null;\n            // Continue with startSweep after reset\n        } else {\n            trackOperation('Start sweep blocked: synchronization in progress', { \n                source: attemptContext.source,\n                attemptId,\n                recovery: 'Wait for synchronization to complete',\n                cyclingBypass: isCyclingBypass\n            });\n            console.log('Start sweep blocked due to synchronization/restoration in progress');\n            showEnhancedError('Operation blocked while synchronizing with server', 'startSweep', {\n                recovery: 'Please wait a moment for synchronization to complete and try again.',\n                context: attemptContext\n            });\n            return;\n        }\n    } else {\n        // Reset the block time when flags are clear\n        window.lastSyncBlockTime = null;\n    }\n    \n    // Pre-flight state check with recovery suggestions\n    if (isScanning) {\n        const errorMsg = 'Sweep is already running. Please stop the current sweep first.';\n        trackOperation('Start sweep blocked: already scanning', { \n            source: attemptContext.source,\n            attemptId,\n            recovery: 'Click Stop button first'\n        });\n        showEnhancedError(errorMsg, 'startSweep', {\n            recovery: 'Click the \"Stop Sweep\" button to stop the current operation before starting a new one.',\n            context: attemptContext\n        });\n        return;\n    }\n    \n    // Validate all frequencies\n    if (!validateAllFrequencyInputs()) {\n        const errorMsg = 'Please fix invalid frequency inputs before starting';\n        trackOperation('Start sweep failed: invalid frequency inputs', { \n            source: attemptContext.source,\n            attemptId,\n            recovery: 'Fix frequency validation errors'\n        });\n        showEnhancedError(errorMsg, 'startSweep', {\n            recovery: 'Check the frequency inputs for red validation messages and correct any errors.',\n            context: attemptContext\n        });\n        return;\n    }\n    \n    const frequencies = collectFrequencies();\n    if (frequencies.length === 0) {\n        const errorMsg = 'Please enter at least one frequency';\n        trackOperation('Start sweep failed: no frequencies entered', { \n            source: attemptContext.source,\n            attemptId,\n            recovery: 'Enter at least one frequency'\n        });\n        showEnhancedError(errorMsg, 'startSweep', {\n            recovery: 'Enter a valid frequency value in at least one frequency input field.',\n            context: attemptContext\n        });\n        return;\n    }\n    \n    // Validate cycle time if multiple frequencies\n    let cycleTime = 10; // Default cycle time\n    \n    if (frequencies.length > 1) {\n        if (!validateCycleTime()) {\n            const errorMsg = 'Invalid cycle time for multi-frequency operation';\n            trackOperation('Start sweep failed: invalid cycle time', { \n                source: attemptContext.source,\n                attemptId,\n                recovery: 'Set valid cycle time (1-300 seconds)'\n            });\n            showEnhancedError(errorMsg, 'startSweep', {\n                recovery: 'Enter a cycle time between 1 and 300 seconds for multi-frequency scanning.',\n                context: attemptContext\n            });\n            return;\n        }\n        const cycleTimeInput = document.getElementById('cycleTimeInput');\n        if (cycleTimeInput) {\n            cycleTime = parseInt(cycleTimeInput.value) || 10;\n        }\n    }\n    \n    // Show loading state\n    showStatus('Starting sweep...', 'info', true);\n    setLoadingState(true);\n    \n    trackOperation(`Starting sweep request for ${frequencies.length} frequencies`, {\n        source: attemptContext.source,\n        attemptId,\n        frequencies: frequencies.map(f => `${f.value}${f.unit}`).join(', '),\n        cycleTime\n    });\n    \n    // Set timeout for startup process with enhanced tracking\n    startupTimeout = setTimeout(() => {\n        if (!isScanning) {\n            const timeoutError = 'Startup timeout. Please check HackRF connection and try again.';\n            trackOperation('Start sweep timeout', {\n                source: attemptContext.source,\n                attemptId,\n                recovery: 'Check HackRF hardware connection'\n            });\n            showEnhancedError(timeoutError, 'startSweep', {\n                recovery: 'Check that your HackRF device is properly connected and powered on. Try unplugging and reconnecting the USB cable.',\n                context: attemptContext\n            });\n            setLoadingState(false);\n        }\n    }, 30000); // 30 second timeout\n    \n    try {\n        const requestBody = {\n            frequencies: frequencies,\n            cycleTime: cycleTime\n        };\n        \n        // For backward compatibility, if single frequency, also send old format\n        if (frequencies.length === 1) {\n            requestBody.frequency = frequencies[0].value;\n            requestBody.unit = frequencies[0].unit;\n        }\n        \n        trackOperation('Sending start-sweep request to server', {\n            source: attemptContext.source,\n            attemptId,\n            requestBody: JSON.stringify(requestBody)\n        });\n        \n        const response = await fetch(`${API_BASE_URL}/start-sweep`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(requestBody)\n        });\n        \n        const data = await response.json();\n        \n        if (response.ok) {\n            clearTimeout(startupTimeout);\n            isScanning = true;\n            isCycling = frequencies.length > 1;\n            currentFrequencyIndex = 0;\n            connectionRetryCount = 0;\n            connectionStatus = 'connected';\n            globalCycleTime = cycleTime;  // Store cycle time globally for timer sync\n            \n            // Set cycling mode flags for guard bypass and reduced sync\n            if (isCycling) {\n                activeCyclingOperation = true;\n                reducedSyncMode = true;\n                trackOperation('Cycling mode activated - reduced sync enabled', {\n                    source: attemptContext.source,\n                    frequencies: frequencies.length,\n                    cycleTime\n                });\n            }\n            \n            setLoadingState(false);\n            updateButtonStates();\n            updateConnectionStatus();\n            \n            trackOperation(`Start sweep successful (${initiationType})`, {\n                source: attemptContext.source,\n                attemptId,\n                frequencies: frequencies.length,\n                cycleTime,\n                cycling: isCycling\n            });\n            \n            if (isCycling) {\n                showCycleStatus(true);\n                startCycleDisplay(frequencies, cycleTime);\n                showStatus(`Started cycling ${frequencies.length} frequencies`, 'success');\n                trackOperation(`Sweep started: cycling ${frequencies.length} frequencies every ${cycleTime}s`, {\n                    source: attemptContext.source,\n                    attemptId\n                });\n            } else {\n                showStatus('Started monitoring single frequency', 'success');\n                trackOperation(`Sweep started: single frequency ${frequencies[0].value} ${frequencies[0].unit}`, {\n                    source: attemptContext.source,\n                    attemptId\n                });\n            }\n            \n            connectSSE();\n            updateFrequencyHighlight(0);\n        } else {\n            clearTimeout(startupTimeout);\n            setLoadingState(false);\n            \n            // Enhanced server error handling with detailed tracking\n            const errorMessage = data.error || 'Failed to start sweep';\n            trackOperation(`Start sweep server error: ${errorMessage}`, {\n                source: attemptContext.source,\n                attemptId,\n                serverResponse: data,\n                statusCode: response.status,\n                recovery: 'Check server logs and HackRF connection'\n            });\n            \n            let recoveryMessage = 'Try restarting the application or checking the server logs.';\n            if (errorMessage.toLowerCase().includes('hackrf')) {\n                recoveryMessage = 'Check that your HackRF device is properly connected and not in use by another application.';\n            } else if (errorMessage.toLowerCase().includes('frequency')) {\n                recoveryMessage = 'Verify that your frequency values are within the HackRF\\'s supported range (1 MHz to 6 GHz).';\n            }\n            \n            showEnhancedError(errorMessage, 'startSweep', {\n                recovery: recoveryMessage,\n                context: attemptContext\n            });\n        }\n    } catch (error) {\n        clearTimeout(startupTimeout);\n        setLoadingState(false);\n        \n        // Enhanced error tracking for network/connection issues\n        trackOperation(`Start sweep network error: ${error.message}`, {\n            source: attemptContext.source,\n            attemptId,\n            errorType: error.name,\n            recovery: 'Check network connection and server status'\n        });\n        \n        logError('startSweep', error, { \n            frequencies, \n            cycleTime,\n            attemptContext,\n            networkError: true\n        });\n        \n        // Update connection status if it's a network error\n        if (error.message.includes('Failed to fetch') || error.name === 'TypeError') {\n            connectionStatus = 'disconnected';\n            updateConnectionStatus();\n        }\n        \n        // Provide specific recovery suggestions based on error type\n        let recoveryMessage = 'Check your network connection and try again.';\n        if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {\n            recoveryMessage = 'Cannot connect to the server. Check that the server is running and your network connection is working.';\n        } else if (error.name === 'AbortError') {\n            recoveryMessage = 'The request was cancelled. This may happen if you clicked start multiple times quickly.';\n        }\n        \n        showEnhancedError(error, 'startSweep', {\n            recovery: recoveryMessage,\n            context: attemptContext\n        });\n        \n        // Reset button states on error\n        isScanning = false;\n        isCycling = false;\n        updateButtonStates();\n    }\n}\n\n// Stop sweep with enhanced resilience and complete state synchronization\nasync function stopSweep() {\n    trackOperation('Stop sweep initiated', {\n        source: 'user_action',\n        currentState: { isScanning, isCycling, connectionStatus }\n    });\n    const endpoint = '/stop-sweep';\n    const timeoutMs = 15000; // Increased to 15 second timeout for complete cleanup\n    \n    try {\n        showStatus('Stopping sweep and verifying cleanup...', 'info', true);\n        \n        // Create abort controller for timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => {\n            controller.abort();\n        }, timeoutMs);\n        \n        const response = await fetch(`${API_BASE_URL}${endpoint}`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            signal: controller.signal\n        });\n        \n        clearTimeout(timeoutId);\n        \n        const data = await response.json();\n        \n        if (response.ok) {\n            // Wait for complete backend stop before showing success\n            showStatus('Stopping sweep...', 'info', true);\n            \n            // Add 500ms delay before verification to allow backend processes to complete\n            await new Promise(resolve => setTimeout(resolve, 500));\n            \n            // Verify the stop with server state check (tolerant of transitional states)\n            await verifyStopCompletion();\n            \n            resetScanningState();\n            showStatus('Sweep stopped successfully', 'success');\n        } else {\n            // Handle specific backend error messages for split brain scenarios\n            if (data.error && data.error.includes('No sweep is running')) {\n                // Backend says no sweep running, so just reset UI state\n                resetScanningState();\n                showStatus('No sweep was running on server - UI state reset', 'info');\n            } else {\n                throw new Error(data.error || 'Failed to stop sweep');\n            }\n        }\n    } catch (error) {\n        logError('stopSweep', error, { endpoint });\n        \n        let errorMessage = '';\n        \n        if (error.name === 'AbortError') {\n            errorMessage = `Stop request timed out after ${timeoutMs/1000} seconds`;\n        } else if (error.message.includes('Failed to fetch')) {\n            errorMessage = 'Unable to connect to server for stop request';\n        } else {\n            errorMessage = `Error stopping sweep: ${error.message}`;\n        }\n        \n        showStatus(errorMessage, 'error');\n        \n        // Always reset states even if stop failed\n        resetScanningState();\n    }\n}\n\n// Reset all scanning-related states\nfunction resetScanningState() {\n    isScanning = false;\n    isCycling = false;\n    currentFrequencyIndex = 0;\n    connectionStatus = 'disconnected';\n    \n    // Clear cycling operation flags\n    activeCyclingOperation = false;\n    reducedSyncMode = false;\n    \n    clearTimeout(startupTimeout);\n    setLoadingState(false);\n    clearCycleDisplay();\n    updateButtonStates();\n    updateConnectionStatus();\n    \n    disconnectSSE();\n    resetDisplay();\n    clearFrequencyHighlights();\n    showCycleStatus(false);\n    \n    trackOperation('Cycling mode deactivated - normal sync restored', {\n        source: 'state_reset'\n    });\n}\n\n\n// Initialize cycle status with default values\nfunction initializeCycleStatus() {\n    const cycleStatus = document.getElementById('cycleStatus');\n    if (cycleStatus) {\n        // Ensure cycle status is always visible\n        cycleStatus.classList.remove('hidden');\n        cycleStatus.classList.remove('active');\n        \n        // Set default values\n        updateCurrentFrequencyDisplay(null); // Will show '--'\n        const timerDisplay = document.getElementById('switchTimer');\n        if (timerDisplay) {\n            timerDisplay.textContent = '--';\n        }\n    }\n}\n\n// Show/hide cycle status display - Modified to always show\nfunction showCycleStatus(show) {\n    const cycleStatus = document.getElementById('cycleStatus');\n    if (cycleStatus) {\n        // Always keep cycle status visible, just change active state\n        cycleStatus.classList.remove('hidden');\n        if (show) {\n            cycleStatus.classList.add('active');\n        } else {\n            cycleStatus.classList.remove('active');\n        }\n    }\n}\n\n// Start cycle display\nfunction startCycleDisplay(frequencies, cycleTime) {\n    // Store frequencies globally for next frequency calculations\n    globalFrequencies = frequencies || [];\n    \n    // Show the next frequency that will be scanned, not the current one\n    updateNextFrequencyDisplay(frequencies, currentFrequencyIndex);\n    startTimer(cycleTime);\n}\n\n// Update current frequency display\nfunction updateCurrentFrequencyDisplay(frequency) {\n    const currentFreqElement = document.getElementById('currentFrequencyDisplay');\n    if (currentFreqElement) {\n        if (frequency && frequency.value && frequency.unit) {\n            currentFreqElement.textContent = `${frequency.value} ${frequency.unit}`;\n        } else {\n            currentFreqElement.textContent = '--';\n        }\n    }\n}\n\n// Update next frequency display (what frequency will be scanned next)\nfunction updateNextFrequencyDisplay(frequencies, currentIndex) {\n    const currentFreqElement = document.getElementById('currentFrequencyDisplay');\n    \n    // Use provided frequencies or global frequencies\n    const freqList = frequencies || globalFrequencies;\n    \n    if (!currentFreqElement || !freqList || freqList.length === 0) {\n        if (currentFreqElement) {\n            currentFreqElement.textContent = '--';\n        }\n        return;\n    }\n    \n    // Calculate next frequency index (wrap around if at end)\n    const nextIndex = (currentIndex + 1) % freqList.length;\n    const nextFrequency = freqList[nextIndex];\n    \n    if (nextFrequency && nextFrequency.value && nextFrequency.unit) {\n        currentFreqElement.textContent = `${nextFrequency.value} ${nextFrequency.unit}`;\n    } else {\n        currentFreqElement.textContent = '--';\n    }\n}\n\n// Start countdown timer with signal indicator synchronization\nfunction startTimer(cycleTime) {\n    // Clear any existing timer first to prevent multiple timers\n    if (cycleTimer) {\n        clearInterval(cycleTimer);\n        cycleTimer = null;\n    }\n    \n    // Convert milliseconds to seconds\n    const cycleTimeSeconds = Math.round(cycleTime / 1000);\n    let remaining = cycleTimeSeconds;\n    const timerDisplay = document.getElementById('switchTimer');\n    const progressBar = document.getElementById('timerProgressBar');\n    const signalFill = document.getElementById('signalIndicatorFill');\n    const dbIndicator = document.getElementById('dbCurrentIndicator');\n    \n    // Reset signal indicator position to sync with timer restart\n    signalResetInProgress = true;\n    \n    if (signalFill && dbIndicator) {\n        signalFill.style.width = '0%';\n        dbIndicator.style.left = '0%';\n        // Reset to weak signal class\n        signalFill.classList.remove('gradient-weak', 'gradient-moderate', 'gradient-strong', 'gradient-very-strong');\n        signalFill.classList.add('gradient-weak');\n        // Reset dB value display\n        document.getElementById('dbCurrentValue').textContent = '-90 dB';\n    }\n    \n    // Allow signal updates after brief delay to prevent immediate override\n    setTimeout(() => {\n        signalResetInProgress = false;\n    }, 100); // 100ms delay to prevent race condition\n    \n    const updateTimer = () => {\n        if (timerDisplay) {\n            timerDisplay.textContent = `${remaining}s`;\n        }\n        \n        if (progressBar) {\n            const percentage = ((cycleTimeSeconds - remaining) / cycleTimeSeconds) * 100;\n            progressBar.style.width = `${percentage}%`;\n        }\n        \n        remaining--;\n        \n        if (remaining < 0) {\n            remaining = cycleTimeSeconds; // Reset for next cycle\n            \n            // Coordinate signal indicator reset with cycle restart\n            signalResetInProgress = true;\n            \n            if (signalFill && dbIndicator) {\n                signalFill.style.width = '0%';\n                dbIndicator.style.left = '0%';\n                // Reset to weak signal class\n                signalFill.classList.remove('gradient-weak', 'gradient-moderate', 'gradient-strong', 'gradient-very-strong');\n                signalFill.classList.add('gradient-weak');\n                // Reset dB value display\n                document.getElementById('dbCurrentValue').textContent = '-90 dB';\n            }\n            \n            // Allow signal updates after brief delay to prevent immediate override\n            setTimeout(() => {\n                signalResetInProgress = false;\n            }, 100); // 100ms delay to prevent race condition\n        }\n    };\n    \n    updateTimer(); // Initial update\n    cycleTimer = setInterval(updateTimer, 1000);\n}\n\n// Clear cycle display\nfunction clearCycleDisplay() {\n    if (cycleTimer) {\n        clearInterval(cycleTimer);\n        cycleTimer = null;\n    }\n    \n    const timerDisplay = document.getElementById('timerDisplay');\n    const progressBar = document.getElementById('timerProgressBar');\n    const currentFreq = document.getElementById('currentFrequency');\n    \n    if (timerDisplay) timerDisplay.textContent = '--';\n    if (progressBar) progressBar.style.width = '0%';\n    if (currentFreq) currentFreq.textContent = '--';\n}\n\n// Connect to SSE\nfunction connectSSE() {\n    // Prevent duplicate connections\n    if (sseConnectionActive && eventSource && eventSource.readyState !== EventSource.CLOSED) {\n        return;\n    }\n    \n    if (eventSource) {\n        eventSource.close();\n    }\n    \n    sseConnectionActive = true;\n    eventSource = new EventSource(`${API_BASE_URL}/data-stream`);\n    \n    eventSource.onopen = () => {\n        console.log('SSE connection established');\n        connectionStatus = 'connected';\n        connectionRetryCount = 0;\n        updateConnectionStatus();\n        \n        // Reset sync flags when SSE connects to clear any stuck states\n        resetSyncFlags();\n        \n        if (connectionRetryCount > 0) {\n            showStatus('Connection restored', 'success');\n        }\n        \n        // Don't call synchronizeWithServerState here - it causes a loop\n        // The periodic sync (every 30 seconds) will handle state updates\n    };\n    \n    // Comment out generic message handler to avoid duplicate processing\n    // eventSource.onmessage = (event) => {\n    //     try {\n    //         const data = JSON.parse(event.data);\n    //         updateDisplay(data);\n    //         \n    //         // Update heartbeat and connection status on successful data\n    //         if (connectionStatus !== 'connected') {\n    //             connectionStatus = 'connected';\n    //             connectionRetryCount = 0;\n    //             updateConnectionStatus();\n    //         }\n    //     } catch (error) {\n    //         logError('SSE data parsing', error, { eventData: event.data });\n    //         showStatus('Error parsing data from server', 'warning');\n    //     }\n    // };\n    \n    // Handle sweep_data events (signal strength updates) - SIGNAL DATA ONLY\n    eventSource.addEventListener('sweep_data', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            \n            \n            updateDisplay(data); // Signal data processing - no cycle state management\n            \n            // Update connection status on successful data\n            if (connectionStatus !== 'connected') {\n                connectionStatus = 'connected';\n                connectionRetryCount = 0;\n                updateConnectionStatus();\n            }\n        } catch (error) {\n            logError('SSE sweep_data parsing', error, { eventData: event.data });\n            showStatus('Error parsing sweep data from server', 'warning');\n        }\n    });\n    \n    // Handle status_change events - CYCLE STATE MANAGEMENT ONLY\n    eventSource.addEventListener('status_change', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            handleStatusChange(data); // Cycle state changes and frequency display updates\n        } catch (error) {\n            console.error('Error parsing status change:', error);\n        }\n    });\n    \n    // Handle cycle_config events - CYCLE CONFIGURATION ONLY\n    eventSource.addEventListener('cycle_config', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            handleCycleConfig(data); // Initial cycle setup and configuration\n        } catch (error) {\n            console.error('Error parsing cycle config:', error);\n        }\n    });\n    \n    eventSource.addEventListener('error', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            const errorMessage = data.message || 'Error occurred';\n            \n            // Use enhanced error display for better user feedback\n            const errorType = data.errorType || 'general_error';\n            const recoveryMessage = getGeneralErrorRecovery(errorType, data);\n            \n            showEnhancedError(errorMessage, 'general_error', {\n                recovery: recoveryMessage,\n                context: { \n                    errorType: errorType,\n                    severity: data.severity || 'medium',\n                    retryable: isRetryableError(errorType)\n                }\n            });\n            \n            trackOperation(`General error: ${errorMessage}`, { \n                source: 'sse_error',\n                errorType: errorType,\n                severity: data.severity\n            });\n            \n        } catch (error) {\n            console.error('Error parsing error event:', error);\n            showStatus('An unknown error occurred', 'error');\n        }\n    });\n    \n    // Handle emergency stop events\n    eventSource.addEventListener('emergency_stop', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            console.log('🚨 Emergency stop event received from server');\n            \n            // Force reset UI state immediately\n            resetScanningState();\n            showStatus('🚨 Emergency stop executed by server - all processes terminated', 'warning');\n            trackOperation('Emergency stop executed by server');\n            \n        } catch (error) {\n            console.error('Error parsing emergency_stop event:', error);\n        }\n    });\n    \n    // Handle server reset events\n    eventSource.addEventListener('server_reset', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            console.log('🔧 Server reset event received');\n            \n            showStatus('🔧 Server reset in progress - page will reload automatically', 'warning');\n            \n            // Force reset UI state\n            resetScanningState();\n            \n            // Disconnect from SSE\n            disconnectSSE();\n            \n            // Reload page after brief delay to allow server to complete reset\n            setTimeout(() => {\n                window.location.reload();\n            }, 3000);\n            \n        } catch (error) {\n            console.error('Error parsing server_reset event:', error);\n        }\n    });\n    \n    // Handle state sync events\n    eventSource.addEventListener('state_sync', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            console.log('🔄 State sync event received from server');\n            \n            showStatus('🔄 Server state synchronized', 'info');\n            \n            // Update UI with the latest state\n            if (data.afterState) {\n                restoreUIStateFromServer(data.afterState);\n            }\n            \n        } catch (error) {\n            console.error('Error parsing state_sync event:', error);\n        }\n    });\n\n\n\n    // Handle stuck recovery events\n    eventSource.addEventListener('stuck_recovery_attempted', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            showStatus(`🔧 Attempting stuck recovery (${data.attempt}/${data.maxAttempts})`, 'warning');\n        } catch (error) {\n            console.error('Error parsing stuck_recovery_attempted event:', error);\n        }\n    });\n\n    eventSource.addEventListener('stuck_recovery_successful', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            showStatus('✅ Stuck recovery successful', 'success');\n        } catch (error) {\n            console.error('Error parsing stuck_recovery_successful event:', error);\n        }\n    });\n\n    eventSource.addEventListener('stuck_recovery_failed', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            showEnhancedError(`🚨 Stuck recovery failed: ${data.message}`, 'stuck_recovery', {\n                recovery: 'Check HackRF connection and try restarting the sweep operation.',\n                context: { errorType: 'stuck_recovery_failure', attempts: data.attempts }\n            });\n        } catch (error) {\n            console.error('Error parsing stuck_recovery_failed event:', error);\n        }\n    });\n\n    // Handle cycling-specific error events\n    eventSource.addEventListener('cycling_error', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            handleCyclingError(data);\n        } catch (error) {\n            console.error('Error parsing cycling_error event:', error);\n        }\n    });\n\n    eventSource.addEventListener('frequency_error', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            handleFrequencyError(data);\n        } catch (error) {\n            console.error('Error parsing frequency_error event:', error);\n        }\n    });\n\n    eventSource.addEventListener('graceful_stop', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            handleGracefulStop(data);\n        } catch (error) {\n            console.error('Error parsing graceful_stop event:', error);\n        }\n    });\n\n    eventSource.addEventListener('stuck_recovery_error', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            showEnhancedError(`🔧 Recovery attempt failed: ${data.error}`, 'recovery_error', {\n                recovery: 'Try restarting the scanning operation or check HackRF connection.',\n                context: { errorType: 'recovery_error', attempt: data.attempt }\n            });\n        } catch (error) {\n            console.error('Error parsing stuck_recovery_error event:', error);\n        }\n    });\n    \n    eventSource.onerror = (error) => {\n        console.error('SSE error:', error);\n        connectionStatus = 'error';\n        sseConnectionActive = false;  // Mark connection as inactive\n        updateConnectionStatus();\n        \n        if (eventSource.readyState === EventSource.CLOSED) {\n            connectionRetryCount++;\n            \n            if (connectionRetryCount <= maxRetryAttempts) {\n                showStatus(`Connection lost. Attempting to reconnect... (${connectionRetryCount}/${maxRetryAttempts})`, 'warning');\n                \n                // Reset states on connection loss (but preserve cycling flags for reconnection)\n                if (isScanning) {\n                    isScanning = false;\n                    isCycling = false;\n                    // Don't immediately clear cycling flags - may reconnect during cycling\n                    updateButtonStates();\n                }\n                \n                // Try to reconnect with exponential backoff\n                const retryDelay = Math.min(5000 * Math.pow(2, connectionRetryCount - 1), 30000);\n                setTimeout(() => {\n                    if (connectionRetryCount <= maxRetryAttempts) {\n                        console.log(`Attempting to reconnect (attempt ${connectionRetryCount})...`);\n                        connectSSE();\n                    }\n                }, retryDelay);\n            } else {\n                showStatus('Connection failed after multiple attempts. Server may be down or HackRF disconnected.', 'error');\n                // Connection error\n                \n                // Reset states on final failure\n                isScanning = false;\n                isCycling = false;\n                // Clear cycling flags on final connection failure\n                activeCyclingOperation = false;\n                reducedSyncMode = false;\n                updateButtonStates();\n            }\n        }\n    };\n}\n\n// Disconnect SSE\nfunction disconnectSSE() {\n    sseConnectionActive = false;  // Mark connection as inactive\n    if (eventSource) {\n        eventSource.close();\n        eventSource = null;\n    }\n}\n\n// Enhanced synchronization with detailed tracking\nasync function synchronizeWithServerState(syncReason = 'manual') {\n    // Prevent recursive synchronization calls\n    if (isSynchronizing) {\n        trackOperation('Sync blocked: already synchronizing', { source: 'sync_guard', reason: syncReason });\n        return;\n    }\n    \n    // CYCLING PRIORITY: Reduce sync blocking during active cycling\n    const isCyclingSync = (syncReason === 'cycling_frequency_switch' || activeCyclingOperation);\n    \n    isSynchronizing = true;\n    syncInProgress = !isCyclingSync;  // Don't block startSweep during cycling sync\n    lastSyncTime = Date.now();  // Track sync timing\n    const syncId = Date.now() + '_' + Math.random().toString(36).substr(2, 5);\n    \n    trackOperation(`State synchronization started (${syncReason})`, { \n        source: 'state_sync',\n        syncId,\n        currentState: { isScanning, isCycling, connectionStatus }\n    });\n    \n    try {\n        // Create abort controller for timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => {\n            controller.abort();\n        }, 5000);\n        \n        const response = await fetch(`${API_BASE_URL}/cycle-status`, {\n            method: 'GET',\n            signal: controller.signal\n        });\n        \n        clearTimeout(timeoutId);\n        \n        if (response.ok) {\n            const serverState = await response.json();\n            \n            trackOperation('Server state received', {\n                source: 'state_sync',\n                syncId,\n                serverRunning: Boolean(serverState.isRunning || serverState.isActive),\n                frequencies: serverState.frequencies?.length || 0\n            });\n            \n            // Validate server state structure\n            if (typeof serverState === 'object' && serverState !== null) {\n                // Check for state coherence issues on the server\n                if (serverState.stateCoherent === false) {\n                    console.warn('⚠️ Server state incoherent detected - process and running state mismatch');\n                    trackOperation('Server state incoherent detected', {\n                        source: 'state_sync',\n                        syncId,\n                        recovery: 'Server auto-fixing state coherence'\n                    });\n                    showStatus('Server state synchronization in progress...', 'warning');\n                }\n                \n                // Check if server state differs from UI state\n                const stateChanged = restoreUIStateFromServer(serverState);\n                \n                \n                // Always ensure button states match reality after synchronization\n                const serverIsActive = Boolean(serverState.isRunning || serverState.isActive);\n                verifyButtonStatesMatchReality(serverIsActive);\n                \n                // Track last sync time\n                window.lastStateSyncTime = new Date().toLocaleTimeString();\n                \n                if (stateChanged) {\n                    trackOperation('UI state synchronized with server', {\n                        source: 'state_sync',\n                        syncId,\n                        changes: 'State differences resolved'\n                    });\n                    showStatus('UI state synchronized with server state', 'info');\n                } else {\n                    trackOperation('States already synchronized', {\n                        source: 'state_sync',\n                        syncId\n                    });\n                }\n            }\n        } else {\n            trackOperation(`Sync failed: HTTP ${response.status}`, {\n                source: 'state_sync',\n                syncId,\n                statusCode: response.status\n            });\n        }\n    } catch (error) {\n        // Track sync errors for debugging but don't show to user\n        trackOperation(`Sync error: ${error.message}`, {\n            source: 'state_sync',\n            syncId,\n            errorType: error.name,\n            reason: syncReason\n        });\n        \n        if (error.name === 'AbortError') {\n            console.log('State sync timed out - this is normal during server operations');\n        } else {\n            console.log('State sync failed:', error.message);\n        }\n    } finally {\n        isSynchronizing = false;\n        syncInProgress = false;  // Clear guard flag\n        \n        trackOperation(`State synchronization completed (${syncReason})`, {\n            source: 'state_sync',\n            syncId,\n            cyclingMode: activeCyclingOperation,\n            reducedSync: reducedSyncMode\n        });\n    }\n}\n\n// Verify that the stop operation has completed on the server\nasync function verifyStopCompletion() {\n    try {\n        // Create abort controller for timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => {\n            controller.abort();\n        }, 3000); // 3 second timeout for verification\n        \n        const response = await fetch(`${API_BASE_URL}/cycle-status`, {\n            method: 'GET',\n            signal: controller.signal\n        });\n        \n        clearTimeout(timeoutId);\n        \n        if (response.ok) {\n            const serverState = await response.json();\n            \n            // Check if server is truly stopped\n            const serverIsActive = Boolean(serverState.isRunning || serverState.isActive);\n            \n            if (serverIsActive) {\n                // Server still shows running - this is expected due to race condition timing\n                console.warn('⚠️ Timing issue detected: server may still be shutting down');\n                // Don't throw error - force stop will handle this automatically if needed\n                console.log('ℹ️ This is normal - the stop operation may still be completing');\n            } else {\n                console.log('✅ Stop completion verified - server shows stopped state');\n            }\n        } else {\n            // If status endpoint fails, assume stop worked (for backward compatibility)\n            console.log('ℹ️ Could not verify stop completion (status endpoint unavailable)');\n        }\n    } catch (error) {\n        if (error.name === 'AbortError') {\n            console.warn('⚠️ Stop verification timed out - this is normal during shutdown');\n            // Don't throw error - this is expected during stop operations\n        } else if (error.message.includes('Failed to fetch')) {\n            // Network error - can't verify, but don't fail the stop operation\n            console.log('ℹ️ Cannot verify stop completion due to network error');\n        } else {\n            // Log other errors but don't throw - let stop operation complete\n            console.warn('ℹ️ Stop verification error (non-critical):', error.message);\n        }\n    }\n}\n\n// Restore UI state based on server response\nfunction restoreUIStateFromServer(serverState) {\n    let stateChanged = false;\n    \n    // CYCLING EXCEPTION: Skip restoration if actively cycling to prevent interference\n    if (activeCyclingOperation && isCycling) {\n        trackOperation('State restoration skipped - active cycling in progress', {\n            source: 'cycling_protection',\n            serverIsActive: Boolean(serverState.isRunning || serverState.isActive)\n        });\n        return false; // No state change during active cycling\n    }\n    \n    // Set restoration mode flag to prevent event handlers from triggering operations\n    isRestoringState = true;\n    \n    // Server returns 'isRunning', not 'isActive' - fix the key mismatch\n    const serverIsActive = Boolean(serverState.isRunning || serverState.isActive);\n    \n    // Check if server is running but UI thinks it's not (split brain state)\n    if (serverIsActive && !isScanning) {\n        isScanning = true;\n        stateChanged = true;\n        \n        // Show clear user feedback about state sync\n        showStatus('🔄 Server is running a sweep - UI synchronized', 'warning');\n        \n        // Update connection status since we found server is active\n        connectionStatus = 'connected';\n        \n    }\n    \n    // Check if server is not running but UI thinks it is\n    if (!serverIsActive && isScanning) {\n        isScanning = false;\n        isCycling = false;\n        stateChanged = true;\n        \n        // Show user feedback about state reset\n        showStatus('🔄 Server not running - UI state reset', 'info');\n        \n        // Update connection status\n        connectionStatus = 'disconnected';\n        \n    }\n    \n    // Enhanced button state management for split-brain recovery\n    if (stateChanged) {\n        // Force update button states to reflect corrected server state\n        updateButtonStates();\n    }\n    \n    // Update cycling state and frequency information only if server is active\n    if (serverIsActive) {\n        // Handle frequency information if available\n        if (Array.isArray(serverState.frequencies) && serverState.frequencies.length > 0) {\n            // Restore frequency inputs to match server state\n            const frequencyList = document.getElementById('frequencyList');\n            if (frequencyList) {\n                // Clear existing frequency inputs\n                frequencyList.innerHTML = '';\n                \n                // Recreate frequency inputs based on server state (direct HTML manipulation during restoration)\n                serverState.frequencies.forEach((freq, index) => {\n                    const newIndex = index + 1;\n                    const newItem = document.createElement('div');\n                    newItem.className = 'frequency-item saasfly-interactive-card flex items-center gap-3 p-4 bg-gradient-to-r from-bg-card/40 to-bg-card/20 rounded-xl border border-border-primary/40 hover:border-neon-cyan/40 hover:bg-gradient-to-r hover:from-bg-card/60 hover:to-bg-card/40 hover:shadow-md transition-all duration-300';\n                    newItem.id = `frequencyItem${newIndex}`;\n                    \n                    newItem.innerHTML = `\n                        <span class=\"font-mono text-sm text-text-muted font-semibold min-w-[24px] text-center bg-neon-cyan/10 rounded-lg px-2 py-1\">${newIndex}</span>\n                        <div class=\"flex-1 relative\">\n                            <input type=\"text\" id=\"frequencyInput${newIndex}\" placeholder=\"Target\" value=\"${freq.value || ''}\" class=\"font-mono w-full pl-3 pr-12 py-2 bg-bg-input/80 border border-border-primary/60 rounded-lg text-text-primary outline-none focus:border-neon-cyan focus:bg-bg-input focus:shadow-neon-cyan-sm transition-all duration-300 placeholder:text-text-muted/50\">\n                            <span class=\"absolute right-3 top-1/2 -translate-y-1/2 font-mono text-sm text-text-secondary font-medium pointer-events-none\">MHz</span>\n                        </div>\n                        ${newIndex > 1 ? `<button type=\"button\" onclick=\"removeFrequencyInput('frequencyItem${newIndex}')\" style=\"padding: 6px 12px !important; background-color: #ef4444 !important; color: white !important; border: none !important; border-radius: 6px !important; font-size: 14px !important; font-weight: 500 !important; cursor: pointer !important; box-shadow: none !important; text-shadow: none !important; outline: none !important; transition: box-shadow 0.3s ease !important;\" onmouseover=\"this.style.boxShadow='0 0 10px rgba(255, 255, 255, 0.4)'\" onmouseout=\"this.style.boxShadow='none'\">Remove</button>` : ''}\n                    `;\n                    \n                    frequencyList.appendChild(newItem);\n                });\n                \n                // Update button states\n                updateAddButtonState();\n                \n            }\n            \n            const wasCycling = isCycling;\n            isCycling = serverState.frequencies.length > 1;\n            \n            if (wasCycling !== isCycling) {\n                stateChanged = true;\n            }\n            \n            // Update current frequency index if provided\n            if (typeof serverState.currentIndex === 'number' && \n                serverState.currentIndex >= 0 && \n                serverState.currentIndex < serverState.frequencies.length) {\n                const oldIndex = currentFrequencyIndex;\n                currentFrequencyIndex = serverState.currentIndex;\n                \n                if (oldIndex !== currentFrequencyIndex) {\n                    stateChanged = true;\n                    updateFrequencyHighlight(currentFrequencyIndex);\n                }\n            }\n            \n            // Update current frequency display - handle both frequency formats\n            if (serverState.currentFrequency) {\n                const freqValue = serverState.currentFrequency.value || serverState.currentFrequency.frequency;\n                const freqUnit = serverState.currentFrequency.unit || 'MHz';\n                if (freqValue && freqUnit) {\n                    updateCurrentFrequencyDisplay({ value: freqValue, unit: freqUnit });\n                }\n            }\n            \n            // Show cycle status if cycling\n            if (isCycling) {\n                showCycleStatus(true);\n                \n                // Start cycle display if we have timing information\n                if (typeof serverState.cycleTime === 'number' && serverState.cycleTime > 0) {\n                    globalCycleTime = serverState.cycleTime;  // Store cycle time globally\n                    startCycleDisplay(serverState.frequencies, serverState.cycleTime);\n                }\n            } else {\n                showCycleStatus(false);\n            }\n            \n        } else if (serverState.currentFrequency) {\n            // Single frequency operation - handle both frequency formats\n            isCycling = false;\n            showCycleStatus(false);\n            \n            const freqValue = serverState.currentFrequency.value || serverState.currentFrequency.frequency;\n            const freqUnit = serverState.currentFrequency.unit || 'MHz';\n            if (freqValue && freqUnit) {\n                updateCurrentFrequencyDisplay({ value: freqValue, unit: freqUnit });\n            }\n            \n        }\n    }\n    \n    // Update button states and UI elements if state changed\n    if (stateChanged) {\n        updateButtonStates();\n        \n        // Clear any previous highlights if not scanning\n        if (!isScanning) {\n            clearFrequencyHighlights();\n            clearCycleDisplay();\n            resetDisplay();\n        }\n        \n        // If server is running but UI wasn't aware, connect to SSE stream\n        if (serverIsActive && !sseConnectionActive) {\n            connectSSE();\n        }\n        \n    }\n    \n    // Clear restoration mode flag and restore event listeners\n    isRestoringState = false;\n    \n    // Add event listeners to all frequency inputs after restoration is complete\n    addEventListenersToFrequencyInputs();\n    \n    return stateChanged;\n}\n\n// Update display with new data - SIGNAL DATA PROCESSING ONLY\n// This function handles signal strength data display and frequency accuracy\n// Cycle frequency display updates are handled by handleStatusChange() for clean separation\nfunction updateDisplay(data) {\n    if (!data || typeof data.db === 'undefined') {\n        return;\n    }\n    \n    // Skip signal indicator updates during reset to maintain synchronization\n    if (signalResetInProgress) {\n        return;\n    }\n    \n    const db = data.db;\n    const frequency = data.frequency;\n    const unit = data.unit || 'MHz';\n    \n    // Update dB level display\n    document.getElementById('dbLevelValue').textContent = db.toFixed(1);\n    \n    // Update signal strength text and class\n    const { strength, className } = getSignalStrength(db);\n    const signalStrengthElement = document.getElementById('signalStrengthText');\n    signalStrengthElement.textContent = strength;\n    signalStrengthElement.className = `value ${className}`;\n    \n    // Update signal indicator bar\n    const percentage = Math.max(0, Math.min(100, (db + 100) * 1.25)); // Map -100 to 0, -20 to 100\n    const fillElement = document.getElementById('signalIndicatorFill');\n    fillElement.style.width = percentage + '%';\n    \n    // Apply gradient class based on signal strength\n    // Remove any existing gradient classes\n    fillElement.classList.remove('gradient-weak', 'gradient-moderate', 'gradient-strong', 'gradient-very-strong');\n    \n    if (db >= -50) {\n        fillElement.classList.add('gradient-very-strong');\n    } else if (db >= -60) {\n        fillElement.classList.add('gradient-strong');\n    } else if (db >= -70) {\n        fillElement.classList.add('gradient-moderate');\n    } else if (db >= -90) {\n        fillElement.classList.add('gradient-weak');\n    }\n    \n    // Update current dB indicator position\n    const indicatorPosition = Math.max(0, Math.min(100, (db + 100) * 1.25));\n    const dbIndicator = document.getElementById('dbCurrentIndicator');\n    dbIndicator.style.left = indicatorPosition + '%';\n    \n    // Update current dB value\n    document.getElementById('dbCurrentValue').textContent = db.toFixed(1) + ' dB';\n    \n    // Enhanced frequency accuracy display\n    if (data.targetFrequency && data.frequencyAccuracy) {\n        // Update target frequency\n        const targetFreqText = `${data.targetFrequency.value.toFixed(3)} ${data.targetFrequency.unit}`;\n        document.getElementById('targetFrequency').textContent = targetFreqText;\n        \n        // Update detected frequency with precision\n        const detectedFreqText = `${frequency.toFixed(3)} ${unit}`;\n        document.getElementById('detectedFrequency').textContent = detectedFreqText;\n        \n        // Update frequency offset with color coding\n        const offsetMHz = data.frequencyAccuracy.offsetFromTargetMHz;\n        const offsetElement = document.getElementById('frequencyOffset');\n        const offsetText = offsetMHz >= 0 ? `+${offsetMHz.toFixed(3)}` : `${offsetMHz.toFixed(3)}`;\n        offsetElement.textContent = `${offsetText} MHz`;\n        \n        // Color code the offset based on accuracy\n        offsetElement.className = 'value';\n        if (Math.abs(offsetMHz) <= 0.05) {\n            offsetElement.classList.add('accurate'); // Green for very accurate (within 50kHz)\n        } else if (Math.abs(offsetMHz) <= 0.1) {\n            offsetElement.classList.add('moderate'); // Yellow for moderate (within 100kHz)\n        } else {\n            offsetElement.classList.add('inaccurate'); // Red for inaccurate (over 100kHz)\n        }\n        \n    } else {\n        // Fallback for backward compatibility\n        document.getElementById('targetFrequency').textContent = '--';\n        document.getElementById('detectedFrequency').textContent = frequency ? `${frequency.toFixed(3)} ${unit}` : '--';\n        document.getElementById('frequencyOffset').textContent = '--';\n        \n    }\n    \n    // Note: Frequency display updates for cycling are handled by status_change events\n    // This ensures clean separation between signal data processing and cycle state management\n}\n\n// Get signal strength classification\nfunction getSignalStrength(db) {\n    if (db < -90) {\n        return { strength: 'No Signal', className: 'signal-no-signal' };\n    } else if (db < -80) {\n        return { strength: 'Very Weak', className: 'signal-very-weak' };\n    } else if (db < -70) {\n        return { strength: 'Weak', className: 'signal-weak' };\n    } else if (db < -60) {\n        return { strength: 'Moderate', className: 'signal-moderate' };\n    } else if (db < -50) {\n        return { strength: 'Strong', className: 'signal-strong' };\n    } else {\n        return { strength: 'Very Strong', className: 'signal-very-strong' };\n    }\n}\n\n// Reset display to default state\nfunction resetDisplay() {\n    // Coordinate reset to prevent conflicts with timer synchronization\n    signalResetInProgress = true;\n    \n    document.getElementById('dbLevelValue').textContent = '--';\n    const signalElement = document.getElementById('signalStrengthText');\n    signalElement.textContent = 'No Signal';\n    signalElement.className = 'value signal-no-signal';\n    const signalFill = document.getElementById('signalIndicatorFill');\n    signalFill.style.width = '0%';\n    signalFill.classList.remove('gradient-weak', 'gradient-moderate', 'gradient-strong', 'gradient-very-strong');\n    document.getElementById('dbCurrentIndicator').style.left = '0%';\n    document.getElementById('dbCurrentValue').textContent = '-90 dB';\n    \n    // Allow signal updates after brief delay\n    setTimeout(() => {\n        signalResetInProgress = false;\n    }, 50); // Shorter delay since this is a one-time reset\n    \n    // Reset frequency accuracy display\n    document.getElementById('targetFrequency').textContent = '--';\n    document.getElementById('detectedFrequency').textContent = '--';\n    const offsetElement = document.getElementById('frequencyOffset');\n    offsetElement.textContent = '--';\n    offsetElement.className = 'value'; // Reset color coding\n}\n\n// Update button states - Enhanced with server state awareness\nfunction updateButtonStates() {\n    const startButton = document.getElementById('startButton');\n    const stopButton = document.getElementById('stopButton');\n    \n    // Primary button logic based on frontend state\n    startButton.disabled = isScanning;\n    stopButton.disabled = !isScanning;\n    \n    // Update button text to reflect current state\n    if (isScanning) {\n        startButton.textContent = 'Sweep Running';\n        stopButton.textContent = 'Stop Sweep';\n    } else {\n        startButton.textContent = 'Start Cycling';\n        stopButton.textContent = 'Stop';\n    }\n    \n    // Enable/disable cycling state on container\n    const container = document.querySelector('.container');\n    if (container) {\n        if (isScanning) {\n            container.classList.add('cycling-disabled');\n        } else {\n            container.classList.remove('cycling-disabled');\n        }\n    }\n    \n    // Update add button\n    updateAddButtonState();\n    \n    // Disable cycle time input during scanning\n    const cycleTimeInput = document.getElementById('cycleTimeInput');\n    if (cycleTimeInput) {\n        cycleTimeInput.disabled = isScanning;\n    }\n}\n\n// Update button states based on actual server state (for split-brain recovery)\nfunction updateButtonStatesFromServerState(serverIsActive) {\n    const startButton = document.getElementById('startButton');\n    const stopButton = document.getElementById('stopButton');\n    \n    if (serverIsActive) {\n        // Server is running - ensure stop button is enabled, start button disabled\n        startButton.disabled = true;\n        startButton.textContent = 'Sweep Running';\n        stopButton.disabled = false;\n        stopButton.textContent = 'Stop Sweep';\n        stopButton.style.background = '#ef4444';\n        stopButton.style.borderColor = '#dc2626';\n        stopButton.style.color = 'white';\n        stopButton.style.cursor = 'pointer';\n        \n        showStatus('🔄 Buttons updated to reflect server state: RUNNING', 'info');\n    } else {\n        // Server is not running - ensure start button is enabled, stop button disabled\n        startButton.disabled = false;\n        startButton.textContent = 'Start Cycling';\n        stopButton.disabled = true;\n        stopButton.textContent = 'Stop';\n        stopButton.style.background = '';\n        stopButton.style.borderColor = '';\n        stopButton.style.color = '';\n        stopButton.style.cursor = '';\n        \n        showStatus('🔄 Buttons updated to reflect server state: STOPPED', 'info');\n    }\n    \n    // Update container cycling state\n    const container = document.querySelector('.container');\n    if (container) {\n        if (serverIsActive) {\n            container.classList.add('cycling-disabled');\n        } else {\n            container.classList.remove('cycling-disabled');\n        }\n    }\n    \n    // Update other UI elements\n    updateAddButtonState();\n    const cycleTimeInput = document.getElementById('cycleTimeInput');\n    if (cycleTimeInput) {\n        cycleTimeInput.disabled = serverIsActive;\n    }\n}\n\n// Verify button states match reality (final safety check for split-brain scenarios)\nfunction verifyButtonStatesMatchReality(serverIsActive) {\n    const startButton = document.getElementById('startButton');\n    const stopButton = document.getElementById('stopButton');\n    \n    let buttonStateIssues = [];\n    \n    // Check for button state mismatches\n    if (serverIsActive) {\n        // Server is running - start should be disabled, stop should be enabled\n        if (!startButton.disabled) {\n            buttonStateIssues.push('Start button should be disabled (server running)');\n            startButton.disabled = true;\n            startButton.textContent = 'Sweep Running';\n        }\n        if (stopButton.disabled) {\n            buttonStateIssues.push('Stop button should be enabled (server running)');\n            stopButton.disabled = false;\n            stopButton.textContent = 'Stop Sweep';\n            stopButton.style.background = '#ef4444';\n            stopButton.style.borderColor = '#dc2626';\n            stopButton.style.color = 'white';\n            stopButton.style.cursor = 'pointer';\n        }\n    } else {\n        // Server is not running - start should be enabled, stop should be disabled\n        if (startButton.disabled && !isScanning) {\n            buttonStateIssues.push('Start button should be enabled (server stopped)');\n            startButton.disabled = false;\n            startButton.textContent = 'Start Cycling';\n        }\n        if (!stopButton.disabled && !isScanning) {\n            buttonStateIssues.push('Stop button should be disabled (server stopped)');\n            stopButton.disabled = true;\n            stopButton.textContent = 'Stop';\n            stopButton.style.background = '';\n            stopButton.style.borderColor = '';\n            stopButton.style.color = '';\n            stopButton.style.cursor = '';\n        }\n    }\n    \n    \n    // Log any fixes made\n    if (buttonStateIssues.length > 0) {\n        console.warn('🔧 Button state issues fixed:', buttonStateIssues);\n        showStatus(`🔧 Fixed ${buttonStateIssues.length} button state issue(s)`, 'info');\n    }\n}\n\n// Handle status change events - SINGLE SOURCE OF TRUTH for cycle frequency display\n// This function manages cycle state changes and frequency display updates\n// Signal data processing (updateDisplay) is kept separate from cycle state management\nfunction handleStatusChange(data) {\n    if (data.status === 'switching') {\n        // Mark active cycling operation to bypass certain guard flags\n        activeCyclingOperation = true;\n        reducedSyncMode = true;\n        \n        // DO NOT update currentFrequencyIndex during switching - only during 'active' status\n        \n        // Handle both frequency formats during transition\n        const nextFreq = data.nextFrequency;\n        if (nextFreq) {\n            const freqValue = nextFreq.value || nextFreq.frequency;\n            const freqUnit = nextFreq.unit || 'MHz';\n            showStatus(`Switching to ${freqValue} ${freqUnit}...`, 'info');\n            updateCurrentFrequencyDisplay({ value: freqValue, unit: freqUnit });\n            \n            trackOperation('Frequency switch in progress', {\n                source: 'cycling_operation',\n                fromIndex: currentFrequencyIndex,\n                toFrequency: `${freqValue} ${freqUnit}`,\n                cyclingActive: true\n            });\n        }\n        updateFrequencyHighlight(currentFrequencyIndex);\n        \n    } else if (data.status === 'active') {\n        currentFrequencyIndex = data.currentIndex || 0;\n        updateFrequencyHighlight(currentFrequencyIndex);\n        \n        // Handle both frequency formats during transition\n        if (data.currentFrequency) {\n            // Since the label says \"Next Frequency\", show the next frequency in cycle\n            updateNextFrequencyDisplay(null, currentFrequencyIndex);\n        }\n        \n        // CRITICAL FIX: Restart timer when frequency becomes active during cycling\n        // This ensures timer stays synchronized with actual frequency switches\n        if (isCycling) {\n            // Maintain cycling operation flags during active cycling\n            activeCyclingOperation = true;\n            reducedSyncMode = true;\n            \n            // Use provided cycleTime or fall back to global cycle time\n            const cycleTime = data.cycleTime || globalCycleTime;\n            startTimer(cycleTime);\n            \n            trackOperation('Timer restarted for active frequency', {\n                source: 'cycling_timer_sync',\n                currentIndex: currentFrequencyIndex,\n                cycleTime,\n                cyclingFlags: { activeCyclingOperation, reducedSyncMode }\n            });\n        }\n    }\n}\n\n// Handle cycle configuration\nfunction handleCycleConfig(data) {\n    if (data.frequencies && data.cycleTime) {\n        isCycling = data.frequencies.length > 1;\n        globalCycleTime = data.cycleTime;  // Store cycle time globally\n        \n        if (isCycling) {\n            // Activate cycling mode flags for guard bypass\n            activeCyclingOperation = true;\n            reducedSyncMode = true;\n            \n            showStatus(`Cycling ${data.frequencies.length} frequencies every ${data.cycleTime / 1000}s`, 'info');\n            startCycleDisplay(data.frequencies, data.cycleTime);\n            \n            trackOperation('Cycle configuration activated', {\n                source: 'cycle_config',\n                frequencyCount: data.frequencies.length,\n                cycleTime: data.cycleTime,\n                cyclingFlags: { activeCyclingOperation, reducedSyncMode }\n            });\n        } else {\n            // Single frequency mode - disable cycling flags\n            activeCyclingOperation = false;\n            reducedSyncMode = false;\n        }\n    }\n}\n\n// Cycling-aware state management functions\nfunction setCyclingPriority(enabled, reason = 'unknown') {\n    const wasEnabled = activeCyclingOperation;\n    activeCyclingOperation = enabled;\n    reducedSyncMode = enabled;\n    \n    if (wasEnabled !== enabled) {\n        trackOperation(`Cycling priority ${enabled ? 'enabled' : 'disabled'}`, {\n            source: 'cycling_priority',\n            reason,\n            previousState: wasEnabled,\n            newState: enabled\n        });\n    }\n}\n\nfunction isCyclingActive() {\n    return activeCyclingOperation && isCycling;\n}\n\nfunction shouldBypassSyncGuards(operationType = 'unknown') {\n    const bypass = activeCyclingOperation || (operationType === 'cycling');\n    if (bypass) {\n        trackOperation('Sync guard bypass activated', {\n            source: 'guard_bypass',\n            operationType,\n            activeCycling: activeCyclingOperation,\n            reason: activeCyclingOperation ? 'active_cycling' : 'cycling_operation'\n        });\n    }\n    return bypass;\n}\n\n// Update frequency highlight\nfunction updateFrequencyHighlight(index) {\n    clearFrequencyHighlights();\n    \n    const frequencyItems = document.querySelectorAll('.frequency-item');\n    if (frequencyItems[index]) {\n        // Don't add any class that changes appearance\n        // Just track internally which one is active\n        frequencyItems[index].setAttribute('data-current', 'true');\n    }\n}\n\n// Clear all frequency highlights\nfunction clearFrequencyHighlights() {\n    document.querySelectorAll('.frequency-item[data-current=\"true\"]').forEach(elem => {\n        elem.removeAttribute('data-current');\n    });\n}\n\n// Show status message with enhanced formatting\nfunction showStatus(message, type = 'info', showSpinner = false) {\n    const statusElement = document.getElementById('statusMessage');\n    const timestamp = new Date().toLocaleTimeString();\n    \n    // Create message with timestamp\n    let displayMessage = `[${timestamp}] ${message}`;\n    \n    // Add spinner if requested\n    if (showSpinner) {\n        displayMessage += ' <span class=\"loading\"></span>';\n        statusElement.innerHTML = displayMessage;\n    } else {\n        statusElement.textContent = displayMessage;\n    }\n    \n    // Reset classes and apply new ones\n    statusElement.className = 'status-message';\n    \n    // Apply type-specific styling\n    switch (type) {\n        case 'error':\n            statusElement.classList.add('error');\n            break;\n        case 'warning':\n            statusElement.classList.add('warning');\n            break;\n        case 'success':\n            statusElement.classList.add('success');\n            break;\n        case 'info':\n        default:\n            statusElement.classList.add('info');\n            break;\n    }\n    \n    // Clear status after timeout for non-error messages\n    if (type !== 'error') {\n        const timeout = type === 'success' ? 3000 : 5000;\n        setTimeout(() => {\n            if (!statusElement.classList.contains('error')) {\n                statusElement.textContent = '';\n                statusElement.className = 'status-message';\n            }\n        }, timeout);\n    }\n}\n\n// Set loading state for buttons and inputs\nfunction setLoadingState(loading) {\n    const startButton = document.getElementById('startButton');\n    const stopButton = document.getElementById('stopButton');\n    const addButton = document.getElementById('addFrequencyButton');\n    const cycleTimeInput = document.getElementById('cycleTimeInput');\n    const frequencyInputs = document.querySelectorAll('.frequency-item input, .frequency-item select');\n    \n    if (loading) {\n        startButton.disabled = true;\n        startButton.textContent = 'Starting...';\n        \n        // Disable all inputs during loading\n        if (addButton) addButton.disabled = true;\n        if (cycleTimeInput) cycleTimeInput.disabled = true;\n        frequencyInputs.forEach(input => input.disabled = true);\n    } else {\n        startButton.textContent = 'Start Cycling';\n        \n        // Re-enable inputs based on current state\n        if (addButton) addButton.disabled = isScanning;\n        if (cycleTimeInput) cycleTimeInput.disabled = isScanning;\n        frequencyInputs.forEach(input => input.disabled = isScanning);\n    }\n}\n\n// Update connection status indicator\nfunction updateConnectionStatus() {\n    // Connection status indicator removed\n}\n\n// Basic error message extraction\nfunction getErrorMessage(error) {\n    if (typeof error === 'string') return error;\n    return error.message || error.toString() || 'Unknown error occurred';\n}\n\n\n// Enhanced error display system with recovery suggestions\nfunction showEnhancedError(error, context = '', options = {}) {\n    const errorMessage = getErrorMessage(error);\n    showStatus(errorMessage, 'error');\n    \n    // Enhanced error tracking\n    trackOperation(`Error displayed: ${errorMessage}`, {\n        source: 'error_display',\n        context,\n        recovery: options.recovery || 'No recovery suggestion available',\n        errorType: typeof error === 'object' ? error.name : 'string_error'\n    });\n    \n    // Show Copy Error Details button and recovery suggestions after error\n    setTimeout(() => {\n        createEnhancedErrorPanel(error, context, options);\n    }, 500);\n}\n\n// Create enhanced error panel with recovery suggestions\nfunction createEnhancedErrorPanel(error, context = '', options = {}) {\n    // Remove existing error panel if present\n    const existingPanel = document.getElementById('errorPanel');\n    if (existingPanel) {\n        existingPanel.remove();\n    }\n    \n    const panel = document.createElement('div');\n    panel.id = 'errorPanel';\n    panel.className = 'error-panel';\n    \n    // Determine if this is a retryable cycling error\n    const isRetryable = options.context?.retryable || \n                       (context === 'cycling_error' && options.context?.errorType !== 'failure_loop_prevention') ||\n                       (context === 'frequency_error' && !options.context?.blacklisted);\n    \n    const isCyclingError = context === 'cycling_error' || context === 'frequency_error';\n    \n    panel.innerHTML = `\n        <div class=\"error-panel-content\">\n            ${options.recovery ? `\n                <div class=\"recovery-suggestion\">\n                    <strong>💡 Recovery Suggestion:</strong>\n                    <p>${options.recovery}</p>\n                </div>\n            ` : ''}\n            ${isCyclingError ? `\n                <div class=\"cycling-error-details\">\n                    ${options.context?.frequency ? `<p><strong>Frequency:</strong> ${options.context.frequency} MHz</p>` : ''}\n                    ${options.context?.retryCount ? `<p><strong>Retry Count:</strong> ${options.context.retryCount}/${options.context.maxRetries || 'unlimited'}</p>` : ''}\n                    ${options.context?.errorType ? `<p><strong>Error Type:</strong> ${options.context.errorType}</p>` : ''}\n                </div>\n            ` : ''}\n            <div class=\"error-actions\">\n                <button id=\"copyErrorButton\" class=\"copy-error-btn\">📋 Copy Error Details</button>\n                ${options.context && options.context.attemptId ? `\n                    <button id=\"viewCallStackButton\" class=\"view-stack-btn\">🔍 View Call Stack</button>\n                ` : ''}\n                ${isRetryable ? `\n                    <button id=\"retryOperationButton\" class=\"retry-btn\">🔄 Retry Operation</button>\n                ` : ''}\n                ${isCyclingError && !isScanning ? `\n                    <button id=\"restartSweepButton\" class=\"restart-btn\">🚀 Restart Sweep</button>\n                ` : ''}\n                <button id=\"dismissErrorButton\" class=\"dismiss-error-btn\">✕ Dismiss</button>\n            </div>\n        </div>\n    `;\n    \n    // Insert after the status message\n    const statusMessage = document.getElementById('statusMessage');\n    statusMessage.parentNode.insertBefore(panel, statusMessage.nextSibling);\n    \n    // Add event listeners\n    document.getElementById('copyErrorButton').onclick = () => copyErrorDetails(error, context, options);\n    document.getElementById('dismissErrorButton').onclick = () => panel.remove();\n    \n    if (options.context && options.context.attemptId) {\n        document.getElementById('viewCallStackButton').onclick = () => showCallStackModal(options.context);\n    }\n    \n    // Add retry button listeners for cycling errors\n    const retryButton = document.getElementById('retryOperationButton');\n    if (retryButton) {\n        retryButton.onclick = () => {\n            panel.remove();\n            handleRetryOperation(context, options.context);\n        };\n    }\n    \n    const restartButton = document.getElementById('restartSweepButton');\n    if (restartButton) {\n        restartButton.onclick = () => {\n            panel.remove();\n            handleRestartSweep(options.context);\n        };\n    }\n    \n    // Auto-hide after 60 seconds\n    setTimeout(() => {\n        if (panel.parentNode) {\n            panel.remove();\n        }\n    }, 60000);\n}\n\n// Create simple Copy Error Details button\nfunction createCopyErrorButton(error, context = '') {\n    // Remove existing button if present\n    const existingButton = document.getElementById('copyErrorButton');\n    if (existingButton) {\n        existingButton.remove();\n    }\n    \n    const button = document.createElement('button');\n    button.id = 'copyErrorButton';\n    button.className = 'copy-error-btn';\n    button.textContent = '📋 Copy Error Details';\n    button.onclick = () => copyErrorDetails(error, context);\n    \n    // Insert after the status message\n    const statusMessage = document.getElementById('statusMessage');\n    statusMessage.parentNode.insertBefore(button, statusMessage.nextSibling);\n    \n    // Auto-hide after 30 seconds\n    setTimeout(() => {\n        if (button.parentNode) {\n            button.remove();\n        }\n    }, 30000);\n}\n\n// Enhanced error details copy with comprehensive context\nfunction copyErrorDetails(error, context = '', options = {}) {\n    const errorInfo = {\n        timestamp: new Date().toISOString(),\n        context: context,\n        error: typeof error === 'string' ? error : error.message || error.toString(),\n        errorStack: typeof error === 'object' ? error.stack : 'N/A',\n        userAgent: navigator.userAgent,\n        url: window.location.href,\n        applicationState: {\n            isScanning,\n            isCycling,\n            connectionStatus,\n            sseConnectionActive,\n            currentFrequencyIndex\n        },\n        recentOperations: window.recentOperations?.slice(0, 10) || [],\n        startSweepAttempts: window.startSweepTracker?.attempts?.slice(-3) || [],\n        lastSyncTime: window.lastStateSyncTime || 'Never',\n        recovery: options.recovery || 'No recovery suggestion provided'\n    };\n    \n    // Add attempt context if available\n    if (options.context && options.context.attemptId) {\n        errorInfo.attemptContext = {\n            attemptId: options.context.attemptId,\n            type: options.context.type,\n            source: options.context.source,\n            callStack: options.context.callStack || []\n        };\n    }\n    \n    const errorText = `HackRF Monitor Enhanced Error Report\n========================================\nTimestamp: ${errorInfo.timestamp}\nContext: ${errorInfo.context}\nError: ${errorInfo.error}\nRecovery Suggestion: ${errorInfo.recovery}\n\nApplication State:\n- Scanning: ${errorInfo.applicationState.isScanning}\n- Cycling: ${errorInfo.applicationState.isCycling}\n- Connection: ${errorInfo.applicationState.connectionStatus}\n- SSE Active: ${errorInfo.applicationState.sseConnectionActive}\n- Current Frequency Index: ${errorInfo.applicationState.currentFrequencyIndex}\n- Last Sync: ${errorInfo.lastSyncTime}\n\nRecent Operations (last 10):\n${errorInfo.recentOperations.map((op, i) => `${i + 1}. ${op}`).join('\\n')}\n\nStart Sweep Attempts (last 3):\n${errorInfo.startSweepAttempts.map((attempt, i) => `${i + 1}. [${attempt.timestamp}] ${attempt.type} (${attempt.source})`).join('\\n')}\n\n${errorInfo.attemptContext ? `\nAttempt Context:\n- ID: ${errorInfo.attemptContext.attemptId}\n- Type: ${errorInfo.attemptContext.type}\n- Source: ${errorInfo.attemptContext.source}\n- Call Stack: ${errorInfo.attemptContext.callStack.slice(0, 5).join(' → ')}\n` : ''}\n\nError Stack:\n${errorInfo.errorStack}\n\nBrowser: ${errorInfo.userAgent}\nURL: ${errorInfo.url}`;\n    \n    // Create enhanced modal with the error text\n    const modal = document.createElement('div');\n    modal.style.cssText = `\n        position: fixed;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        background: rgba(0,0,0,0.8);\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        z-index: 10000;\n    `;\n    \n    modal.innerHTML = `\n        <div style=\"background: #1a1a1a; padding: 20px; border-radius: 8px; width: 90%; max-width: 800px; max-height: 80vh; overflow: auto;\">\n            <h3 style=\"color: #fff; margin-top: 0;\">Enhanced Error Details - Press Ctrl+C to copy</h3>\n            <textarea readonly style=\"width: 100%; height: 400px; background: #2a2a2a; color: #fff; border: 1px solid #444; padding: 10px; font-family: monospace; font-size: 12px;\">${errorText}</textarea>\n            <div style=\"margin-top: 10px;\">\n                <button onclick=\"this.closest('div').parentElement.remove()\" style=\"padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;\">Close</button>\n                <button onclick=\"navigator.clipboard.writeText(this.parentElement.previousElementSibling.value).then(() => alert('Copied to clipboard!'))\" style=\"padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;\">Copy to Clipboard</button>\n            </div>\n        </div>\n    `;\n    \n    document.body.appendChild(modal);\n    \n    // Auto-select the text\n    const textarea = modal.querySelector('textarea');\n    textarea.focus();\n    textarea.select();\n}\n\n// Show call stack modal for debugging\nfunction showCallStackModal(attemptContext) {\n    const modal = document.createElement('div');\n    modal.style.cssText = `\n        position: fixed;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        background: rgba(0,0,0,0.8);\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        z-index: 10000;\n    `;\n    \n    const callStackText = attemptContext.callStack ? \n        attemptContext.callStack.map((frame, i) => `${i + 1}. ${frame}`).join('\\n') :\n        'Call stack not available';\n    \n    modal.innerHTML = `\n        <div style=\"background: #1a1a1a; padding: 20px; border-radius: 8px; width: 80%; max-width: 600px;\">\n            <h3 style=\"color: #fff; margin-top: 0;\">Call Stack for Attempt: ${attemptContext.attemptId}</h3>\n            <div style=\"background: #2a2a2a; color: #fff; padding: 10px; border-radius: 4px; margin: 10px 0;\">\n                <strong>Type:</strong> ${attemptContext.type}<br>\n                <strong>Source:</strong> ${attemptContext.source}<br>\n                <strong>Timestamp:</strong> ${attemptContext.timestamp}\n            </div>\n            <textarea readonly style=\"width: 100%; height: 200px; background: #2a2a2a; color: #fff; border: 1px solid #444; padding: 10px; font-family: monospace;\">${callStackText}</textarea>\n            <button onclick=\"this.closest('div').parentElement.remove()\" style=\"margin-top: 10px; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;\">Close</button>\n        </div>\n    `;\n    \n    document.body.appendChild(modal);\n}\n\n\n\n\n\n\n\n\n\n\n\n// Clear error states - removed\nfunction clearErrorStates() {\n    // Clear error states removed\n}\n\n// Perform initial health check\nasync function performHealthCheck() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`, {\n            method: 'GET',\n            timeout: 5000\n        });\n        \n        if (response.ok) {\n            const data = await response.json();\n            connectionStatus = 'connected';\n            updateConnectionStatus();\n            \n        } else {\n            connectionStatus = 'error';\n            updateConnectionStatus();\n            showStatus('Server health check failed', 'warning');\n        }\n    } catch (error) {\n        connectionStatus = 'disconnected';\n        updateConnectionStatus();\n        \n    }\n}\n\n// Add debug panel for troubleshooting - removed\nfunction addDebugPanel() {\n    // Debug panel removed\n}\n\n// Update debug information - removed\nfunction updateDebugInfo() {\n    // Debug info update removed\n}\n\n// Copy debug information to clipboard - removed\nfunction copyDebugInfo() {\n    // Debug info copy removed\n}\n\n// Test connection manually - removed\nasync function testConnection() {\n    // Connection test removed\n}\n\n// Get error history (simplified implementation)\nfunction getErrorHistory() {\n    // In a real implementation, you might store error history\n    return ['Error history not implemented yet'];\n}\n\n// Cycling-specific error handling functions\nfunction handleCyclingError(data) {\n    const errorMessage = data.message || 'Cycling operation failed';\n    const errorType = data.errorType || 'general_cycling_error';\n    \n    trackOperation(`Cycling error: ${errorMessage}`, { \n        source: 'cycling_error',\n        errorType: errorType,\n        frequency: data.frequency,\n        severity: data.severity\n    });\n\n    // Create enhanced error display with cycling-specific recovery\n    const recoveryActions = getCyclingRecoveryActions(errorType, data);\n    \n    showEnhancedError(errorMessage, 'cycling_error', {\n        recovery: recoveryActions.message,\n        context: { \n            errorType: errorType,\n            frequency: data.frequency,\n            severity: data.severity,\n            retryable: recoveryActions.retryable\n        }\n    });\n\n    // Add cycling error indicator to UI\n    updateCyclingErrorIndicator(data);\n}\n\nfunction handleFrequencyError(data) {\n    const frequency = data.frequency || 'unknown';\n    const errorMessage = data.message || `Frequency ${frequency} failed`;\n    \n    trackOperation(`Frequency error: ${errorMessage}`, { \n        source: 'frequency_error',\n        frequency: frequency,\n        errorType: data.errorType,\n        retryCount: data.retryCount\n    });\n\n    // Show frequency-specific error with transition state\n    const recoveryMessage = getFrequencyRecoveryMessage(data);\n    \n    showEnhancedError(errorMessage, 'frequency_error', {\n        recovery: recoveryMessage,\n        context: { \n            frequency: frequency,\n            errorType: data.errorType,\n            retryCount: data.retryCount,\n            maxRetries: data.maxRetries,\n            blacklisted: data.blacklisted\n        }\n    });\n\n    // Update frequency transition display\n    updateFrequencyErrorDisplay(data);\n}\n\nfunction handleGracefulStop(data) {\n    const stopReason = data.consecutiveErrors >= data.maxErrors ? \n        'Too many consecutive errors' : 'System protection activated';\n    \n    trackOperation(`Graceful stop: ${stopReason}`, { \n        source: 'graceful_stop',\n        consecutiveErrors: data.consecutiveErrors,\n        maxErrors: data.maxErrors,\n        frequencyErrors: data.frequencyErrors\n    });\n\n    // Reset UI state\n    resetScanningState();\n    \n    // Show comprehensive stop information\n    showEnhancedError(`🛑 Cycling stopped: ${stopReason}`, 'graceful_stop', {\n        recovery: 'Review error details and check frequency settings. Consider removing problematic frequencies.',\n        context: {\n            errorType: 'graceful_stop',\n            consecutiveErrors: data.consecutiveErrors,\n            maxErrors: data.maxErrors,\n            blacklistedFrequencies: data.blacklistedFrequencies,\n            hasBlacklistedFreqs: data.blacklistedFrequencies && data.blacklistedFrequencies.length > 0\n        }\n    });\n\n    // Show detailed error summary\n    if (data.frequencyErrors && Object.keys(data.frequencyErrors).length > 0) {\n        createFrequencyErrorSummary(data.frequencyErrors, data.blacklistedFrequencies);\n    }\n}\n\nfunction getCyclingRecoveryActions(errorType, data) {\n    switch (errorType) {\n        case 'frequency_startup':\n            return {\n                message: 'Check HackRF connection and verify frequency is within valid range (1 MHz - 6 GHz).',\n                retryable: true\n            };\n        case 'failure_loop_prevention':\n            return {\n                message: 'Too many failures detected. Check HackRF connection and frequency settings.',\n                retryable: false\n            };\n        case 'hackrf_device_error':\n            return {\n                message: 'HackRF device error. Try disconnecting and reconnecting the device.',\n                retryable: true\n            };\n        default:\n            return {\n                message: 'Check system status and try restarting the operation.',\n                retryable: true\n            };\n    }\n}\n\nfunction getFrequencyRecoveryMessage(data) {\n    if (data.blacklisted) {\n        return `Frequency ${data.frequency} has been blacklisted due to repeated errors. Consider removing it from your frequency list.`;\n    }\n    \n    if (data.retryCount >= data.maxRetries) {\n        return `Frequency ${data.frequency} failed after ${data.retryCount} attempts. It may be incompatible or require different settings.`;\n    }\n    \n    return `Frequency ${data.frequency} failed. The system will retry automatically.`;\n}\n\nfunction updateCyclingErrorIndicator(data) {\n    // Add visual indicator for cycling errors\n    const statusElement = document.getElementById('statusMessage');\n    if (statusElement) {\n        statusElement.classList.add('cycling-error');\n        \n        // Add severity indicator\n        statusElement.setAttribute('data-error-severity', data.severity || 'medium');\n        \n        // Auto-remove after delay\n        setTimeout(() => {\n            statusElement.classList.remove('cycling-error');\n            statusElement.removeAttribute('data-error-severity');\n        }, 10000);\n    }\n}\n\nfunction updateFrequencyErrorDisplay(data) {\n    \n    // Highlight problematic frequency in UI if visible\n    highlightFrequencyError(data.frequency);\n}\n\nfunction highlightFrequencyError(frequency) {\n    // Find and highlight the frequency input that matches the error\n    const frequencyInputs = document.querySelectorAll('input[id^=\"frequencyInput\"]');\n    frequencyInputs.forEach(input => {\n        const value = parseFloat(input.value);\n        const unit = input.parentElement?.querySelector('select')?.value || 'MHz';\n        \n        let valueInMHz = value;\n        if (unit === 'GHz') valueInMHz = value * 1000;\n        if (unit === 'kHz') valueInMHz = value / 1000;\n        \n        // Convert frequency to MHz for comparison\n        const errorFreqMHz = parseFloat(frequency);\n        \n        if (Math.abs(valueInMHz - errorFreqMHz) < 0.001) { // Allow small floating point differences\n            const container = input.closest('.frequency-item');\n            if (container) {\n                container.classList.add('frequency-error');\n                \n                // Auto-remove highlighting after 15 seconds\n                setTimeout(() => {\n                    container.classList.remove('frequency-error');\n                }, 15000);\n            }\n        }\n    });\n}\n\nfunction createFrequencyErrorSummary(frequencyErrors, blacklistedFrequencies) {\n    // Remove existing summary if present\n    const existingSummary = document.getElementById('frequencyErrorSummary');\n    if (existingSummary) {\n        existingSummary.remove();\n    }\n    \n    const summaryPanel = document.createElement('div');\n    summaryPanel.id = 'frequencyErrorSummary';\n    summaryPanel.className = 'frequency-error-summary';\n    \n    let summaryHTML = '<div class=\"error-summary-header\"><h3>📊 Frequency Error Summary</h3></div>';\n    summaryHTML += '<div class=\"error-summary-content\">';\n    \n    // Show blacklisted frequencies\n    if (blacklistedFrequencies && blacklistedFrequencies.length > 0) {\n        summaryHTML += '<div class=\"blacklisted-frequencies\">';\n        summaryHTML += '<h4>🚫 Blacklisted Frequencies:</h4>';\n        summaryHTML += '<ul>';\n        blacklistedFrequencies.forEach(freq => {\n            summaryHTML += `<li>${freq} MHz (removed from cycling)</li>`;\n        });\n        summaryHTML += '</ul>';\n        summaryHTML += '</div>';\n    }\n    \n    // Show frequency error details\n    if (Object.keys(frequencyErrors).length > 0) {\n        summaryHTML += '<div class=\"frequency-error-details\">';\n        summaryHTML += '<h4>⚠️ Frequency Errors:</h4>';\n        summaryHTML += '<ul>';\n        Object.entries(frequencyErrors).forEach(([freq, errors]) => {\n            if (errors && errors.length > 0) {\n                const latestError = errors[errors.length - 1];\n                summaryHTML += `<li>${freq} MHz: ${errors.length} error(s) - ${latestError.error}</li>`;\n            }\n        });\n        summaryHTML += '</ul>';\n        summaryHTML += '</div>';\n    }\n    \n    summaryHTML += '<div class=\"error-summary-actions\">';\n    summaryHTML += '<button id=\"clearErrorSummary\" class=\"dismiss-error-btn\">✕ Dismiss</button>';\n    summaryHTML += '<button id=\"restartWithoutErrors\" class=\"retry-btn\">🔄 Restart Without Problem Frequencies</button>';\n    summaryHTML += '</div>';\n    summaryHTML += '</div>';\n    \n    summaryPanel.innerHTML = summaryHTML;\n    \n    // Insert after the status message\n    const statusMessage = document.getElementById('statusMessage');\n    statusMessage.parentNode.insertBefore(summaryPanel, statusMessage.nextSibling);\n    \n    // Add event listeners\n    document.getElementById('clearErrorSummary').onclick = () => summaryPanel.remove();\n    document.getElementById('restartWithoutErrors').onclick = () => {\n        removeBlacklistedFrequencies(blacklistedFrequencies);\n        summaryPanel.remove();\n    };\n    \n    // Auto-remove after 2 minutes\n    setTimeout(() => {\n        if (summaryPanel.parentNode) {\n            summaryPanel.remove();\n        }\n    }, 120000);\n}\n\nfunction removeBlacklistedFrequencies(blacklistedFrequencies) {\n    if (!blacklistedFrequencies || blacklistedFrequencies.length === 0) return;\n    \n    blacklistedFrequencies.forEach(freqStr => {\n        const freqMHz = parseFloat(freqStr);\n        removeFrequencyFromInputs(freqMHz);\n    });\n    \n    showStatus(`Removed ${blacklistedFrequencies.length} problematic frequencies from the list`, 'success');\n}\n\nfunction removeFrequencyFromInputs(targetFreqMHz) {\n    const frequencyInputs = document.querySelectorAll('input[id^=\"frequencyInput\"]');\n    frequencyInputs.forEach(input => {\n        const value = parseFloat(input.value);\n        const unit = input.parentElement?.querySelector('select')?.value || 'MHz';\n        \n        let valueInMHz = value;\n        if (unit === 'GHz') valueInMHz = value * 1000;\n        if (unit === 'kHz') valueInMHz = value / 1000;\n        \n        if (Math.abs(valueInMHz - targetFreqMHz) < 0.001) {\n            const container = input.closest('.frequency-item');\n            if (container && container.id !== 'frequencyItem1') {\n                // Don't remove the first frequency input, just clear it\n                container.remove();\n                // updateRemoveButtons(); // Commented out to prevent duplicate remove buttons\n                updateAddButtonState();\n            } else if (container && container.id === 'frequencyItem1') {\n                // Clear the first input but keep the container\n                input.value = '';\n                const unitSelect = container.querySelector('select');\n                if (unitSelect) unitSelect.value = 'MHz';\n            }\n        }\n    });\n}\n\n// Retry operation handlers for cycling errors\nfunction handleRetryOperation(errorContext, contextData) {\n    trackOperation('User initiated retry operation', { \n        source: 'error_retry',\n        errorContext: errorContext,\n        frequency: contextData?.frequency,\n        errorType: contextData?.errorType\n    });\n    \n    showStatus('🔄 Retrying operation...', 'info');\n    \n    // Wait a moment for system to stabilize, then retry\n    setTimeout(() => {\n        if (errorContext === 'cycling_error' || errorContext === 'frequency_error') {\n            // For cycling errors, attempt to restart the sweep\n            startSweep({ source: 'error_retry' });\n        } else if (errorContext === 'stuck_recovery') {\n            // For stuck recovery, try to force a clean restart\n            stopSweep().then(() => {\n                setTimeout(() => {\n                    startSweep({ source: 'stuck_recovery_retry' });\n                }, 2000);\n            });\n        } else {\n            // Generic retry - attempt to restart sweep\n            startSweep({ source: 'generic_retry' });\n        }\n    }, 1000);\n}\n\nfunction handleRestartSweep(contextData) {\n    trackOperation('User initiated sweep restart from error', { \n        source: 'error_restart',\n        frequency: contextData?.frequency,\n        errorType: contextData?.errorType\n    });\n    \n    showStatus('🚀 Restarting sweep operation...', 'info');\n    \n    // Ensure clean state before restart\n    if (isScanning) {\n        stopSweep().then(() => {\n            setTimeout(() => {\n                startSweep({ source: 'error_restart' });\n            }, 2000);\n        });\n    } else {\n        startSweep({ source: 'error_restart' });\n    }\n}\n\n// General error recovery message generator\nfunction getGeneralErrorRecovery(errorType, data) {\n    switch (errorType) {\n        case 'hackrf_not_found':\n            return 'Check that your HackRF device is connected via USB and not being used by another application.';\n        case 'hackrf_device_error':\n        case 'device_error':\n            return 'Try disconnecting and reconnecting your HackRF device. Make sure it has adequate power supply.';\n        case 'invalid_frequency':\n            return 'Verify that all frequencies are within the valid range (1 MHz - 6 GHz) and properly formatted.';\n        case 'sweep_startup_failed':\n            return 'Check HackRF connection and frequency settings. Try restarting the sweep operation.';\n        case 'connection_error':\n            return 'Server connection lost. Check that the backend service is running and try refreshing the page.';\n        default:\n            return 'Try restarting the operation. If the problem persists, check the HackRF connection and frequency settings.';\n    }\n}\n\n// Determine if an error is retryable\nfunction isRetryableError(errorType) {\n    const nonRetryableErrors = [\n        'hackrf_not_found',\n        'invalid_frequency',\n        'configuration_error'\n    ];\n    return !nonRetryableErrors.includes(errorType);\n}\n\n// Enhanced error logging with comprehensive context tracking\nfunction logError(context, error, additionalInfo = {}) {\n    const callStack = getCallStack();\n    const errorInfo = {\n        timestamp: new Date().toISOString(),\n        context: context,\n        error: {\n            message: error.message,\n            name: error.name,\n            stack: error.stack\n        },\n        applicationState: {\n            isScanning,\n            isCycling,\n            connectionStatus,\n            sseConnectionActive,\n            currentFrequencyIndex\n        },\n        callStack: callStack.slice(0, 10),\n        recentOperations: window.recentOperations?.slice(0, 5) || [],\n        lastSyncTime: window.lastStateSyncTime || 'Never',\n        ...additionalInfo\n    };\n    \n    console.error('Enhanced error log:', errorInfo);\n    \n    // Track error in recent operations with enhanced context\n    trackOperation(`ERROR in ${context}: ${error.message}`, {\n        source: 'error_log',\n        errorType: error.name,\n        callStack: callStack.slice(0, 3),\n        recovery: additionalInfo.recovery || 'No recovery info provided'\n    });\n    \n    // Store last error context for debugging\n    window.lastErrorContext = {\n        context,\n        timestamp: new Date().toISOString(),\n        errorInfo\n    };\n    \n    // Store error history for debugging\n    if (!window.errorHistory) window.errorHistory = [];\n    window.errorHistory.unshift({\n        timestamp: new Date().toISOString(),\n        context,\n        error: error.message,\n        stack: callStack.slice(0, 5)\n    });\n    if (window.errorHistory.length > 20) {\n        window.errorHistory.pop();\n    }\n}\n\n// Handle page unload\nwindow.addEventListener('beforeunload', () => {\n    if (isScanning) {\n        stopSweep();\n    }\n});\n\n// Handle online/offline events\nwindow.addEventListener('online', () => {\n    showStatus('Internet connection restored', 'success');\n    if (!isScanning) {\n        performHealthCheck();\n    }\n});\n\nwindow.addEventListener('offline', () => {\n    showStatus('Internet connection lost', 'warning');\n    connectionStatus = 'disconnected';\n    updateConnectionStatus();\n});\n\n\n// Keyboard shortcuts\ndocument.addEventListener('keydown', (event) => {\n    // Escape key to stop sweep (regular stop)\n    if (event.key === 'Escape' && isScanning) {\n        event.preventDefault();\n        stopSweep(false);\n    }\n});\n\n// Toggle debug mode - removed\nfunction toggleDebugMode() {\n    // Debug mode toggle removed\n}\n\n// Proactive State Validation and Health Check Functions\n\n/**\n * Perform startup health check to verify clean initial state\n */\nasync function performStartupHealthCheck() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/api/startup-health`, {\n            method: 'GET',\n            timeout: 5000\n        });\n        \n        if (response.ok) {\n            const data = await response.json();\n            \n            if (data.startupCheck.cleanState) {\n                console.log('✅ Startup health check passed - clean state verified');\n            } else {\n                console.warn('⚠️ Startup health check detected issues:', data.startupCheck.issues);\n                showStatus('Startup health check detected issues - see console for details', 'warning');\n            }\n            \n            return data.startupCheck;\n        } else {\n            console.warn('⚠️ Startup health check endpoint failed');\n            return { cleanState: false, issues: ['Health check endpoint failed'] };\n        }\n    } catch (error) {\n        console.warn('⚠️ Startup health check error:', error.message);\n        return { cleanState: false, issues: [`Health check error: ${error.message}`] };\n    }\n}\n\n/**\n * Start proactive state validation monitoring\n */\nfunction startProactiveStateValidation() {\n    // Run state validation every 2 minutes for proactive monitoring\n    setInterval(async () => {\n        if (connectionStatus === 'connected') {\n            await performProactiveStateValidation();\n        }\n    }, 120000); // 2 minutes\n    \n    // Run a quick validation check every 30 seconds during active operations\n    setInterval(async () => {\n        if (connectionStatus === 'connected' && isScanning) {\n            await performQuickStateValidation();\n        }\n    }, 30000); // 30 seconds\n}\n\n/**\n * Perform comprehensive proactive state validation\n */\nasync function performProactiveStateValidation() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/api/state-validation`, {\n            method: 'GET',\n            timeout: 5000\n        });\n        \n        if (response.ok) {\n            const data = await response.json();\n            \n            // Check validation results\n            if (!data.validation.valid) {\n                console.warn('⚠️ Proactive state validation detected issues:', data.validation.issues);\n                \n                // Show user-friendly warning for serious issues\n                const seriousIssues = data.validation.issues.filter(issue => \n                    issue.includes('State incoherence') || \n                    issue.includes('orphaned') ||\n                    issue.includes('stale')\n                );\n                \n                if (seriousIssues.length > 0) {\n                    showStatus('System health check detected issues - automatic cleanup in progress', 'warning');\n                }\n            }\n            \n            // Check split-brain detection\n            if (data.splitBrainCheck.detected) {\n                console.warn('⚠️ Split-brain condition detected:', data.splitBrainCheck.issues);\n                showStatus('Split-brain condition detected - attempting automatic resolution', 'warning');\n                \n                // Trigger synchronization to help resolve split-brain\n                setTimeout(() => {\n                    synchronizeWithServerState('split_brain_resolution');\n                }, 2000);\n            }\n            \n            return data;\n        } else {\n            console.warn('⚠️ State validation endpoint failed');\n            return null;\n        }\n    } catch (error) {\n        // Don't show errors to user for proactive checks - they're background operations\n        console.debug('State validation check failed (non-critical):', error.message);\n        return null;\n    }\n}\n\n/**\n * Perform quick state validation during active operations\n */\nasync function performQuickStateValidation() {\n    try {\n        // Quick check: verify current server state matches UI state\n        const response = await fetch(`${API_BASE_URL}/cycle-status`, {\n            method: 'GET',\n            timeout: 3000\n        });\n        \n        if (response.ok) {\n            const serverState = await response.json();\n            \n            // Check for obvious mismatches\n            const serverIsActive = Boolean(serverState.isRunning || serverState.isActive);\n            \n            if (serverIsActive !== isScanning) {\n                console.warn('⚠️ Quick validation detected state mismatch - triggering sync');\n                \n                // Trigger immediate synchronization\n                synchronizeWithServerState('quick_validation_mismatch');\n            }\n        }\n    } catch (error) {\n        // Silent failure for quick checks - don't disturb user experience\n        console.debug('Quick state validation failed (non-critical):', error.message);\n    }\n}\n\n/**\n * Enhanced health check with validation reporting\n */\nasync function performEnhancedHealthCheck() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`, {\n            method: 'GET',\n            timeout: 5000\n        });\n        \n        if (response.ok) {\n            const data = await response.json();\n            \n            // Update connection status based on health check\n            connectionStatus = data.status === 'ok' ? 'connected' : 'warning';\n            updateConnectionStatus();\n            \n            // Report any state validation issues\n            if (data.stateValidation && !data.stateValidation.valid) {\n                console.warn('🔍 Health check detected state validation issues:', data.stateValidation.issues);\n            }\n            \n            // Report split-brain detection\n            if (data.splitBrainCheck && data.splitBrainCheck.detected) {\n                console.warn('🔍 Health check detected split-brain conditions:', data.splitBrainCheck.issues);\n            }\n            \n            // Report hardware issues\n            if (data.hardware && data.hardware.hackrfError) {\n                console.warn('🔍 Hardware issue detected:', data.hardware.hackrfError);\n            }\n            \n            return data;\n        } else {\n            connectionStatus = 'error';\n            updateConnectionStatus();\n            return null;\n        }\n    } catch (error) {\n        connectionStatus = 'disconnected';\n        updateConnectionStatus();\n        return null;\n    }\n}\n\n// Note: performHealthCheck function is defined earlier in the file\n\n\n\n/**\n * Format duration in milliseconds to a human-readable string\n */\nfunction formatDuration(ms) {\n    if (ms < 1000) {\n        return `${Math.round(ms)}ms`;\n    } else if (ms < 60000) {\n        return `${(ms / 1000).toFixed(1)}s`;\n    } else {\n        const minutes = Math.floor(ms / 60000);\n        const seconds = Math.floor((ms % 60000) / 1000);\n        return `${minutes}m ${seconds}s`;\n    }\n}\n\n/**\n * Format frequency object to display string\n */\nfunction formatFrequency(frequency) {\n    if (!frequency) return '--';\n    \n    if (typeof frequency === 'object') {\n        return `${frequency.frequency} ${frequency.unit || 'MHz'}`;\n    } else {\n        return `${frequency} MHz`;\n    }\n}\n\n/**\n * Capitalize first letter of a string\n */\nfunction capitalizeFirst(str) {\n    if (!str) return '';\n    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();\n}\n\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/static/script.js",
		"messages": [
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'cycleCountdown' is assigned a value but never used.",
				"line": 13,
				"column": 5,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 13,
				"endColumn": 19,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "cycleCountdown" },
						"fix": { "range": [338, 364], "text": "" },
						"desc": "Remove unused variable 'cycleCountdown'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'cycleInterval' is assigned a value but never used.",
				"line": 14,
				"column": 5,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 14,
				"endColumn": 18,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "cycleInterval" },
						"fix": { "range": [365, 390], "text": "" },
						"desc": "Remove unused variable 'cycleInterval'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'updateRemoveButtons' is defined but never used.",
				"line": 469,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 469,
				"endColumn": 29,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "updateRemoveButtons" },
						"fix": { "range": [18235, 19968], "text": "" },
						"desc": "Remove unused variable 'updateRemoveButtons'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'data' is assigned a value but never used.",
				"line": 1247,
				"column": 19,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 1247,
				"endColumn": 23,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "data" },
						"fix": { "range": [47687, 47723], "text": "" },
						"desc": "Remove unused variable 'data'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'data' is assigned a value but never used.",
				"line": 1263,
				"column": 19,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 1263,
				"endColumn": 23,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "data" },
						"fix": { "range": [48316, 48352], "text": "" },
						"desc": "Remove unused variable 'data'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'data' is assigned a value but never used.",
				"line": 1316,
				"column": 19,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 1316,
				"endColumn": 23,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "data" },
						"fix": { "range": [50109, 50145], "text": "" },
						"desc": "Remove unused variable 'data'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'updateButtonStatesFromServerState' is defined but never used.",
				"line": 1938,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 1938,
				"endColumn": 43,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "updateButtonStatesFromServerState" },
						"fix": { "range": [76823, 78622], "text": "" },
						"desc": "Remove unused variable 'updateButtonStatesFromServerState'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'setCyclingPriority' is defined but never used.",
				"line": 2124,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2124,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "setCyclingPriority" },
						"fix": { "range": [84479, 84922], "text": "" },
						"desc": "Remove unused variable 'setCyclingPriority'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'isCyclingActive' is defined but never used.",
				"line": 2139,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2139,
				"endColumn": 25,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "isCyclingActive" },
						"fix": { "range": [84924, 85002], "text": "" },
						"desc": "Remove unused variable 'isCyclingActive'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'shouldBypassSyncGuards' is defined but never used.",
				"line": 2143,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2143,
				"endColumn": 32,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "shouldBypassSyncGuards" },
						"fix": { "range": [85004, 85451], "text": "" },
						"desc": "Remove unused variable 'shouldBypassSyncGuards'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'stopButton' is assigned a value but never used.",
				"line": 2226,
				"column": 11,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2226,
				"endColumn": 21,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "stopButton" },
						"fix": { "range": [87729, 87786], "text": "" },
						"desc": "Remove unused variable 'stopButton'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'createCopyErrorButton' is defined but never used.",
				"line": 2368,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2368,
				"endColumn": 31,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "createCopyErrorButton" },
						"fix": { "range": [93503, 94319], "text": "" },
						"desc": "Remove unused variable 'createCopyErrorButton'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'clearErrorStates' is defined but never used.",
				"line": 2541,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2541,
				"endColumn": 26,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "clearErrorStates" },
						"fix": { "range": [100157, 100222], "text": "" },
						"desc": "Remove unused variable 'clearErrorStates'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'data' is assigned a value but never used.",
				"line": 2554,
				"column": 19,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2554,
				"endColumn": 23,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "data" },
						"fix": { "range": [100482, 100517], "text": "" },
						"desc": "Remove unused variable 'data'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'error' is defined but never used.",
				"line": 2563,
				"column": 14,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2563,
				"endColumn": 19
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'addDebugPanel' is defined but never used.",
				"line": 2571,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2571,
				"endColumn": 23,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "addDebugPanel" },
						"fix": { "range": [100949, 101004], "text": "" },
						"desc": "Remove unused variable 'addDebugPanel'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'updateDebugInfo' is defined but never used.",
				"line": 2576,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2576,
				"endColumn": 25,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "updateDebugInfo" },
						"fix": { "range": [101044, 101107], "text": "" },
						"desc": "Remove unused variable 'updateDebugInfo'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'copyDebugInfo' is defined but never used.",
				"line": 2581,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2581,
				"endColumn": 23,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "copyDebugInfo" },
						"fix": { "range": [101158, 101217], "text": "" },
						"desc": "Remove unused variable 'copyDebugInfo'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'testConnection' is defined but never used.",
				"line": 2586,
				"column": 16,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2586,
				"endColumn": 30,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "testConnection" },
						"fix": { "range": [101257, 101323], "text": "" },
						"desc": "Remove unused variable 'testConnection'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'getErrorHistory' is defined but never used.",
				"line": 2591,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2591,
				"endColumn": 25,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "getErrorHistory" },
						"fix": { "range": [101374, 101517], "text": "" },
						"desc": "Remove unused variable 'getErrorHistory'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'data' is defined but never used.",
				"line": 2686,
				"column": 47,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2686,
				"endColumn": 51,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "data" },
						"fix": { "range": [104661, 104667], "text": "" },
						"desc": "Remove unused variable 'data'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'data' is defined but never used.",
				"line": 2932,
				"column": 45,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 2932,
				"endColumn": 49,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "data" },
						"fix": { "range": [114077, 114083], "text": "" },
						"desc": "Remove unused variable 'data'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'toggleDebugMode' is defined but never used.",
				"line": 3046,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 3046,
				"endColumn": 25,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "toggleDebugMode" },
						"fix": { "range": [117727, 117790], "text": "" },
						"desc": "Remove unused variable 'toggleDebugMode'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'performEnhancedHealthCheck' is defined but never used.",
				"line": 3187,
				"column": 16,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 3187,
				"endColumn": 42,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "performEnhancedHealthCheck" },
						"fix": { "range": [122777, 124264], "text": "" },
						"desc": "Remove unused variable 'performEnhancedHealthCheck'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'error' is defined but never used.",
				"line": 3222,
				"column": 14,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 3222,
				"endColumn": 19
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'formatDuration' is defined but never used.",
				"line": 3236,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 3236,
				"endColumn": 24,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "formatDuration" },
						"fix": { "range": [124407, 124737], "text": "" },
						"desc": "Remove unused variable 'formatDuration'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'formatFrequency' is defined but never used.",
				"line": 3251,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 3251,
				"endColumn": 25,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "formatFrequency" },
						"fix": { "range": [124792, 125032], "text": "" },
						"desc": "Remove unused variable 'formatFrequency'."
					}
				]
			},
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'capitalizeFirst' is defined but never used.",
				"line": 3264,
				"column": 10,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 3264,
				"endColumn": 25,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "capitalizeFirst" },
						"fix": { "range": [125081, 125208], "text": "" },
						"desc": "Remove unused variable 'capitalizeFirst'."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 28,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "// HackRF Monitor Frontend JavaScript\n\n// API Configuration\n// Use the current hostname to allow access from different devices on the network\nconst API_BASE_URL = `http://${window.location.hostname}:3002`;\n\nconst MAX_FREQUENCIES = 10;\n\nlet eventSource = null;\nlet isScanning = false;\nlet isCycling = false;\nlet currentFrequencyIndex = 0;\nlet cycleCountdown = null;\nlet cycleInterval = null;\nlet cycleTimer = null;\nlet connectionRetryCount = 0;\nlet maxRetryAttempts = 3;\nlet startupTimeout = null;\nlet connectionStatus = 'disconnected';\nlet isSynchronizing = false;  // Prevent sync loops\nlet sseConnectionActive = false;  // Track SSE connection state\nlet globalCycleTime = 30;  // Store cycle time globally for timer sync\nlet globalFrequencies = [];   // Store frequencies globally for next frequency calculation\nlet isRestoringState = false;  // Flag to prevent operations during state restoration\nlet performanceMode = true;   // Reduce verbose tracking for better performance\nlet syncInProgress = false;  // Guard flag to prevent startSweep during sync\nlet activeCyclingOperation = false;  // Flag to track active cycling operations\nlet reducedSyncMode = false;  // Flag to reduce sync frequency during cycling\nlet lastSyncTime = 0;  // Track sync timing for frequency reduction\nlet signalResetInProgress = false;  // Flag to coordinate signal indicator reset timing\n\n// Function to reset all blocking sync flags - emergency recovery\nfunction resetSyncFlags() {\n    console.log('🔄 Resetting all synchronization flags');\n    isSynchronizing = false;\n    syncInProgress = false;\n    isRestoringState = false;\n    signalResetInProgress = false;\n    console.log('✅ All sync flags cleared');\n}\n\n// Enhanced error tracking and operation logging system\nwindow.recentOperations = [];\nwindow.startSweepTracker = {\n    attempts: [],\n    lastUserInitiated: null,\n    lastSystemInitiated: null\n};\n\n// Enhanced operation tracking with call source detection\nfunction trackOperation(operation, context = {}) {\n    // Skip non-critical tracking in performance mode\n    if (performanceMode && context.source && context.source.includes('cycling')) {\n        return; // Skip verbose cycling operations\n    }\n    \n    const timestamp = new Date().toLocaleTimeString();\n    const stackTrace = performanceMode ? [] : getCallStack(); // Skip stack traces in performance mode\n    \n    const operationEntry = {\n        timestamp,\n        operation,\n        context,\n        callSource: context.source || 'unknown',\n        stackTrace: performanceMode ? [] : stackTrace.slice(0, 3)\n    };\n    \n    window.recentOperations.unshift(`[${timestamp}] ${operation} (${context.source || 'unknown'})`);\n    if (window.recentOperations.length > (performanceMode ? 15 : 30)) { // Reduced buffer in performance mode\n        window.recentOperations.pop();\n    }\n    \n    // Store detailed operation for debugging (reduced in performance mode)\n    if (!performanceMode) {\n        if (!window.detailedOperations) window.detailedOperations = [];\n        window.detailedOperations.unshift(operationEntry);\n        if (window.detailedOperations.length > 25) { // Reduced from 50\n            window.detailedOperations.pop();\n        }\n    }\n}\n\n// Get simplified call stack for tracking\nfunction getCallStack() {\n    try {\n        throw new Error();\n    } catch (e) {\n        return e.stack.split('\\n')\n            .slice(2) // Remove getCallStack and Error lines\n            .map(line => line.trim())\n            .filter(line => line.length > 0);\n    }\n}\n\n// Initialize on page load\ndocument.addEventListener('DOMContentLoaded', () => {\n    try {\n        // Reset all sync flags on page load to prevent stuck states\n        resetSyncFlags();\n        \n        trackOperation('Application initialized', { source: 'page_load' });\n        setupEventHandlers();\n        \n        updateButtonStates();\n        updateAddButtonState();\n        // updateRemoveButtons(); // Commented out to prevent duplicate remove buttons\n        updateConnectionStatus();\n        \n        // Initialize cycle status display with defaults (always visible)\n        initializeCycleStatus();\n        \n        // Add validation listener for the initial frequency input\n        const initialInput = document.getElementById('frequencyInput1');\n        if (initialInput) {\n            initialInput.addEventListener('input', function() {\n                validateFrequencyInputById(this.id);\n            });\n        }\n        \n        // Perform startup health check\n        performStartupHealthCheck();\n        \n        // Perform initial health check\n        performHealthCheck();\n        \n        // Synchronize with server state on page load - critical for split brain fix\n        setTimeout(() => {\n            synchronizeWithServerState('initialization');\n        }, 1000);\n        \n        // Start proactive state validation monitoring\n        startProactiveStateValidation();\n        \n        // Also sync state every 30 seconds to catch any drift\n        // Reduced frequency during active cycling to prevent interference\n        setInterval(() => {\n            if (connectionStatus === 'connected') {\n                // Skip periodic sync if cycling and recent sync occurred\n                if (reducedSyncMode && activeCyclingOperation) {\n                    const timeSinceLastSync = Date.now() - lastSyncTime;\n                    if (timeSinceLastSync < 60000) { // Skip if synced within last minute\n                        trackOperation('Periodic sync skipped - cycling mode active', {\n                            source: 'sync_reduction',\n                            timeSinceLastSync\n                        });\n                        return;\n                    }\n                }\n                synchronizeWithServerState('periodic');\n            }\n        }, 30000);\n        \n        showStatus('Application initialized successfully', 'success');\n    } catch (error) {\n        logError('initialization', error, { source: 'page_load' });\n        showStatus('Application initialization failed: ' + error.message, 'error');\n    }\n});\n\n// Setup event handlers\nfunction setupEventHandlers() {\n    document.getElementById('startButton').addEventListener('click', () => {\n        trackOperation('Start button clicked', { source: 'user_click' });\n        startSweep('user_initiated');\n    });\n    document.getElementById('stopButton').addEventListener('click', () => {\n        trackOperation('Stop button clicked', { source: 'user_click' });\n        stopSweep();\n    });\n    \n    // Add frequency button\n    const addFreqBtn = document.getElementById('addFrequencyButton');\n    if (addFreqBtn) {\n        addFreqBtn.addEventListener('click', () => {\n            trackOperation('Add frequency button clicked', { source: 'user_click' });\n            addFrequencyInput();\n        });\n    }\n    \n    // Cycle time input validation\n    const cycleTimeInput = document.getElementById('cycleTimeInput');\n    if (cycleTimeInput) {\n        cycleTimeInput.addEventListener('input', validateCycleTime);\n    }\n}\n\n// Enhanced frequency validation with real-time feedback\nfunction validateFrequencyInputById(inputId) {\n    const frequencyInput = document.getElementById(inputId);\n    if (!frequencyInput) return false;\n    \n    const frequencyItem = frequencyInput.closest('.frequency-item');\n    const unitSelect = frequencyInput.nextElementSibling;\n    const unit = unitSelect ? unitSelect.value : 'MHz';\n    const value = parseFloat(frequencyInput.value);\n    \n    // Remove existing validation messages\n    removeValidationMessage(frequencyItem);\n    \n    // Clear visual indicators\n    frequencyItem.classList.remove('invalid', 'valid');\n    \n    // Empty input validation\n    if (!frequencyInput.value.trim()) {\n        showValidationMessage(frequencyItem, 'Please enter a frequency value', 'error');\n        frequencyInput.setCustomValidity('Please enter a frequency value');\n        frequencyItem.classList.add('invalid');\n        return false;\n    }\n    \n    // Numeric validation\n    if (isNaN(value) || value <= 0) {\n        showValidationMessage(frequencyItem, 'Please enter a valid positive number', 'error');\n        frequencyInput.setCustomValidity('Please enter a valid positive number');\n        frequencyItem.classList.add('invalid');\n        return false;\n    }\n    \n    // Convert to MHz for validation\n    let freqMHz = value;\n    if (unit === 'GHz') {\n        freqMHz = value * 1000;\n    } else if (unit === 'kHz') {\n        freqMHz = value / 1000;\n    }\n    \n    // Range validation with specific guidance\n    if (freqMHz < 1) {\n        showValidationMessage(frequencyItem, \n            `Frequency too low. Minimum: 1 MHz (you entered ${freqMHz.toFixed(3)} MHz)`, 'error');\n        frequencyInput.setCustomValidity('Frequency too low - minimum 1 MHz');\n        frequencyItem.classList.add('invalid');\n        return false;\n    }\n    \n    if (freqMHz > 6000) {\n        showValidationMessage(frequencyItem, \n            `Frequency too high. Maximum: 6 GHz (you entered ${freqMHz.toFixed(3)} MHz)`, 'error');\n        frequencyInput.setCustomValidity('Frequency too high - maximum 6 GHz');\n        frequencyItem.classList.add('invalid');\n        return false;\n    }\n    \n    // All validations passed\n    frequencyInput.setCustomValidity('');\n    frequencyItem.classList.add('valid');\n    \n    return true;\n}\n\n// Show validation message with styling - only for errors\nfunction showValidationMessage(frequencyItem, message, type) {\n    if (type === 'error') {\n        removeValidationMessage(frequencyItem);\n        \n        const messageDiv = document.createElement('div');\n        messageDiv.className = `validation-message validation-${type}`;\n        messageDiv.textContent = message;\n        \n        frequencyItem.appendChild(messageDiv);\n    }\n}\n\n// Remove existing validation message\nfunction removeValidationMessage(frequencyItem) {\n    const existingMessage = frequencyItem.querySelector('.validation-message');\n    if (existingMessage) {\n        existingMessage.remove();\n    }\n}\n\n// Validate all frequency inputs\nfunction validateAllFrequencyInputs() {\n    const frequencyItems = document.querySelectorAll('.frequency-item');\n    let allValid = true;\n    \n    frequencyItems.forEach((item) => {\n        const input = item.querySelector('input[type=\"text\"]');\n        if (input && !validateFrequencyInputById(input.id)) {\n            allValid = false;\n        }\n    });\n    \n    return allValid;\n}\n\n// Enhanced cycle time validation with helpful feedback\nfunction validateCycleTime() {\n    const cycleTimeInput = document.getElementById('cycleTimeInput');\n    if (!cycleTimeInput) return true;\n    \n    const value = parseInt(cycleTimeInput.value);\n    const container = cycleTimeInput.parentElement;\n    \n    // Remove existing validation messages\n    removeCycleTimeValidationMessage(container);\n    \n    // Clear visual indicators\n    cycleTimeInput.classList.remove('invalid', 'valid');\n    \n    // Empty input\n    if (!cycleTimeInput.value.trim()) {\n        showCycleTimeValidationMessage(container, 'Please enter a cycle time', 'error');\n        cycleTimeInput.setCustomValidity('Please enter a cycle time');\n        cycleTimeInput.classList.add('invalid');\n        return false;\n    }\n    \n    // Numeric validation\n    if (isNaN(value) || value <= 0) {\n        showCycleTimeValidationMessage(container, 'Please enter a valid positive number', 'error');\n        cycleTimeInput.setCustomValidity('Please enter a valid positive number');\n        cycleTimeInput.classList.add('invalid');\n        return false;\n    }\n    \n    // Range validation with guidance\n    if (value < 1) {\n        showCycleTimeValidationMessage(container, 'Minimum cycle time is 1 second', 'error');\n        cycleTimeInput.setCustomValidity('Minimum cycle time is 1 second');\n        cycleTimeInput.classList.add('invalid');\n        return false;\n    }\n    \n    if (value > 300) {\n        showCycleTimeValidationMessage(container, 'Maximum cycle time is 300 seconds (5 minutes)', 'error');\n        cycleTimeInput.setCustomValidity('Maximum cycle time is 300 seconds');\n        cycleTimeInput.classList.add('invalid');\n        return false;\n    }\n    \n    // Success validation\n    cycleTimeInput.setCustomValidity('');\n    cycleTimeInput.classList.add('valid');\n    \n    return true;\n}\n\n// Show cycle time validation message - only for errors\nfunction showCycleTimeValidationMessage(container, message, type) {\n    if (type === 'error') {\n        removeCycleTimeValidationMessage(container);\n        \n        const messageDiv = document.createElement('div');\n        messageDiv.className = `cycle-validation-message validation-${type}`;\n        messageDiv.textContent = message;\n        \n        container.appendChild(messageDiv);\n    }\n}\n\n// Remove cycle time validation message\nfunction removeCycleTimeValidationMessage(container) {\n    const existingMessage = container.querySelector('.cycle-validation-message');\n    if (existingMessage) {\n        existingMessage.remove();\n    }\n}\n\n// Add frequency input\nfunction addFrequencyInput() {\n    const currentCount = document.getElementsByClassName('frequency-item').length;\n    \n    if (currentCount >= MAX_FREQUENCIES) {\n        showStatus(`Maximum ${MAX_FREQUENCIES} frequencies allowed`, 'warning');\n        return;\n    }\n    \n    const container = document.getElementById('frequencyList');\n    const newItem = document.createElement('div');\n    const newIndex = currentCount + 1;\n    \n    newItem.className = 'frequency-item saasfly-interactive-card flex items-center gap-3 p-4 bg-gradient-to-r from-bg-card/40 to-bg-card/20 rounded-xl border border-border-primary/40 hover:border-neon-cyan/40 hover:bg-gradient-to-r hover:from-bg-card/60 hover:to-bg-card/40 hover:shadow-md transition-all duration-300';\n    newItem.id = `frequencyItem${newIndex}`;\n    \n    newItem.innerHTML = `\n        <span class=\"font-mono text-sm text-text-muted font-semibold min-w-[24px] text-center bg-neon-cyan/10 rounded-lg px-2 py-1\">${newIndex}</span>\n        <div class=\"flex-1 relative\">\n            <input type=\"text\" id=\"frequencyInput${newIndex}\" placeholder=\"Target\" value=\"\" class=\"font-mono w-full pl-3 pr-12 py-2 bg-bg-input/80 border border-border-primary/60 rounded-lg text-text-primary outline-none focus:border-neon-cyan focus:bg-bg-input focus:shadow-neon-cyan-sm transition-all duration-300 placeholder:text-text-muted/50\">\n            <span class=\"absolute right-3 top-1/2 -translate-y-1/2 font-mono text-sm text-text-secondary font-medium pointer-events-none\">MHz</span>\n        </div>\n        ${newIndex > 1 ? `<button type=\"button\" onclick=\"removeFrequencyInput('frequencyItem${newIndex}')\" style=\"padding: 6px 12px !important; background-color: #ef4444 !important; color: white !important; border: none !important; border-radius: 6px !important; font-size: 14px !important; font-weight: 500 !important; cursor: pointer !important; box-shadow: none !important; text-shadow: none !important; outline: none !important; transition: box-shadow 0.3s ease !important;\" onmouseover=\"this.style.boxShadow='0 0 10px rgba(255, 255, 255, 0.4)'\" onmouseout=\"this.style.boxShadow='none'\">Remove</button>` : ''}\n    `;\n    \n    container.appendChild(newItem);\n    \n    // Add validation listener (skip during state restoration to prevent race conditions)\n    if (!isRestoringState) {\n        document.getElementById(`frequencyInput${newIndex}`).addEventListener('input', function() {\n            validateFrequencyInputById(this.id);\n        });\n        \n        // Add remove button event listener if it exists\n        const removeBtn = newItem.querySelector('.remove-frequency-btn');\n        if (removeBtn) {\n            removeBtn.addEventListener('click', function() {\n                const itemId = this.getAttribute('data-item-id');\n                removeFrequencyInput(itemId);\n            });\n        }\n    }\n    \n    updateAddButtonState();\n    updateNumbering();\n}\n\n// Add event listeners to frequency inputs after state restoration\nfunction addEventListenersToFrequencyInputs() {\n    const frequencyItems = document.querySelectorAll('.frequency-item');\n    frequencyItems.forEach((item, index) => {\n        const input = item.querySelector('input[type=\"text\"]');\n        const removeBtn = item.querySelector('.remove-frequency-btn');\n        \n        if (input) {\n            // Remove existing listeners by cloning\n            const newInput = input.cloneNode(true);\n            input.parentNode.replaceChild(newInput, input);\n            \n            // Add validation listener\n            newInput.addEventListener('input', function() {\n                validateFrequencyInputById(this.id);\n            });\n        }\n        \n        if (removeBtn && index > 0) { // Only add to non-first items\n            // Remove existing listeners by cloning\n            const newRemoveBtn = removeBtn.cloneNode(true);\n            removeBtn.parentNode.replaceChild(newRemoveBtn, removeBtn);\n            \n            // Add remove button event listener\n            newRemoveBtn.addEventListener('click', function() {\n                const itemId = this.getAttribute('data-item-id');\n                removeFrequencyInput(itemId);\n            });\n        }\n    });\n}\n\n// Remove frequency input\nfunction removeFrequencyInput(itemId) {\n    // Don't allow removing the last frequency\n    const frequencyItems = document.querySelectorAll('.frequency-item');\n    if (frequencyItems.length <= 1) {\n        showStatus('At least one frequency is required', 'warning');\n        return;\n    }\n    \n    const item = document.getElementById(itemId);\n    if (item) {\n        item.remove();\n        updateAddButtonState();\n        updateNumbering();\n        // updateRemoveButtons(); // Commented out to prevent duplicate remove buttons\n    }\n}\n\n// Update numbering of frequency items\nfunction updateNumbering() {\n    const frequencyItems = document.querySelectorAll('.frequency-item');\n    frequencyItems.forEach((item, index) => {\n        const numberSpan = item.querySelector('.frequency-number');\n        if (numberSpan) {\n            numberSpan.textContent = index + 1;\n        }\n    });\n}\n\n// Update remove buttons (ensure first frequency item doesn't have remove button)\nfunction updateRemoveButtons() {\n    const frequencyItems = document.querySelectorAll('.frequency-item');\n    frequencyItems.forEach((item, index) => {\n        const removeBtn = item.querySelector('.remove-frequency-btn');\n        \n        if (index === 0) {\n            // First item should not have remove button\n            if (removeBtn) {\n                removeBtn.remove();\n            }\n        } else {\n            // Other items should have remove button\n            if (!removeBtn) {\n                const newRemoveBtn = document.createElement('button');\n                newRemoveBtn.type = 'button';\n                newRemoveBtn.className = 'remove-frequency-btn';\n                newRemoveBtn.textContent = 'Remove';\n                newRemoveBtn.setAttribute('data-item-id', item.id);\n                \n                newRemoveBtn.addEventListener('click', function() {\n                    const itemId = this.getAttribute('data-item-id');\n                    removeFrequencyInput(itemId);\n                });\n                \n                item.appendChild(newRemoveBtn);\n            } else {\n                // Update existing button's data-item-id and event listener\n                removeBtn.setAttribute('data-item-id', item.id);\n                \n                // Remove old event listeners by cloning the element\n                const newRemoveBtn = removeBtn.cloneNode(true);\n                newRemoveBtn.addEventListener('click', function() {\n                    const itemId = this.getAttribute('data-item-id');\n                    removeFrequencyInput(itemId);\n                });\n                \n                removeBtn.parentNode.replaceChild(newRemoveBtn, removeBtn);\n            }\n        }\n    });\n}\n\n// Update add button state\nfunction updateAddButtonState() {\n    const addBtn = document.getElementById('addFrequencyButton');\n    if (addBtn) {\n        const currentCount = document.getElementsByClassName('frequency-item').length;\n        addBtn.disabled = currentCount >= MAX_FREQUENCIES || isScanning;\n        if (currentCount >= MAX_FREQUENCIES) {\n            addBtn.textContent = `Maximum Reached (${MAX_FREQUENCIES})`;\n        } else {\n            addBtn.textContent = '+ Add Frequency';\n        }\n    }\n}\n\n// Collect all frequencies\nfunction collectFrequencies() {\n    const frequencies = [];\n    const frequencyItems = document.querySelectorAll('.frequency-item');\n    \n    frequencyItems.forEach((item) => {\n        const input = item.querySelector('input[type=\"text\"]');\n        \n        if (input && input.value) {\n            frequencies.push({\n                value: parseFloat(input.value),\n                unit: 'MHz'  // Always use MHz since dropdown is removed\n            });\n        }\n    });\n    \n    return frequencies;\n}\n\n// Enhanced startSweep with detailed tracking and error recovery\nasync function startSweep(initiationType = 'unknown') {\n    const attemptId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n    \n    // Track start attempt with detailed context\n    const attemptContext = {\n        attemptId,\n        type: initiationType,\n        timestamp: new Date().toISOString(),\n        source: initiationType === 'user_initiated' ? 'user_click' : 'system_call',\n        callStack: getCallStack().slice(0, 5),\n        currentState: {\n            isScanning,\n            isCycling,\n            connectionStatus,\n            sseConnectionActive\n        }\n    };\n    \n    window.startSweepTracker.attempts.push(attemptContext);\n    if (window.startSweepTracker.attempts.length > 10) {\n        window.startSweepTracker.attempts.shift();\n    }\n    \n    if (initiationType === 'user_initiated') {\n        window.startSweepTracker.lastUserInitiated = attemptContext;\n    } else {\n        window.startSweepTracker.lastSystemInitiated = attemptContext;\n    }\n    \n    trackOperation(`Start sweep initiated (${initiationType})`, {\n        source: attemptContext.source,\n        attemptId,\n        stateCheck: `scanning=${isScanning}, cycling=${isCycling}`\n    });\n    \n    // Synchronization guard flags - prevent start operations during sync or restoration\n    // CYCLING EXCEPTION: Allow cycling operations to bypass certain sync blocks\n    const isCyclingBypass = (initiationType === 'cycling' || activeCyclingOperation);\n    \n    if ((isSynchronizing || syncInProgress || isRestoringState) && !isCyclingBypass) {\n        // Emergency fallback: If sync flags have been stuck for too long, reset them\n        const now = Date.now();\n        if (!window.lastSyncBlockTime) {\n            window.lastSyncBlockTime = now;\n        } else if (now - window.lastSyncBlockTime > 10000) { // 10 seconds\n            console.warn('⚠️ Sync flags stuck for >10s - force resetting');\n            resetSyncFlags();\n            window.lastSyncBlockTime = null;\n            // Continue with startSweep after reset\n        } else {\n            trackOperation('Start sweep blocked: synchronization in progress', { \n                source: attemptContext.source,\n                attemptId,\n                recovery: 'Wait for synchronization to complete',\n                cyclingBypass: isCyclingBypass\n            });\n            console.log('Start sweep blocked due to synchronization/restoration in progress');\n            showEnhancedError('Operation blocked while synchronizing with server', 'startSweep', {\n                recovery: 'Please wait a moment for synchronization to complete and try again.',\n                context: attemptContext\n            });\n            return;\n        }\n    } else {\n        // Reset the block time when flags are clear\n        window.lastSyncBlockTime = null;\n    }\n    \n    // Pre-flight state check with recovery suggestions\n    if (isScanning) {\n        const errorMsg = 'Sweep is already running. Please stop the current sweep first.';\n        trackOperation('Start sweep blocked: already scanning', { \n            source: attemptContext.source,\n            attemptId,\n            recovery: 'Click Stop button first'\n        });\n        showEnhancedError(errorMsg, 'startSweep', {\n            recovery: 'Click the \"Stop Sweep\" button to stop the current operation before starting a new one.',\n            context: attemptContext\n        });\n        return;\n    }\n    \n    // Validate all frequencies\n    if (!validateAllFrequencyInputs()) {\n        const errorMsg = 'Please fix invalid frequency inputs before starting';\n        trackOperation('Start sweep failed: invalid frequency inputs', { \n            source: attemptContext.source,\n            attemptId,\n            recovery: 'Fix frequency validation errors'\n        });\n        showEnhancedError(errorMsg, 'startSweep', {\n            recovery: 'Check the frequency inputs for red validation messages and correct any errors.',\n            context: attemptContext\n        });\n        return;\n    }\n    \n    const frequencies = collectFrequencies();\n    if (frequencies.length === 0) {\n        const errorMsg = 'Please enter at least one frequency';\n        trackOperation('Start sweep failed: no frequencies entered', { \n            source: attemptContext.source,\n            attemptId,\n            recovery: 'Enter at least one frequency'\n        });\n        showEnhancedError(errorMsg, 'startSweep', {\n            recovery: 'Enter a valid frequency value in at least one frequency input field.',\n            context: attemptContext\n        });\n        return;\n    }\n    \n    // Validate cycle time if multiple frequencies\n    let cycleTime = 10; // Default cycle time\n    \n    if (frequencies.length > 1) {\n        if (!validateCycleTime()) {\n            const errorMsg = 'Invalid cycle time for multi-frequency operation';\n            trackOperation('Start sweep failed: invalid cycle time', { \n                source: attemptContext.source,\n                attemptId,\n                recovery: 'Set valid cycle time (1-300 seconds)'\n            });\n            showEnhancedError(errorMsg, 'startSweep', {\n                recovery: 'Enter a cycle time between 1 and 300 seconds for multi-frequency scanning.',\n                context: attemptContext\n            });\n            return;\n        }\n        const cycleTimeInput = document.getElementById('cycleTimeInput');\n        if (cycleTimeInput) {\n            cycleTime = parseInt(cycleTimeInput.value) || 10;\n        }\n    }\n    \n    // Show loading state\n    showStatus('Starting sweep...', 'info', true);\n    setLoadingState(true);\n    \n    trackOperation(`Starting sweep request for ${frequencies.length} frequencies`, {\n        source: attemptContext.source,\n        attemptId,\n        frequencies: frequencies.map(f => `${f.value}${f.unit}`).join(', '),\n        cycleTime\n    });\n    \n    // Set timeout for startup process with enhanced tracking\n    startupTimeout = setTimeout(() => {\n        if (!isScanning) {\n            const timeoutError = 'Startup timeout. Please check HackRF connection and try again.';\n            trackOperation('Start sweep timeout', {\n                source: attemptContext.source,\n                attemptId,\n                recovery: 'Check HackRF hardware connection'\n            });\n            showEnhancedError(timeoutError, 'startSweep', {\n                recovery: 'Check that your HackRF device is properly connected and powered on. Try unplugging and reconnecting the USB cable.',\n                context: attemptContext\n            });\n            setLoadingState(false);\n        }\n    }, 30000); // 30 second timeout\n    \n    try {\n        const requestBody = {\n            frequencies: frequencies,\n            cycleTime: cycleTime\n        };\n        \n        // For backward compatibility, if single frequency, also send old format\n        if (frequencies.length === 1) {\n            requestBody.frequency = frequencies[0].value;\n            requestBody.unit = frequencies[0].unit;\n        }\n        \n        trackOperation('Sending start-sweep request to server', {\n            source: attemptContext.source,\n            attemptId,\n            requestBody: JSON.stringify(requestBody)\n        });\n        \n        const response = await fetch(`${API_BASE_URL}/start-sweep`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(requestBody)\n        });\n        \n        const data = await response.json();\n        \n        if (response.ok) {\n            clearTimeout(startupTimeout);\n            isScanning = true;\n            isCycling = frequencies.length > 1;\n            currentFrequencyIndex = 0;\n            connectionRetryCount = 0;\n            connectionStatus = 'connected';\n            globalCycleTime = cycleTime;  // Store cycle time globally for timer sync\n            \n            // Set cycling mode flags for guard bypass and reduced sync\n            if (isCycling) {\n                activeCyclingOperation = true;\n                reducedSyncMode = true;\n                trackOperation('Cycling mode activated - reduced sync enabled', {\n                    source: attemptContext.source,\n                    frequencies: frequencies.length,\n                    cycleTime\n                });\n            }\n            \n            setLoadingState(false);\n            updateButtonStates();\n            updateConnectionStatus();\n            \n            trackOperation(`Start sweep successful (${initiationType})`, {\n                source: attemptContext.source,\n                attemptId,\n                frequencies: frequencies.length,\n                cycleTime,\n                cycling: isCycling\n            });\n            \n            if (isCycling) {\n                showCycleStatus(true);\n                startCycleDisplay(frequencies, cycleTime);\n                showStatus(`Started cycling ${frequencies.length} frequencies`, 'success');\n                trackOperation(`Sweep started: cycling ${frequencies.length} frequencies every ${cycleTime}s`, {\n                    source: attemptContext.source,\n                    attemptId\n                });\n            } else {\n                showStatus('Started monitoring single frequency', 'success');\n                trackOperation(`Sweep started: single frequency ${frequencies[0].value} ${frequencies[0].unit}`, {\n                    source: attemptContext.source,\n                    attemptId\n                });\n            }\n            \n            connectSSE();\n            updateFrequencyHighlight(0);\n        } else {\n            clearTimeout(startupTimeout);\n            setLoadingState(false);\n            \n            // Enhanced server error handling with detailed tracking\n            const errorMessage = data.error || 'Failed to start sweep';\n            trackOperation(`Start sweep server error: ${errorMessage}`, {\n                source: attemptContext.source,\n                attemptId,\n                serverResponse: data,\n                statusCode: response.status,\n                recovery: 'Check server logs and HackRF connection'\n            });\n            \n            let recoveryMessage = 'Try restarting the application or checking the server logs.';\n            if (errorMessage.toLowerCase().includes('hackrf')) {\n                recoveryMessage = 'Check that your HackRF device is properly connected and not in use by another application.';\n            } else if (errorMessage.toLowerCase().includes('frequency')) {\n                recoveryMessage = 'Verify that your frequency values are within the HackRF\\'s supported range (1 MHz to 6 GHz).';\n            }\n            \n            showEnhancedError(errorMessage, 'startSweep', {\n                recovery: recoveryMessage,\n                context: attemptContext\n            });\n        }\n    } catch (error) {\n        clearTimeout(startupTimeout);\n        setLoadingState(false);\n        \n        // Enhanced error tracking for network/connection issues\n        trackOperation(`Start sweep network error: ${error.message}`, {\n            source: attemptContext.source,\n            attemptId,\n            errorType: error.name,\n            recovery: 'Check network connection and server status'\n        });\n        \n        logError('startSweep', error, { \n            frequencies, \n            cycleTime,\n            attemptContext,\n            networkError: true\n        });\n        \n        // Update connection status if it's a network error\n        if (error.message.includes('Failed to fetch') || error.name === 'TypeError') {\n            connectionStatus = 'disconnected';\n            updateConnectionStatus();\n        }\n        \n        // Provide specific recovery suggestions based on error type\n        let recoveryMessage = 'Check your network connection and try again.';\n        if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {\n            recoveryMessage = 'Cannot connect to the server. Check that the server is running and your network connection is working.';\n        } else if (error.name === 'AbortError') {\n            recoveryMessage = 'The request was cancelled. This may happen if you clicked start multiple times quickly.';\n        }\n        \n        showEnhancedError(error, 'startSweep', {\n            recovery: recoveryMessage,\n            context: attemptContext\n        });\n        \n        // Reset button states on error\n        isScanning = false;\n        isCycling = false;\n        updateButtonStates();\n    }\n}\n\n// Stop sweep with enhanced resilience and complete state synchronization\nasync function stopSweep() {\n    trackOperation('Stop sweep initiated', {\n        source: 'user_action',\n        currentState: { isScanning, isCycling, connectionStatus }\n    });\n    const endpoint = '/stop-sweep';\n    const timeoutMs = 15000; // Increased to 15 second timeout for complete cleanup\n    \n    try {\n        showStatus('Stopping sweep and verifying cleanup...', 'info', true);\n        \n        // Create abort controller for timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => {\n            controller.abort();\n        }, timeoutMs);\n        \n        const response = await fetch(`${API_BASE_URL}${endpoint}`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            signal: controller.signal\n        });\n        \n        clearTimeout(timeoutId);\n        \n        const data = await response.json();\n        \n        if (response.ok) {\n            // Wait for complete backend stop before showing success\n            showStatus('Stopping sweep...', 'info', true);\n            \n            // Add 500ms delay before verification to allow backend processes to complete\n            await new Promise(resolve => setTimeout(resolve, 500));\n            \n            // Verify the stop with server state check (tolerant of transitional states)\n            await verifyStopCompletion();\n            \n            resetScanningState();\n            showStatus('Sweep stopped successfully', 'success');\n        } else {\n            // Handle specific backend error messages for split brain scenarios\n            if (data.error && data.error.includes('No sweep is running')) {\n                // Backend says no sweep running, so just reset UI state\n                resetScanningState();\n                showStatus('No sweep was running on server - UI state reset', 'info');\n            } else {\n                throw new Error(data.error || 'Failed to stop sweep');\n            }\n        }\n    } catch (error) {\n        logError('stopSweep', error, { endpoint });\n        \n        let errorMessage = '';\n        \n        if (error.name === 'AbortError') {\n            errorMessage = `Stop request timed out after ${timeoutMs/1000} seconds`;\n        } else if (error.message.includes('Failed to fetch')) {\n            errorMessage = 'Unable to connect to server for stop request';\n        } else {\n            errorMessage = `Error stopping sweep: ${error.message}`;\n        }\n        \n        showStatus(errorMessage, 'error');\n        \n        // Always reset states even if stop failed\n        resetScanningState();\n    }\n}\n\n// Reset all scanning-related states\nfunction resetScanningState() {\n    isScanning = false;\n    isCycling = false;\n    currentFrequencyIndex = 0;\n    connectionStatus = 'disconnected';\n    \n    // Clear cycling operation flags\n    activeCyclingOperation = false;\n    reducedSyncMode = false;\n    \n    clearTimeout(startupTimeout);\n    setLoadingState(false);\n    clearCycleDisplay();\n    updateButtonStates();\n    updateConnectionStatus();\n    \n    disconnectSSE();\n    resetDisplay();\n    clearFrequencyHighlights();\n    showCycleStatus(false);\n    \n    trackOperation('Cycling mode deactivated - normal sync restored', {\n        source: 'state_reset'\n    });\n}\n\n\n// Initialize cycle status with default values\nfunction initializeCycleStatus() {\n    const cycleStatus = document.getElementById('cycleStatus');\n    if (cycleStatus) {\n        // Ensure cycle status is always visible\n        cycleStatus.classList.remove('hidden');\n        cycleStatus.classList.remove('active');\n        \n        // Set default values\n        updateCurrentFrequencyDisplay(null); // Will show '--'\n        const timerDisplay = document.getElementById('switchTimer');\n        if (timerDisplay) {\n            timerDisplay.textContent = '--';\n        }\n    }\n}\n\n// Show/hide cycle status display - Modified to always show\nfunction showCycleStatus(show) {\n    const cycleStatus = document.getElementById('cycleStatus');\n    if (cycleStatus) {\n        // Always keep cycle status visible, just change active state\n        cycleStatus.classList.remove('hidden');\n        if (show) {\n            cycleStatus.classList.add('active');\n        } else {\n            cycleStatus.classList.remove('active');\n        }\n    }\n}\n\n// Start cycle display\nfunction startCycleDisplay(frequencies, cycleTime) {\n    // Store frequencies globally for next frequency calculations\n    globalFrequencies = frequencies || [];\n    \n    // Show the next frequency that will be scanned, not the current one\n    updateNextFrequencyDisplay(frequencies, currentFrequencyIndex);\n    startTimer(cycleTime);\n}\n\n// Update current frequency display\nfunction updateCurrentFrequencyDisplay(frequency) {\n    const currentFreqElement = document.getElementById('currentFrequencyDisplay');\n    if (currentFreqElement) {\n        if (frequency && frequency.value && frequency.unit) {\n            currentFreqElement.textContent = `${frequency.value} ${frequency.unit}`;\n        } else {\n            currentFreqElement.textContent = '--';\n        }\n    }\n}\n\n// Update next frequency display (what frequency will be scanned next)\nfunction updateNextFrequencyDisplay(frequencies, currentIndex) {\n    const currentFreqElement = document.getElementById('currentFrequencyDisplay');\n    \n    // Use provided frequencies or global frequencies\n    const freqList = frequencies || globalFrequencies;\n    \n    if (!currentFreqElement || !freqList || freqList.length === 0) {\n        if (currentFreqElement) {\n            currentFreqElement.textContent = '--';\n        }\n        return;\n    }\n    \n    // Calculate next frequency index (wrap around if at end)\n    const nextIndex = (currentIndex + 1) % freqList.length;\n    const nextFrequency = freqList[nextIndex];\n    \n    if (nextFrequency && nextFrequency.value && nextFrequency.unit) {\n        currentFreqElement.textContent = `${nextFrequency.value} ${nextFrequency.unit}`;\n    } else {\n        currentFreqElement.textContent = '--';\n    }\n}\n\n// Start countdown timer with signal indicator synchronization\nfunction startTimer(cycleTime) {\n    // Clear any existing timer first to prevent multiple timers\n    if (cycleTimer) {\n        clearInterval(cycleTimer);\n        cycleTimer = null;\n    }\n    \n    // Convert milliseconds to seconds\n    const cycleTimeSeconds = Math.round(cycleTime / 1000);\n    let remaining = cycleTimeSeconds;\n    const timerDisplay = document.getElementById('switchTimer');\n    const progressBar = document.getElementById('timerProgressBar');\n    const signalFill = document.getElementById('signalIndicatorFill');\n    const dbIndicator = document.getElementById('dbCurrentIndicator');\n    \n    // Reset signal indicator position to sync with timer restart\n    signalResetInProgress = true;\n    \n    if (signalFill && dbIndicator) {\n        signalFill.style.width = '0%';\n        dbIndicator.style.left = '0%';\n        // Reset to weak signal class\n        signalFill.classList.remove('gradient-weak', 'gradient-moderate', 'gradient-strong', 'gradient-very-strong');\n        signalFill.classList.add('gradient-weak');\n        // Reset dB value display\n        document.getElementById('dbCurrentValue').textContent = '-90 dB';\n    }\n    \n    // Allow signal updates after brief delay to prevent immediate override\n    setTimeout(() => {\n        signalResetInProgress = false;\n    }, 100); // 100ms delay to prevent race condition\n    \n    const updateTimer = () => {\n        if (timerDisplay) {\n            timerDisplay.textContent = `${remaining}s`;\n        }\n        \n        if (progressBar) {\n            const percentage = ((cycleTimeSeconds - remaining) / cycleTimeSeconds) * 100;\n            progressBar.style.width = `${percentage}%`;\n        }\n        \n        remaining--;\n        \n        if (remaining < 0) {\n            remaining = cycleTimeSeconds; // Reset for next cycle\n            \n            // Coordinate signal indicator reset with cycle restart\n            signalResetInProgress = true;\n            \n            if (signalFill && dbIndicator) {\n                signalFill.style.width = '0%';\n                dbIndicator.style.left = '0%';\n                // Reset to weak signal class\n                signalFill.classList.remove('gradient-weak', 'gradient-moderate', 'gradient-strong', 'gradient-very-strong');\n                signalFill.classList.add('gradient-weak');\n                // Reset dB value display\n                document.getElementById('dbCurrentValue').textContent = '-90 dB';\n            }\n            \n            // Allow signal updates after brief delay to prevent immediate override\n            setTimeout(() => {\n                signalResetInProgress = false;\n            }, 100); // 100ms delay to prevent race condition\n        }\n    };\n    \n    updateTimer(); // Initial update\n    cycleTimer = setInterval(updateTimer, 1000);\n}\n\n// Clear cycle display\nfunction clearCycleDisplay() {\n    if (cycleTimer) {\n        clearInterval(cycleTimer);\n        cycleTimer = null;\n    }\n    \n    const timerDisplay = document.getElementById('timerDisplay');\n    const progressBar = document.getElementById('timerProgressBar');\n    const currentFreq = document.getElementById('currentFrequency');\n    \n    if (timerDisplay) timerDisplay.textContent = '--';\n    if (progressBar) progressBar.style.width = '0%';\n    if (currentFreq) currentFreq.textContent = '--';\n}\n\n// Connect to SSE\nfunction connectSSE() {\n    // Prevent duplicate connections\n    if (sseConnectionActive && eventSource && eventSource.readyState !== EventSource.CLOSED) {\n        return;\n    }\n    \n    if (eventSource) {\n        eventSource.close();\n    }\n    \n    sseConnectionActive = true;\n    eventSource = new EventSource(`${API_BASE_URL}/data-stream`);\n    \n    eventSource.onopen = () => {\n        console.log('SSE connection established');\n        connectionStatus = 'connected';\n        connectionRetryCount = 0;\n        updateConnectionStatus();\n        \n        // Reset sync flags when SSE connects to clear any stuck states\n        resetSyncFlags();\n        \n        if (connectionRetryCount > 0) {\n            showStatus('Connection restored', 'success');\n        }\n        \n        // Don't call synchronizeWithServerState here - it causes a loop\n        // The periodic sync (every 30 seconds) will handle state updates\n    };\n    \n    // Comment out generic message handler to avoid duplicate processing\n    // eventSource.onmessage = (event) => {\n    //     try {\n    //         const data = JSON.parse(event.data);\n    //         updateDisplay(data);\n    //         \n    //         // Update heartbeat and connection status on successful data\n    //         if (connectionStatus !== 'connected') {\n    //             connectionStatus = 'connected';\n    //             connectionRetryCount = 0;\n    //             updateConnectionStatus();\n    //         }\n    //     } catch (error) {\n    //         logError('SSE data parsing', error, { eventData: event.data });\n    //         showStatus('Error parsing data from server', 'warning');\n    //     }\n    // };\n    \n    // Handle sweep_data events (signal strength updates) - SIGNAL DATA ONLY\n    eventSource.addEventListener('sweep_data', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            \n            \n            updateDisplay(data); // Signal data processing - no cycle state management\n            \n            // Update connection status on successful data\n            if (connectionStatus !== 'connected') {\n                connectionStatus = 'connected';\n                connectionRetryCount = 0;\n                updateConnectionStatus();\n            }\n        } catch (error) {\n            logError('SSE sweep_data parsing', error, { eventData: event.data });\n            showStatus('Error parsing sweep data from server', 'warning');\n        }\n    });\n    \n    // Handle status_change events - CYCLE STATE MANAGEMENT ONLY\n    eventSource.addEventListener('status_change', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            handleStatusChange(data); // Cycle state changes and frequency display updates\n        } catch (error) {\n            console.error('Error parsing status change:', error);\n        }\n    });\n    \n    // Handle cycle_config events - CYCLE CONFIGURATION ONLY\n    eventSource.addEventListener('cycle_config', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            handleCycleConfig(data); // Initial cycle setup and configuration\n        } catch (error) {\n            console.error('Error parsing cycle config:', error);\n        }\n    });\n    \n    eventSource.addEventListener('error', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            const errorMessage = data.message || 'Error occurred';\n            \n            // Use enhanced error display for better user feedback\n            const errorType = data.errorType || 'general_error';\n            const recoveryMessage = getGeneralErrorRecovery(errorType, data);\n            \n            showEnhancedError(errorMessage, 'general_error', {\n                recovery: recoveryMessage,\n                context: { \n                    errorType: errorType,\n                    severity: data.severity || 'medium',\n                    retryable: isRetryableError(errorType)\n                }\n            });\n            \n            trackOperation(`General error: ${errorMessage}`, { \n                source: 'sse_error',\n                errorType: errorType,\n                severity: data.severity\n            });\n            \n        } catch (error) {\n            console.error('Error parsing error event:', error);\n            showStatus('An unknown error occurred', 'error');\n        }\n    });\n    \n    // Handle emergency stop events\n    eventSource.addEventListener('emergency_stop', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            console.log('🚨 Emergency stop event received from server');\n            \n            // Force reset UI state immediately\n            resetScanningState();\n            showStatus('🚨 Emergency stop executed by server - all processes terminated', 'warning');\n            trackOperation('Emergency stop executed by server');\n            \n        } catch (error) {\n            console.error('Error parsing emergency_stop event:', error);\n        }\n    });\n    \n    // Handle server reset events\n    eventSource.addEventListener('server_reset', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            console.log('🔧 Server reset event received');\n            \n            showStatus('🔧 Server reset in progress - page will reload automatically', 'warning');\n            \n            // Force reset UI state\n            resetScanningState();\n            \n            // Disconnect from SSE\n            disconnectSSE();\n            \n            // Reload page after brief delay to allow server to complete reset\n            setTimeout(() => {\n                window.location.reload();\n            }, 3000);\n            \n        } catch (error) {\n            console.error('Error parsing server_reset event:', error);\n        }\n    });\n    \n    // Handle state sync events\n    eventSource.addEventListener('state_sync', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            console.log('🔄 State sync event received from server');\n            \n            showStatus('🔄 Server state synchronized', 'info');\n            \n            // Update UI with the latest state\n            if (data.afterState) {\n                restoreUIStateFromServer(data.afterState);\n            }\n            \n        } catch (error) {\n            console.error('Error parsing state_sync event:', error);\n        }\n    });\n\n\n\n    // Handle stuck recovery events\n    eventSource.addEventListener('stuck_recovery_attempted', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            showStatus(`🔧 Attempting stuck recovery (${data.attempt}/${data.maxAttempts})`, 'warning');\n        } catch (error) {\n            console.error('Error parsing stuck_recovery_attempted event:', error);\n        }\n    });\n\n    eventSource.addEventListener('stuck_recovery_successful', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            showStatus('✅ Stuck recovery successful', 'success');\n        } catch (error) {\n            console.error('Error parsing stuck_recovery_successful event:', error);\n        }\n    });\n\n    eventSource.addEventListener('stuck_recovery_failed', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            showEnhancedError(`🚨 Stuck recovery failed: ${data.message}`, 'stuck_recovery', {\n                recovery: 'Check HackRF connection and try restarting the sweep operation.',\n                context: { errorType: 'stuck_recovery_failure', attempts: data.attempts }\n            });\n        } catch (error) {\n            console.error('Error parsing stuck_recovery_failed event:', error);\n        }\n    });\n\n    // Handle cycling-specific error events\n    eventSource.addEventListener('cycling_error', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            handleCyclingError(data);\n        } catch (error) {\n            console.error('Error parsing cycling_error event:', error);\n        }\n    });\n\n    eventSource.addEventListener('frequency_error', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            handleFrequencyError(data);\n        } catch (error) {\n            console.error('Error parsing frequency_error event:', error);\n        }\n    });\n\n    eventSource.addEventListener('graceful_stop', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            handleGracefulStop(data);\n        } catch (error) {\n            console.error('Error parsing graceful_stop event:', error);\n        }\n    });\n\n    eventSource.addEventListener('stuck_recovery_error', (event) => {\n        try {\n            const data = JSON.parse(event.data);\n            showEnhancedError(`🔧 Recovery attempt failed: ${data.error}`, 'recovery_error', {\n                recovery: 'Try restarting the scanning operation or check HackRF connection.',\n                context: { errorType: 'recovery_error', attempt: data.attempt }\n            });\n        } catch (error) {\n            console.error('Error parsing stuck_recovery_error event:', error);\n        }\n    });\n    \n    eventSource.onerror = (error) => {\n        console.error('SSE error:', error);\n        connectionStatus = 'error';\n        sseConnectionActive = false;  // Mark connection as inactive\n        updateConnectionStatus();\n        \n        if (eventSource.readyState === EventSource.CLOSED) {\n            connectionRetryCount++;\n            \n            if (connectionRetryCount <= maxRetryAttempts) {\n                showStatus(`Connection lost. Attempting to reconnect... (${connectionRetryCount}/${maxRetryAttempts})`, 'warning');\n                \n                // Reset states on connection loss (but preserve cycling flags for reconnection)\n                if (isScanning) {\n                    isScanning = false;\n                    isCycling = false;\n                    // Don't immediately clear cycling flags - may reconnect during cycling\n                    updateButtonStates();\n                }\n                \n                // Try to reconnect with exponential backoff\n                const retryDelay = Math.min(5000 * Math.pow(2, connectionRetryCount - 1), 30000);\n                setTimeout(() => {\n                    if (connectionRetryCount <= maxRetryAttempts) {\n                        console.log(`Attempting to reconnect (attempt ${connectionRetryCount})...`);\n                        connectSSE();\n                    }\n                }, retryDelay);\n            } else {\n                showStatus('Connection failed after multiple attempts. Server may be down or HackRF disconnected.', 'error');\n                // Connection error\n                \n                // Reset states on final failure\n                isScanning = false;\n                isCycling = false;\n                // Clear cycling flags on final connection failure\n                activeCyclingOperation = false;\n                reducedSyncMode = false;\n                updateButtonStates();\n            }\n        }\n    };\n}\n\n// Disconnect SSE\nfunction disconnectSSE() {\n    sseConnectionActive = false;  // Mark connection as inactive\n    if (eventSource) {\n        eventSource.close();\n        eventSource = null;\n    }\n}\n\n// Enhanced synchronization with detailed tracking\nasync function synchronizeWithServerState(syncReason = 'manual') {\n    // Prevent recursive synchronization calls\n    if (isSynchronizing) {\n        trackOperation('Sync blocked: already synchronizing', { source: 'sync_guard', reason: syncReason });\n        return;\n    }\n    \n    // CYCLING PRIORITY: Reduce sync blocking during active cycling\n    const isCyclingSync = (syncReason === 'cycling_frequency_switch' || activeCyclingOperation);\n    \n    isSynchronizing = true;\n    syncInProgress = !isCyclingSync;  // Don't block startSweep during cycling sync\n    lastSyncTime = Date.now();  // Track sync timing\n    const syncId = Date.now() + '_' + Math.random().toString(36).substr(2, 5);\n    \n    trackOperation(`State synchronization started (${syncReason})`, { \n        source: 'state_sync',\n        syncId,\n        currentState: { isScanning, isCycling, connectionStatus }\n    });\n    \n    try {\n        // Create abort controller for timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => {\n            controller.abort();\n        }, 5000);\n        \n        const response = await fetch(`${API_BASE_URL}/cycle-status`, {\n            method: 'GET',\n            signal: controller.signal\n        });\n        \n        clearTimeout(timeoutId);\n        \n        if (response.ok) {\n            const serverState = await response.json();\n            \n            trackOperation('Server state received', {\n                source: 'state_sync',\n                syncId,\n                serverRunning: Boolean(serverState.isRunning || serverState.isActive),\n                frequencies: serverState.frequencies?.length || 0\n            });\n            \n            // Validate server state structure\n            if (typeof serverState === 'object' && serverState !== null) {\n                // Check for state coherence issues on the server\n                if (serverState.stateCoherent === false) {\n                    console.warn('⚠️ Server state incoherent detected - process and running state mismatch');\n                    trackOperation('Server state incoherent detected', {\n                        source: 'state_sync',\n                        syncId,\n                        recovery: 'Server auto-fixing state coherence'\n                    });\n                    showStatus('Server state synchronization in progress...', 'warning');\n                }\n                \n                // Check if server state differs from UI state\n                const stateChanged = restoreUIStateFromServer(serverState);\n                \n                \n                // Always ensure button states match reality after synchronization\n                const serverIsActive = Boolean(serverState.isRunning || serverState.isActive);\n                verifyButtonStatesMatchReality(serverIsActive);\n                \n                // Track last sync time\n                window.lastStateSyncTime = new Date().toLocaleTimeString();\n                \n                if (stateChanged) {\n                    trackOperation('UI state synchronized with server', {\n                        source: 'state_sync',\n                        syncId,\n                        changes: 'State differences resolved'\n                    });\n                    showStatus('UI state synchronized with server state', 'info');\n                } else {\n                    trackOperation('States already synchronized', {\n                        source: 'state_sync',\n                        syncId\n                    });\n                }\n            }\n        } else {\n            trackOperation(`Sync failed: HTTP ${response.status}`, {\n                source: 'state_sync',\n                syncId,\n                statusCode: response.status\n            });\n        }\n    } catch (error) {\n        // Track sync errors for debugging but don't show to user\n        trackOperation(`Sync error: ${error.message}`, {\n            source: 'state_sync',\n            syncId,\n            errorType: error.name,\n            reason: syncReason\n        });\n        \n        if (error.name === 'AbortError') {\n            console.log('State sync timed out - this is normal during server operations');\n        } else {\n            console.log('State sync failed:', error.message);\n        }\n    } finally {\n        isSynchronizing = false;\n        syncInProgress = false;  // Clear guard flag\n        \n        trackOperation(`State synchronization completed (${syncReason})`, {\n            source: 'state_sync',\n            syncId,\n            cyclingMode: activeCyclingOperation,\n            reducedSync: reducedSyncMode\n        });\n    }\n}\n\n// Verify that the stop operation has completed on the server\nasync function verifyStopCompletion() {\n    try {\n        // Create abort controller for timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => {\n            controller.abort();\n        }, 3000); // 3 second timeout for verification\n        \n        const response = await fetch(`${API_BASE_URL}/cycle-status`, {\n            method: 'GET',\n            signal: controller.signal\n        });\n        \n        clearTimeout(timeoutId);\n        \n        if (response.ok) {\n            const serverState = await response.json();\n            \n            // Check if server is truly stopped\n            const serverIsActive = Boolean(serverState.isRunning || serverState.isActive);\n            \n            if (serverIsActive) {\n                // Server still shows running - this is expected due to race condition timing\n                console.warn('⚠️ Timing issue detected: server may still be shutting down');\n                // Don't throw error - force stop will handle this automatically if needed\n                console.log('ℹ️ This is normal - the stop operation may still be completing');\n            } else {\n                console.log('✅ Stop completion verified - server shows stopped state');\n            }\n        } else {\n            // If status endpoint fails, assume stop worked (for backward compatibility)\n            console.log('ℹ️ Could not verify stop completion (status endpoint unavailable)');\n        }\n    } catch (error) {\n        if (error.name === 'AbortError') {\n            console.warn('⚠️ Stop verification timed out - this is normal during shutdown');\n            // Don't throw error - this is expected during stop operations\n        } else if (error.message.includes('Failed to fetch')) {\n            // Network error - can't verify, but don't fail the stop operation\n            console.log('ℹ️ Cannot verify stop completion due to network error');\n        } else {\n            // Log other errors but don't throw - let stop operation complete\n            console.warn('ℹ️ Stop verification error (non-critical):', error.message);\n        }\n    }\n}\n\n// Restore UI state based on server response\nfunction restoreUIStateFromServer(serverState) {\n    let stateChanged = false;\n    \n    // CYCLING EXCEPTION: Skip restoration if actively cycling to prevent interference\n    if (activeCyclingOperation && isCycling) {\n        trackOperation('State restoration skipped - active cycling in progress', {\n            source: 'cycling_protection',\n            serverIsActive: Boolean(serverState.isRunning || serverState.isActive)\n        });\n        return false; // No state change during active cycling\n    }\n    \n    // Set restoration mode flag to prevent event handlers from triggering operations\n    isRestoringState = true;\n    \n    // Server returns 'isRunning', not 'isActive' - fix the key mismatch\n    const serverIsActive = Boolean(serverState.isRunning || serverState.isActive);\n    \n    // Check if server is running but UI thinks it's not (split brain state)\n    if (serverIsActive && !isScanning) {\n        isScanning = true;\n        stateChanged = true;\n        \n        // Show clear user feedback about state sync\n        showStatus('🔄 Server is running a sweep - UI synchronized', 'warning');\n        \n        // Update connection status since we found server is active\n        connectionStatus = 'connected';\n        \n    }\n    \n    // Check if server is not running but UI thinks it is\n    if (!serverIsActive && isScanning) {\n        isScanning = false;\n        isCycling = false;\n        stateChanged = true;\n        \n        // Show user feedback about state reset\n        showStatus('🔄 Server not running - UI state reset', 'info');\n        \n        // Update connection status\n        connectionStatus = 'disconnected';\n        \n    }\n    \n    // Enhanced button state management for split-brain recovery\n    if (stateChanged) {\n        // Force update button states to reflect corrected server state\n        updateButtonStates();\n    }\n    \n    // Update cycling state and frequency information only if server is active\n    if (serverIsActive) {\n        // Handle frequency information if available\n        if (Array.isArray(serverState.frequencies) && serverState.frequencies.length > 0) {\n            // Restore frequency inputs to match server state\n            const frequencyList = document.getElementById('frequencyList');\n            if (frequencyList) {\n                // Clear existing frequency inputs\n                frequencyList.innerHTML = '';\n                \n                // Recreate frequency inputs based on server state (direct HTML manipulation during restoration)\n                serverState.frequencies.forEach((freq, index) => {\n                    const newIndex = index + 1;\n                    const newItem = document.createElement('div');\n                    newItem.className = 'frequency-item saasfly-interactive-card flex items-center gap-3 p-4 bg-gradient-to-r from-bg-card/40 to-bg-card/20 rounded-xl border border-border-primary/40 hover:border-neon-cyan/40 hover:bg-gradient-to-r hover:from-bg-card/60 hover:to-bg-card/40 hover:shadow-md transition-all duration-300';\n                    newItem.id = `frequencyItem${newIndex}`;\n                    \n                    newItem.innerHTML = `\n                        <span class=\"font-mono text-sm text-text-muted font-semibold min-w-[24px] text-center bg-neon-cyan/10 rounded-lg px-2 py-1\">${newIndex}</span>\n                        <div class=\"flex-1 relative\">\n                            <input type=\"text\" id=\"frequencyInput${newIndex}\" placeholder=\"Target\" value=\"${freq.value || ''}\" class=\"font-mono w-full pl-3 pr-12 py-2 bg-bg-input/80 border border-border-primary/60 rounded-lg text-text-primary outline-none focus:border-neon-cyan focus:bg-bg-input focus:shadow-neon-cyan-sm transition-all duration-300 placeholder:text-text-muted/50\">\n                            <span class=\"absolute right-3 top-1/2 -translate-y-1/2 font-mono text-sm text-text-secondary font-medium pointer-events-none\">MHz</span>\n                        </div>\n                        ${newIndex > 1 ? `<button type=\"button\" onclick=\"removeFrequencyInput('frequencyItem${newIndex}')\" style=\"padding: 6px 12px !important; background-color: #ef4444 !important; color: white !important; border: none !important; border-radius: 6px !important; font-size: 14px !important; font-weight: 500 !important; cursor: pointer !important; box-shadow: none !important; text-shadow: none !important; outline: none !important; transition: box-shadow 0.3s ease !important;\" onmouseover=\"this.style.boxShadow='0 0 10px rgba(255, 255, 255, 0.4)'\" onmouseout=\"this.style.boxShadow='none'\">Remove</button>` : ''}\n                    `;\n                    \n                    frequencyList.appendChild(newItem);\n                });\n                \n                // Update button states\n                updateAddButtonState();\n                \n            }\n            \n            const wasCycling = isCycling;\n            isCycling = serverState.frequencies.length > 1;\n            \n            if (wasCycling !== isCycling) {\n                stateChanged = true;\n            }\n            \n            // Update current frequency index if provided\n            if (typeof serverState.currentIndex === 'number' && \n                serverState.currentIndex >= 0 && \n                serverState.currentIndex < serverState.frequencies.length) {\n                const oldIndex = currentFrequencyIndex;\n                currentFrequencyIndex = serverState.currentIndex;\n                \n                if (oldIndex !== currentFrequencyIndex) {\n                    stateChanged = true;\n                    updateFrequencyHighlight(currentFrequencyIndex);\n                }\n            }\n            \n            // Update current frequency display - handle both frequency formats\n            if (serverState.currentFrequency) {\n                const freqValue = serverState.currentFrequency.value || serverState.currentFrequency.frequency;\n                const freqUnit = serverState.currentFrequency.unit || 'MHz';\n                if (freqValue && freqUnit) {\n                    updateCurrentFrequencyDisplay({ value: freqValue, unit: freqUnit });\n                }\n            }\n            \n            // Show cycle status if cycling\n            if (isCycling) {\n                showCycleStatus(true);\n                \n                // Start cycle display if we have timing information\n                if (typeof serverState.cycleTime === 'number' && serverState.cycleTime > 0) {\n                    globalCycleTime = serverState.cycleTime;  // Store cycle time globally\n                    startCycleDisplay(serverState.frequencies, serverState.cycleTime);\n                }\n            } else {\n                showCycleStatus(false);\n            }\n            \n        } else if (serverState.currentFrequency) {\n            // Single frequency operation - handle both frequency formats\n            isCycling = false;\n            showCycleStatus(false);\n            \n            const freqValue = serverState.currentFrequency.value || serverState.currentFrequency.frequency;\n            const freqUnit = serverState.currentFrequency.unit || 'MHz';\n            if (freqValue && freqUnit) {\n                updateCurrentFrequencyDisplay({ value: freqValue, unit: freqUnit });\n            }\n            \n        }\n    }\n    \n    // Update button states and UI elements if state changed\n    if (stateChanged) {\n        updateButtonStates();\n        \n        // Clear any previous highlights if not scanning\n        if (!isScanning) {\n            clearFrequencyHighlights();\n            clearCycleDisplay();\n            resetDisplay();\n        }\n        \n        // If server is running but UI wasn't aware, connect to SSE stream\n        if (serverIsActive && !sseConnectionActive) {\n            connectSSE();\n        }\n        \n    }\n    \n    // Clear restoration mode flag and restore event listeners\n    isRestoringState = false;\n    \n    // Add event listeners to all frequency inputs after restoration is complete\n    addEventListenersToFrequencyInputs();\n    \n    return stateChanged;\n}\n\n// Update display with new data - SIGNAL DATA PROCESSING ONLY\n// This function handles signal strength data display and frequency accuracy\n// Cycle frequency display updates are handled by handleStatusChange() for clean separation\nfunction updateDisplay(data) {\n    if (!data || typeof data.db === 'undefined') {\n        return;\n    }\n    \n    // Skip signal indicator updates during reset to maintain synchronization\n    if (signalResetInProgress) {\n        return;\n    }\n    \n    const db = data.db;\n    const frequency = data.frequency;\n    const unit = data.unit || 'MHz';\n    \n    // Update dB level display\n    document.getElementById('dbLevelValue').textContent = db.toFixed(1);\n    \n    // Update signal strength text and class\n    const { strength, className } = getSignalStrength(db);\n    const signalStrengthElement = document.getElementById('signalStrengthText');\n    signalStrengthElement.textContent = strength;\n    signalStrengthElement.className = `value ${className}`;\n    \n    // Update signal indicator bar\n    const percentage = Math.max(0, Math.min(100, (db + 100) * 1.25)); // Map -100 to 0, -20 to 100\n    const fillElement = document.getElementById('signalIndicatorFill');\n    fillElement.style.width = percentage + '%';\n    \n    // Apply gradient class based on signal strength\n    // Remove any existing gradient classes\n    fillElement.classList.remove('gradient-weak', 'gradient-moderate', 'gradient-strong', 'gradient-very-strong');\n    \n    if (db >= -50) {\n        fillElement.classList.add('gradient-very-strong');\n    } else if (db >= -60) {\n        fillElement.classList.add('gradient-strong');\n    } else if (db >= -70) {\n        fillElement.classList.add('gradient-moderate');\n    } else if (db >= -90) {\n        fillElement.classList.add('gradient-weak');\n    }\n    \n    // Update current dB indicator position\n    const indicatorPosition = Math.max(0, Math.min(100, (db + 100) * 1.25));\n    const dbIndicator = document.getElementById('dbCurrentIndicator');\n    dbIndicator.style.left = indicatorPosition + '%';\n    \n    // Update current dB value\n    document.getElementById('dbCurrentValue').textContent = db.toFixed(1) + ' dB';\n    \n    // Enhanced frequency accuracy display\n    if (data.targetFrequency && data.frequencyAccuracy) {\n        // Update target frequency\n        const targetFreqText = `${data.targetFrequency.value.toFixed(3)} ${data.targetFrequency.unit}`;\n        document.getElementById('targetFrequency').textContent = targetFreqText;\n        \n        // Update detected frequency with precision\n        const detectedFreqText = `${frequency.toFixed(3)} ${unit}`;\n        document.getElementById('detectedFrequency').textContent = detectedFreqText;\n        \n        // Update frequency offset with color coding\n        const offsetMHz = data.frequencyAccuracy.offsetFromTargetMHz;\n        const offsetElement = document.getElementById('frequencyOffset');\n        const offsetText = offsetMHz >= 0 ? `+${offsetMHz.toFixed(3)}` : `${offsetMHz.toFixed(3)}`;\n        offsetElement.textContent = `${offsetText} MHz`;\n        \n        // Color code the offset based on accuracy\n        offsetElement.className = 'value';\n        if (Math.abs(offsetMHz) <= 0.05) {\n            offsetElement.classList.add('accurate'); // Green for very accurate (within 50kHz)\n        } else if (Math.abs(offsetMHz) <= 0.1) {\n            offsetElement.classList.add('moderate'); // Yellow for moderate (within 100kHz)\n        } else {\n            offsetElement.classList.add('inaccurate'); // Red for inaccurate (over 100kHz)\n        }\n        \n    } else {\n        // Fallback for backward compatibility\n        document.getElementById('targetFrequency').textContent = '--';\n        document.getElementById('detectedFrequency').textContent = frequency ? `${frequency.toFixed(3)} ${unit}` : '--';\n        document.getElementById('frequencyOffset').textContent = '--';\n        \n    }\n    \n    // Note: Frequency display updates for cycling are handled by status_change events\n    // This ensures clean separation between signal data processing and cycle state management\n}\n\n// Get signal strength classification\nfunction getSignalStrength(db) {\n    if (db < -90) {\n        return { strength: 'No Signal', className: 'signal-no-signal' };\n    } else if (db < -80) {\n        return { strength: 'Very Weak', className: 'signal-very-weak' };\n    } else if (db < -70) {\n        return { strength: 'Weak', className: 'signal-weak' };\n    } else if (db < -60) {\n        return { strength: 'Moderate', className: 'signal-moderate' };\n    } else if (db < -50) {\n        return { strength: 'Strong', className: 'signal-strong' };\n    } else {\n        return { strength: 'Very Strong', className: 'signal-very-strong' };\n    }\n}\n\n// Reset display to default state\nfunction resetDisplay() {\n    // Coordinate reset to prevent conflicts with timer synchronization\n    signalResetInProgress = true;\n    \n    document.getElementById('dbLevelValue').textContent = '--';\n    const signalElement = document.getElementById('signalStrengthText');\n    signalElement.textContent = 'No Signal';\n    signalElement.className = 'value signal-no-signal';\n    const signalFill = document.getElementById('signalIndicatorFill');\n    signalFill.style.width = '0%';\n    signalFill.classList.remove('gradient-weak', 'gradient-moderate', 'gradient-strong', 'gradient-very-strong');\n    document.getElementById('dbCurrentIndicator').style.left = '0%';\n    document.getElementById('dbCurrentValue').textContent = '-90 dB';\n    \n    // Allow signal updates after brief delay\n    setTimeout(() => {\n        signalResetInProgress = false;\n    }, 50); // Shorter delay since this is a one-time reset\n    \n    // Reset frequency accuracy display\n    document.getElementById('targetFrequency').textContent = '--';\n    document.getElementById('detectedFrequency').textContent = '--';\n    const offsetElement = document.getElementById('frequencyOffset');\n    offsetElement.textContent = '--';\n    offsetElement.className = 'value'; // Reset color coding\n}\n\n// Update button states - Enhanced with server state awareness\nfunction updateButtonStates() {\n    const startButton = document.getElementById('startButton');\n    const stopButton = document.getElementById('stopButton');\n    \n    // Primary button logic based on frontend state\n    startButton.disabled = isScanning;\n    stopButton.disabled = !isScanning;\n    \n    // Update button text to reflect current state\n    if (isScanning) {\n        startButton.textContent = 'Sweep Running';\n        stopButton.textContent = 'Stop Sweep';\n    } else {\n        startButton.textContent = 'Start Cycling';\n        stopButton.textContent = 'Stop';\n    }\n    \n    // Enable/disable cycling state on container\n    const container = document.querySelector('.container');\n    if (container) {\n        if (isScanning) {\n            container.classList.add('cycling-disabled');\n        } else {\n            container.classList.remove('cycling-disabled');\n        }\n    }\n    \n    // Update add button\n    updateAddButtonState();\n    \n    // Disable cycle time input during scanning\n    const cycleTimeInput = document.getElementById('cycleTimeInput');\n    if (cycleTimeInput) {\n        cycleTimeInput.disabled = isScanning;\n    }\n}\n\n// Update button states based on actual server state (for split-brain recovery)\nfunction updateButtonStatesFromServerState(serverIsActive) {\n    const startButton = document.getElementById('startButton');\n    const stopButton = document.getElementById('stopButton');\n    \n    if (serverIsActive) {\n        // Server is running - ensure stop button is enabled, start button disabled\n        startButton.disabled = true;\n        startButton.textContent = 'Sweep Running';\n        stopButton.disabled = false;\n        stopButton.textContent = 'Stop Sweep';\n        stopButton.style.background = '#ef4444';\n        stopButton.style.borderColor = '#dc2626';\n        stopButton.style.color = 'white';\n        stopButton.style.cursor = 'pointer';\n        \n        showStatus('🔄 Buttons updated to reflect server state: RUNNING', 'info');\n    } else {\n        // Server is not running - ensure start button is enabled, stop button disabled\n        startButton.disabled = false;\n        startButton.textContent = 'Start Cycling';\n        stopButton.disabled = true;\n        stopButton.textContent = 'Stop';\n        stopButton.style.background = '';\n        stopButton.style.borderColor = '';\n        stopButton.style.color = '';\n        stopButton.style.cursor = '';\n        \n        showStatus('🔄 Buttons updated to reflect server state: STOPPED', 'info');\n    }\n    \n    // Update container cycling state\n    const container = document.querySelector('.container');\n    if (container) {\n        if (serverIsActive) {\n            container.classList.add('cycling-disabled');\n        } else {\n            container.classList.remove('cycling-disabled');\n        }\n    }\n    \n    // Update other UI elements\n    updateAddButtonState();\n    const cycleTimeInput = document.getElementById('cycleTimeInput');\n    if (cycleTimeInput) {\n        cycleTimeInput.disabled = serverIsActive;\n    }\n}\n\n// Verify button states match reality (final safety check for split-brain scenarios)\nfunction verifyButtonStatesMatchReality(serverIsActive) {\n    const startButton = document.getElementById('startButton');\n    const stopButton = document.getElementById('stopButton');\n    \n    let buttonStateIssues = [];\n    \n    // Check for button state mismatches\n    if (serverIsActive) {\n        // Server is running - start should be disabled, stop should be enabled\n        if (!startButton.disabled) {\n            buttonStateIssues.push('Start button should be disabled (server running)');\n            startButton.disabled = true;\n            startButton.textContent = 'Sweep Running';\n        }\n        if (stopButton.disabled) {\n            buttonStateIssues.push('Stop button should be enabled (server running)');\n            stopButton.disabled = false;\n            stopButton.textContent = 'Stop Sweep';\n            stopButton.style.background = '#ef4444';\n            stopButton.style.borderColor = '#dc2626';\n            stopButton.style.color = 'white';\n            stopButton.style.cursor = 'pointer';\n        }\n    } else {\n        // Server is not running - start should be enabled, stop should be disabled\n        if (startButton.disabled && !isScanning) {\n            buttonStateIssues.push('Start button should be enabled (server stopped)');\n            startButton.disabled = false;\n            startButton.textContent = 'Start Cycling';\n        }\n        if (!stopButton.disabled && !isScanning) {\n            buttonStateIssues.push('Stop button should be disabled (server stopped)');\n            stopButton.disabled = true;\n            stopButton.textContent = 'Stop';\n            stopButton.style.background = '';\n            stopButton.style.borderColor = '';\n            stopButton.style.color = '';\n            stopButton.style.cursor = '';\n        }\n    }\n    \n    \n    // Log any fixes made\n    if (buttonStateIssues.length > 0) {\n        console.warn('🔧 Button state issues fixed:', buttonStateIssues);\n        showStatus(`🔧 Fixed ${buttonStateIssues.length} button state issue(s)`, 'info');\n    }\n}\n\n// Handle status change events - SINGLE SOURCE OF TRUTH for cycle frequency display\n// This function manages cycle state changes and frequency display updates\n// Signal data processing (updateDisplay) is kept separate from cycle state management\nfunction handleStatusChange(data) {\n    if (data.status === 'switching') {\n        // Mark active cycling operation to bypass certain guard flags\n        activeCyclingOperation = true;\n        reducedSyncMode = true;\n        \n        // DO NOT update currentFrequencyIndex during switching - only during 'active' status\n        \n        // Handle both frequency formats during transition\n        const nextFreq = data.nextFrequency;\n        if (nextFreq) {\n            const freqValue = nextFreq.value || nextFreq.frequency;\n            const freqUnit = nextFreq.unit || 'MHz';\n            showStatus(`Switching to ${freqValue} ${freqUnit}...`, 'info');\n            updateCurrentFrequencyDisplay({ value: freqValue, unit: freqUnit });\n            \n            trackOperation('Frequency switch in progress', {\n                source: 'cycling_operation',\n                fromIndex: currentFrequencyIndex,\n                toFrequency: `${freqValue} ${freqUnit}`,\n                cyclingActive: true\n            });\n        }\n        updateFrequencyHighlight(currentFrequencyIndex);\n        \n    } else if (data.status === 'active') {\n        currentFrequencyIndex = data.currentIndex || 0;\n        updateFrequencyHighlight(currentFrequencyIndex);\n        \n        // Handle both frequency formats during transition\n        if (data.currentFrequency) {\n            // Since the label says \"Next Frequency\", show the next frequency in cycle\n            updateNextFrequencyDisplay(null, currentFrequencyIndex);\n        }\n        \n        // CRITICAL FIX: Restart timer when frequency becomes active during cycling\n        // This ensures timer stays synchronized with actual frequency switches\n        if (isCycling) {\n            // Maintain cycling operation flags during active cycling\n            activeCyclingOperation = true;\n            reducedSyncMode = true;\n            \n            // Use provided cycleTime or fall back to global cycle time\n            const cycleTime = data.cycleTime || globalCycleTime;\n            startTimer(cycleTime);\n            \n            trackOperation('Timer restarted for active frequency', {\n                source: 'cycling_timer_sync',\n                currentIndex: currentFrequencyIndex,\n                cycleTime,\n                cyclingFlags: { activeCyclingOperation, reducedSyncMode }\n            });\n        }\n    }\n}\n\n// Handle cycle configuration\nfunction handleCycleConfig(data) {\n    if (data.frequencies && data.cycleTime) {\n        isCycling = data.frequencies.length > 1;\n        globalCycleTime = data.cycleTime;  // Store cycle time globally\n        \n        if (isCycling) {\n            // Activate cycling mode flags for guard bypass\n            activeCyclingOperation = true;\n            reducedSyncMode = true;\n            \n            showStatus(`Cycling ${data.frequencies.length} frequencies every ${data.cycleTime / 1000}s`, 'info');\n            startCycleDisplay(data.frequencies, data.cycleTime);\n            \n            trackOperation('Cycle configuration activated', {\n                source: 'cycle_config',\n                frequencyCount: data.frequencies.length,\n                cycleTime: data.cycleTime,\n                cyclingFlags: { activeCyclingOperation, reducedSyncMode }\n            });\n        } else {\n            // Single frequency mode - disable cycling flags\n            activeCyclingOperation = false;\n            reducedSyncMode = false;\n        }\n    }\n}\n\n// Cycling-aware state management functions\nfunction setCyclingPriority(enabled, reason = 'unknown') {\n    const wasEnabled = activeCyclingOperation;\n    activeCyclingOperation = enabled;\n    reducedSyncMode = enabled;\n    \n    if (wasEnabled !== enabled) {\n        trackOperation(`Cycling priority ${enabled ? 'enabled' : 'disabled'}`, {\n            source: 'cycling_priority',\n            reason,\n            previousState: wasEnabled,\n            newState: enabled\n        });\n    }\n}\n\nfunction isCyclingActive() {\n    return activeCyclingOperation && isCycling;\n}\n\nfunction shouldBypassSyncGuards(operationType = 'unknown') {\n    const bypass = activeCyclingOperation || (operationType === 'cycling');\n    if (bypass) {\n        trackOperation('Sync guard bypass activated', {\n            source: 'guard_bypass',\n            operationType,\n            activeCycling: activeCyclingOperation,\n            reason: activeCyclingOperation ? 'active_cycling' : 'cycling_operation'\n        });\n    }\n    return bypass;\n}\n\n// Update frequency highlight\nfunction updateFrequencyHighlight(index) {\n    clearFrequencyHighlights();\n    \n    const frequencyItems = document.querySelectorAll('.frequency-item');\n    if (frequencyItems[index]) {\n        // Don't add any class that changes appearance\n        // Just track internally which one is active\n        frequencyItems[index].setAttribute('data-current', 'true');\n    }\n}\n\n// Clear all frequency highlights\nfunction clearFrequencyHighlights() {\n    document.querySelectorAll('.frequency-item[data-current=\"true\"]').forEach(elem => {\n        elem.removeAttribute('data-current');\n    });\n}\n\n// Show status message with enhanced formatting\nfunction showStatus(message, type = 'info', showSpinner = false) {\n    const statusElement = document.getElementById('statusMessage');\n    const timestamp = new Date().toLocaleTimeString();\n    \n    // Create message with timestamp\n    let displayMessage = `[${timestamp}] ${message}`;\n    \n    // Add spinner if requested\n    if (showSpinner) {\n        displayMessage += ' <span class=\"loading\"></span>';\n        statusElement.innerHTML = displayMessage;\n    } else {\n        statusElement.textContent = displayMessage;\n    }\n    \n    // Reset classes and apply new ones\n    statusElement.className = 'status-message';\n    \n    // Apply type-specific styling\n    switch (type) {\n        case 'error':\n            statusElement.classList.add('error');\n            break;\n        case 'warning':\n            statusElement.classList.add('warning');\n            break;\n        case 'success':\n            statusElement.classList.add('success');\n            break;\n        case 'info':\n        default:\n            statusElement.classList.add('info');\n            break;\n    }\n    \n    // Clear status after timeout for non-error messages\n    if (type !== 'error') {\n        const timeout = type === 'success' ? 3000 : 5000;\n        setTimeout(() => {\n            if (!statusElement.classList.contains('error')) {\n                statusElement.textContent = '';\n                statusElement.className = 'status-message';\n            }\n        }, timeout);\n    }\n}\n\n// Set loading state for buttons and inputs\nfunction setLoadingState(loading) {\n    const startButton = document.getElementById('startButton');\n    const stopButton = document.getElementById('stopButton');\n    const addButton = document.getElementById('addFrequencyButton');\n    const cycleTimeInput = document.getElementById('cycleTimeInput');\n    const frequencyInputs = document.querySelectorAll('.frequency-item input, .frequency-item select');\n    \n    if (loading) {\n        startButton.disabled = true;\n        startButton.textContent = 'Starting...';\n        \n        // Disable all inputs during loading\n        if (addButton) addButton.disabled = true;\n        if (cycleTimeInput) cycleTimeInput.disabled = true;\n        frequencyInputs.forEach(input => input.disabled = true);\n    } else {\n        startButton.textContent = 'Start Cycling';\n        \n        // Re-enable inputs based on current state\n        if (addButton) addButton.disabled = isScanning;\n        if (cycleTimeInput) cycleTimeInput.disabled = isScanning;\n        frequencyInputs.forEach(input => input.disabled = isScanning);\n    }\n}\n\n// Update connection status indicator\nfunction updateConnectionStatus() {\n    // Connection status indicator removed\n}\n\n// Basic error message extraction\nfunction getErrorMessage(error) {\n    if (typeof error === 'string') return error;\n    return error.message || error.toString() || 'Unknown error occurred';\n}\n\n\n// Enhanced error display system with recovery suggestions\nfunction showEnhancedError(error, context = '', options = {}) {\n    const errorMessage = getErrorMessage(error);\n    showStatus(errorMessage, 'error');\n    \n    // Enhanced error tracking\n    trackOperation(`Error displayed: ${errorMessage}`, {\n        source: 'error_display',\n        context,\n        recovery: options.recovery || 'No recovery suggestion available',\n        errorType: typeof error === 'object' ? error.name : 'string_error'\n    });\n    \n    // Show Copy Error Details button and recovery suggestions after error\n    setTimeout(() => {\n        createEnhancedErrorPanel(error, context, options);\n    }, 500);\n}\n\n// Create enhanced error panel with recovery suggestions\nfunction createEnhancedErrorPanel(error, context = '', options = {}) {\n    // Remove existing error panel if present\n    const existingPanel = document.getElementById('errorPanel');\n    if (existingPanel) {\n        existingPanel.remove();\n    }\n    \n    const panel = document.createElement('div');\n    panel.id = 'errorPanel';\n    panel.className = 'error-panel';\n    \n    // Determine if this is a retryable cycling error\n    const isRetryable = options.context?.retryable || \n                       (context === 'cycling_error' && options.context?.errorType !== 'failure_loop_prevention') ||\n                       (context === 'frequency_error' && !options.context?.blacklisted);\n    \n    const isCyclingError = context === 'cycling_error' || context === 'frequency_error';\n    \n    panel.innerHTML = `\n        <div class=\"error-panel-content\">\n            ${options.recovery ? `\n                <div class=\"recovery-suggestion\">\n                    <strong>💡 Recovery Suggestion:</strong>\n                    <p>${options.recovery}</p>\n                </div>\n            ` : ''}\n            ${isCyclingError ? `\n                <div class=\"cycling-error-details\">\n                    ${options.context?.frequency ? `<p><strong>Frequency:</strong> ${options.context.frequency} MHz</p>` : ''}\n                    ${options.context?.retryCount ? `<p><strong>Retry Count:</strong> ${options.context.retryCount}/${options.context.maxRetries || 'unlimited'}</p>` : ''}\n                    ${options.context?.errorType ? `<p><strong>Error Type:</strong> ${options.context.errorType}</p>` : ''}\n                </div>\n            ` : ''}\n            <div class=\"error-actions\">\n                <button id=\"copyErrorButton\" class=\"copy-error-btn\">📋 Copy Error Details</button>\n                ${options.context && options.context.attemptId ? `\n                    <button id=\"viewCallStackButton\" class=\"view-stack-btn\">🔍 View Call Stack</button>\n                ` : ''}\n                ${isRetryable ? `\n                    <button id=\"retryOperationButton\" class=\"retry-btn\">🔄 Retry Operation</button>\n                ` : ''}\n                ${isCyclingError && !isScanning ? `\n                    <button id=\"restartSweepButton\" class=\"restart-btn\">🚀 Restart Sweep</button>\n                ` : ''}\n                <button id=\"dismissErrorButton\" class=\"dismiss-error-btn\">✕ Dismiss</button>\n            </div>\n        </div>\n    `;\n    \n    // Insert after the status message\n    const statusMessage = document.getElementById('statusMessage');\n    statusMessage.parentNode.insertBefore(panel, statusMessage.nextSibling);\n    \n    // Add event listeners\n    document.getElementById('copyErrorButton').onclick = () => copyErrorDetails(error, context, options);\n    document.getElementById('dismissErrorButton').onclick = () => panel.remove();\n    \n    if (options.context && options.context.attemptId) {\n        document.getElementById('viewCallStackButton').onclick = () => showCallStackModal(options.context);\n    }\n    \n    // Add retry button listeners for cycling errors\n    const retryButton = document.getElementById('retryOperationButton');\n    if (retryButton) {\n        retryButton.onclick = () => {\n            panel.remove();\n            handleRetryOperation(context, options.context);\n        };\n    }\n    \n    const restartButton = document.getElementById('restartSweepButton');\n    if (restartButton) {\n        restartButton.onclick = () => {\n            panel.remove();\n            handleRestartSweep(options.context);\n        };\n    }\n    \n    // Auto-hide after 60 seconds\n    setTimeout(() => {\n        if (panel.parentNode) {\n            panel.remove();\n        }\n    }, 60000);\n}\n\n// Create simple Copy Error Details button\nfunction createCopyErrorButton(error, context = '') {\n    // Remove existing button if present\n    const existingButton = document.getElementById('copyErrorButton');\n    if (existingButton) {\n        existingButton.remove();\n    }\n    \n    const button = document.createElement('button');\n    button.id = 'copyErrorButton';\n    button.className = 'copy-error-btn';\n    button.textContent = '📋 Copy Error Details';\n    button.onclick = () => copyErrorDetails(error, context);\n    \n    // Insert after the status message\n    const statusMessage = document.getElementById('statusMessage');\n    statusMessage.parentNode.insertBefore(button, statusMessage.nextSibling);\n    \n    // Auto-hide after 30 seconds\n    setTimeout(() => {\n        if (button.parentNode) {\n            button.remove();\n        }\n    }, 30000);\n}\n\n// Enhanced error details copy with comprehensive context\nfunction copyErrorDetails(error, context = '', options = {}) {\n    const errorInfo = {\n        timestamp: new Date().toISOString(),\n        context: context,\n        error: typeof error === 'string' ? error : error.message || error.toString(),\n        errorStack: typeof error === 'object' ? error.stack : 'N/A',\n        userAgent: navigator.userAgent,\n        url: window.location.href,\n        applicationState: {\n            isScanning,\n            isCycling,\n            connectionStatus,\n            sseConnectionActive,\n            currentFrequencyIndex\n        },\n        recentOperations: window.recentOperations?.slice(0, 10) || [],\n        startSweepAttempts: window.startSweepTracker?.attempts?.slice(-3) || [],\n        lastSyncTime: window.lastStateSyncTime || 'Never',\n        recovery: options.recovery || 'No recovery suggestion provided'\n    };\n    \n    // Add attempt context if available\n    if (options.context && options.context.attemptId) {\n        errorInfo.attemptContext = {\n            attemptId: options.context.attemptId,\n            type: options.context.type,\n            source: options.context.source,\n            callStack: options.context.callStack || []\n        };\n    }\n    \n    const errorText = `HackRF Monitor Enhanced Error Report\n========================================\nTimestamp: ${errorInfo.timestamp}\nContext: ${errorInfo.context}\nError: ${errorInfo.error}\nRecovery Suggestion: ${errorInfo.recovery}\n\nApplication State:\n- Scanning: ${errorInfo.applicationState.isScanning}\n- Cycling: ${errorInfo.applicationState.isCycling}\n- Connection: ${errorInfo.applicationState.connectionStatus}\n- SSE Active: ${errorInfo.applicationState.sseConnectionActive}\n- Current Frequency Index: ${errorInfo.applicationState.currentFrequencyIndex}\n- Last Sync: ${errorInfo.lastSyncTime}\n\nRecent Operations (last 10):\n${errorInfo.recentOperations.map((op, i) => `${i + 1}. ${op}`).join('\\n')}\n\nStart Sweep Attempts (last 3):\n${errorInfo.startSweepAttempts.map((attempt, i) => `${i + 1}. [${attempt.timestamp}] ${attempt.type} (${attempt.source})`).join('\\n')}\n\n${errorInfo.attemptContext ? `\nAttempt Context:\n- ID: ${errorInfo.attemptContext.attemptId}\n- Type: ${errorInfo.attemptContext.type}\n- Source: ${errorInfo.attemptContext.source}\n- Call Stack: ${errorInfo.attemptContext.callStack.slice(0, 5).join(' → ')}\n` : ''}\n\nError Stack:\n${errorInfo.errorStack}\n\nBrowser: ${errorInfo.userAgent}\nURL: ${errorInfo.url}`;\n    \n    // Create enhanced modal with the error text\n    const modal = document.createElement('div');\n    modal.style.cssText = `\n        position: fixed;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        background: rgba(0,0,0,0.8);\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        z-index: 10000;\n    `;\n    \n    modal.innerHTML = `\n        <div style=\"background: #1a1a1a; padding: 20px; border-radius: 8px; width: 90%; max-width: 800px; max-height: 80vh; overflow: auto;\">\n            <h3 style=\"color: #fff; margin-top: 0;\">Enhanced Error Details - Press Ctrl+C to copy</h3>\n            <textarea readonly style=\"width: 100%; height: 400px; background: #2a2a2a; color: #fff; border: 1px solid #444; padding: 10px; font-family: monospace; font-size: 12px;\">${errorText}</textarea>\n            <div style=\"margin-top: 10px;\">\n                <button onclick=\"this.closest('div').parentElement.remove()\" style=\"padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;\">Close</button>\n                <button onclick=\"navigator.clipboard.writeText(this.parentElement.previousElementSibling.value).then(() => alert('Copied to clipboard!'))\" style=\"padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;\">Copy to Clipboard</button>\n            </div>\n        </div>\n    `;\n    \n    document.body.appendChild(modal);\n    \n    // Auto-select the text\n    const textarea = modal.querySelector('textarea');\n    textarea.focus();\n    textarea.select();\n}\n\n// Show call stack modal for debugging\nfunction showCallStackModal(attemptContext) {\n    const modal = document.createElement('div');\n    modal.style.cssText = `\n        position: fixed;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        background: rgba(0,0,0,0.8);\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        z-index: 10000;\n    `;\n    \n    const callStackText = attemptContext.callStack ? \n        attemptContext.callStack.map((frame, i) => `${i + 1}. ${frame}`).join('\\n') :\n        'Call stack not available';\n    \n    modal.innerHTML = `\n        <div style=\"background: #1a1a1a; padding: 20px; border-radius: 8px; width: 80%; max-width: 600px;\">\n            <h3 style=\"color: #fff; margin-top: 0;\">Call Stack for Attempt: ${attemptContext.attemptId}</h3>\n            <div style=\"background: #2a2a2a; color: #fff; padding: 10px; border-radius: 4px; margin: 10px 0;\">\n                <strong>Type:</strong> ${attemptContext.type}<br>\n                <strong>Source:</strong> ${attemptContext.source}<br>\n                <strong>Timestamp:</strong> ${attemptContext.timestamp}\n            </div>\n            <textarea readonly style=\"width: 100%; height: 200px; background: #2a2a2a; color: #fff; border: 1px solid #444; padding: 10px; font-family: monospace;\">${callStackText}</textarea>\n            <button onclick=\"this.closest('div').parentElement.remove()\" style=\"margin-top: 10px; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;\">Close</button>\n        </div>\n    `;\n    \n    document.body.appendChild(modal);\n}\n\n\n\n\n\n\n\n\n\n\n\n// Clear error states - removed\nfunction clearErrorStates() {\n    // Clear error states removed\n}\n\n// Perform initial health check\nasync function performHealthCheck() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`, {\n            method: 'GET',\n            timeout: 5000\n        });\n        \n        if (response.ok) {\n            const data = await response.json();\n            connectionStatus = 'connected';\n            updateConnectionStatus();\n            \n        } else {\n            connectionStatus = 'error';\n            updateConnectionStatus();\n            showStatus('Server health check failed', 'warning');\n        }\n    } catch (error) {\n        connectionStatus = 'disconnected';\n        updateConnectionStatus();\n        \n    }\n}\n\n// Add debug panel for troubleshooting - removed\nfunction addDebugPanel() {\n    // Debug panel removed\n}\n\n// Update debug information - removed\nfunction updateDebugInfo() {\n    // Debug info update removed\n}\n\n// Copy debug information to clipboard - removed\nfunction copyDebugInfo() {\n    // Debug info copy removed\n}\n\n// Test connection manually - removed\nasync function testConnection() {\n    // Connection test removed\n}\n\n// Get error history (simplified implementation)\nfunction getErrorHistory() {\n    // In a real implementation, you might store error history\n    return ['Error history not implemented yet'];\n}\n\n// Cycling-specific error handling functions\nfunction handleCyclingError(data) {\n    const errorMessage = data.message || 'Cycling operation failed';\n    const errorType = data.errorType || 'general_cycling_error';\n    \n    trackOperation(`Cycling error: ${errorMessage}`, { \n        source: 'cycling_error',\n        errorType: errorType,\n        frequency: data.frequency,\n        severity: data.severity\n    });\n\n    // Create enhanced error display with cycling-specific recovery\n    const recoveryActions = getCyclingRecoveryActions(errorType, data);\n    \n    showEnhancedError(errorMessage, 'cycling_error', {\n        recovery: recoveryActions.message,\n        context: { \n            errorType: errorType,\n            frequency: data.frequency,\n            severity: data.severity,\n            retryable: recoveryActions.retryable\n        }\n    });\n\n    // Add cycling error indicator to UI\n    updateCyclingErrorIndicator(data);\n}\n\nfunction handleFrequencyError(data) {\n    const frequency = data.frequency || 'unknown';\n    const errorMessage = data.message || `Frequency ${frequency} failed`;\n    \n    trackOperation(`Frequency error: ${errorMessage}`, { \n        source: 'frequency_error',\n        frequency: frequency,\n        errorType: data.errorType,\n        retryCount: data.retryCount\n    });\n\n    // Show frequency-specific error with transition state\n    const recoveryMessage = getFrequencyRecoveryMessage(data);\n    \n    showEnhancedError(errorMessage, 'frequency_error', {\n        recovery: recoveryMessage,\n        context: { \n            frequency: frequency,\n            errorType: data.errorType,\n            retryCount: data.retryCount,\n            maxRetries: data.maxRetries,\n            blacklisted: data.blacklisted\n        }\n    });\n\n    // Update frequency transition display\n    updateFrequencyErrorDisplay(data);\n}\n\nfunction handleGracefulStop(data) {\n    const stopReason = data.consecutiveErrors >= data.maxErrors ? \n        'Too many consecutive errors' : 'System protection activated';\n    \n    trackOperation(`Graceful stop: ${stopReason}`, { \n        source: 'graceful_stop',\n        consecutiveErrors: data.consecutiveErrors,\n        maxErrors: data.maxErrors,\n        frequencyErrors: data.frequencyErrors\n    });\n\n    // Reset UI state\n    resetScanningState();\n    \n    // Show comprehensive stop information\n    showEnhancedError(`🛑 Cycling stopped: ${stopReason}`, 'graceful_stop', {\n        recovery: 'Review error details and check frequency settings. Consider removing problematic frequencies.',\n        context: {\n            errorType: 'graceful_stop',\n            consecutiveErrors: data.consecutiveErrors,\n            maxErrors: data.maxErrors,\n            blacklistedFrequencies: data.blacklistedFrequencies,\n            hasBlacklistedFreqs: data.blacklistedFrequencies && data.blacklistedFrequencies.length > 0\n        }\n    });\n\n    // Show detailed error summary\n    if (data.frequencyErrors && Object.keys(data.frequencyErrors).length > 0) {\n        createFrequencyErrorSummary(data.frequencyErrors, data.blacklistedFrequencies);\n    }\n}\n\nfunction getCyclingRecoveryActions(errorType, data) {\n    switch (errorType) {\n        case 'frequency_startup':\n            return {\n                message: 'Check HackRF connection and verify frequency is within valid range (1 MHz - 6 GHz).',\n                retryable: true\n            };\n        case 'failure_loop_prevention':\n            return {\n                message: 'Too many failures detected. Check HackRF connection and frequency settings.',\n                retryable: false\n            };\n        case 'hackrf_device_error':\n            return {\n                message: 'HackRF device error. Try disconnecting and reconnecting the device.',\n                retryable: true\n            };\n        default:\n            return {\n                message: 'Check system status and try restarting the operation.',\n                retryable: true\n            };\n    }\n}\n\nfunction getFrequencyRecoveryMessage(data) {\n    if (data.blacklisted) {\n        return `Frequency ${data.frequency} has been blacklisted due to repeated errors. Consider removing it from your frequency list.`;\n    }\n    \n    if (data.retryCount >= data.maxRetries) {\n        return `Frequency ${data.frequency} failed after ${data.retryCount} attempts. It may be incompatible or require different settings.`;\n    }\n    \n    return `Frequency ${data.frequency} failed. The system will retry automatically.`;\n}\n\nfunction updateCyclingErrorIndicator(data) {\n    // Add visual indicator for cycling errors\n    const statusElement = document.getElementById('statusMessage');\n    if (statusElement) {\n        statusElement.classList.add('cycling-error');\n        \n        // Add severity indicator\n        statusElement.setAttribute('data-error-severity', data.severity || 'medium');\n        \n        // Auto-remove after delay\n        setTimeout(() => {\n            statusElement.classList.remove('cycling-error');\n            statusElement.removeAttribute('data-error-severity');\n        }, 10000);\n    }\n}\n\nfunction updateFrequencyErrorDisplay(data) {\n    \n    // Highlight problematic frequency in UI if visible\n    highlightFrequencyError(data.frequency);\n}\n\nfunction highlightFrequencyError(frequency) {\n    // Find and highlight the frequency input that matches the error\n    const frequencyInputs = document.querySelectorAll('input[id^=\"frequencyInput\"]');\n    frequencyInputs.forEach(input => {\n        const value = parseFloat(input.value);\n        const unit = input.parentElement?.querySelector('select')?.value || 'MHz';\n        \n        let valueInMHz = value;\n        if (unit === 'GHz') valueInMHz = value * 1000;\n        if (unit === 'kHz') valueInMHz = value / 1000;\n        \n        // Convert frequency to MHz for comparison\n        const errorFreqMHz = parseFloat(frequency);\n        \n        if (Math.abs(valueInMHz - errorFreqMHz) < 0.001) { // Allow small floating point differences\n            const container = input.closest('.frequency-item');\n            if (container) {\n                container.classList.add('frequency-error');\n                \n                // Auto-remove highlighting after 15 seconds\n                setTimeout(() => {\n                    container.classList.remove('frequency-error');\n                }, 15000);\n            }\n        }\n    });\n}\n\nfunction createFrequencyErrorSummary(frequencyErrors, blacklistedFrequencies) {\n    // Remove existing summary if present\n    const existingSummary = document.getElementById('frequencyErrorSummary');\n    if (existingSummary) {\n        existingSummary.remove();\n    }\n    \n    const summaryPanel = document.createElement('div');\n    summaryPanel.id = 'frequencyErrorSummary';\n    summaryPanel.className = 'frequency-error-summary';\n    \n    let summaryHTML = '<div class=\"error-summary-header\"><h3>📊 Frequency Error Summary</h3></div>';\n    summaryHTML += '<div class=\"error-summary-content\">';\n    \n    // Show blacklisted frequencies\n    if (blacklistedFrequencies && blacklistedFrequencies.length > 0) {\n        summaryHTML += '<div class=\"blacklisted-frequencies\">';\n        summaryHTML += '<h4>🚫 Blacklisted Frequencies:</h4>';\n        summaryHTML += '<ul>';\n        blacklistedFrequencies.forEach(freq => {\n            summaryHTML += `<li>${freq} MHz (removed from cycling)</li>`;\n        });\n        summaryHTML += '</ul>';\n        summaryHTML += '</div>';\n    }\n    \n    // Show frequency error details\n    if (Object.keys(frequencyErrors).length > 0) {\n        summaryHTML += '<div class=\"frequency-error-details\">';\n        summaryHTML += '<h4>⚠️ Frequency Errors:</h4>';\n        summaryHTML += '<ul>';\n        Object.entries(frequencyErrors).forEach(([freq, errors]) => {\n            if (errors && errors.length > 0) {\n                const latestError = errors[errors.length - 1];\n                summaryHTML += `<li>${freq} MHz: ${errors.length} error(s) - ${latestError.error}</li>`;\n            }\n        });\n        summaryHTML += '</ul>';\n        summaryHTML += '</div>';\n    }\n    \n    summaryHTML += '<div class=\"error-summary-actions\">';\n    summaryHTML += '<button id=\"clearErrorSummary\" class=\"dismiss-error-btn\">✕ Dismiss</button>';\n    summaryHTML += '<button id=\"restartWithoutErrors\" class=\"retry-btn\">🔄 Restart Without Problem Frequencies</button>';\n    summaryHTML += '</div>';\n    summaryHTML += '</div>';\n    \n    summaryPanel.innerHTML = summaryHTML;\n    \n    // Insert after the status message\n    const statusMessage = document.getElementById('statusMessage');\n    statusMessage.parentNode.insertBefore(summaryPanel, statusMessage.nextSibling);\n    \n    // Add event listeners\n    document.getElementById('clearErrorSummary').onclick = () => summaryPanel.remove();\n    document.getElementById('restartWithoutErrors').onclick = () => {\n        removeBlacklistedFrequencies(blacklistedFrequencies);\n        summaryPanel.remove();\n    };\n    \n    // Auto-remove after 2 minutes\n    setTimeout(() => {\n        if (summaryPanel.parentNode) {\n            summaryPanel.remove();\n        }\n    }, 120000);\n}\n\nfunction removeBlacklistedFrequencies(blacklistedFrequencies) {\n    if (!blacklistedFrequencies || blacklistedFrequencies.length === 0) return;\n    \n    blacklistedFrequencies.forEach(freqStr => {\n        const freqMHz = parseFloat(freqStr);\n        removeFrequencyFromInputs(freqMHz);\n    });\n    \n    showStatus(`Removed ${blacklistedFrequencies.length} problematic frequencies from the list`, 'success');\n}\n\nfunction removeFrequencyFromInputs(targetFreqMHz) {\n    const frequencyInputs = document.querySelectorAll('input[id^=\"frequencyInput\"]');\n    frequencyInputs.forEach(input => {\n        const value = parseFloat(input.value);\n        const unit = input.parentElement?.querySelector('select')?.value || 'MHz';\n        \n        let valueInMHz = value;\n        if (unit === 'GHz') valueInMHz = value * 1000;\n        if (unit === 'kHz') valueInMHz = value / 1000;\n        \n        if (Math.abs(valueInMHz - targetFreqMHz) < 0.001) {\n            const container = input.closest('.frequency-item');\n            if (container && container.id !== 'frequencyItem1') {\n                // Don't remove the first frequency input, just clear it\n                container.remove();\n                // updateRemoveButtons(); // Commented out to prevent duplicate remove buttons\n                updateAddButtonState();\n            } else if (container && container.id === 'frequencyItem1') {\n                // Clear the first input but keep the container\n                input.value = '';\n                const unitSelect = container.querySelector('select');\n                if (unitSelect) unitSelect.value = 'MHz';\n            }\n        }\n    });\n}\n\n// Retry operation handlers for cycling errors\nfunction handleRetryOperation(errorContext, contextData) {\n    trackOperation('User initiated retry operation', { \n        source: 'error_retry',\n        errorContext: errorContext,\n        frequency: contextData?.frequency,\n        errorType: contextData?.errorType\n    });\n    \n    showStatus('🔄 Retrying operation...', 'info');\n    \n    // Wait a moment for system to stabilize, then retry\n    setTimeout(() => {\n        if (errorContext === 'cycling_error' || errorContext === 'frequency_error') {\n            // For cycling errors, attempt to restart the sweep\n            startSweep({ source: 'error_retry' });\n        } else if (errorContext === 'stuck_recovery') {\n            // For stuck recovery, try to force a clean restart\n            stopSweep().then(() => {\n                setTimeout(() => {\n                    startSweep({ source: 'stuck_recovery_retry' });\n                }, 2000);\n            });\n        } else {\n            // Generic retry - attempt to restart sweep\n            startSweep({ source: 'generic_retry' });\n        }\n    }, 1000);\n}\n\nfunction handleRestartSweep(contextData) {\n    trackOperation('User initiated sweep restart from error', { \n        source: 'error_restart',\n        frequency: contextData?.frequency,\n        errorType: contextData?.errorType\n    });\n    \n    showStatus('🚀 Restarting sweep operation...', 'info');\n    \n    // Ensure clean state before restart\n    if (isScanning) {\n        stopSweep().then(() => {\n            setTimeout(() => {\n                startSweep({ source: 'error_restart' });\n            }, 2000);\n        });\n    } else {\n        startSweep({ source: 'error_restart' });\n    }\n}\n\n// General error recovery message generator\nfunction getGeneralErrorRecovery(errorType, data) {\n    switch (errorType) {\n        case 'hackrf_not_found':\n            return 'Check that your HackRF device is connected via USB and not being used by another application.';\n        case 'hackrf_device_error':\n        case 'device_error':\n            return 'Try disconnecting and reconnecting your HackRF device. Make sure it has adequate power supply.';\n        case 'invalid_frequency':\n            return 'Verify that all frequencies are within the valid range (1 MHz - 6 GHz) and properly formatted.';\n        case 'sweep_startup_failed':\n            return 'Check HackRF connection and frequency settings. Try restarting the sweep operation.';\n        case 'connection_error':\n            return 'Server connection lost. Check that the backend service is running and try refreshing the page.';\n        default:\n            return 'Try restarting the operation. If the problem persists, check the HackRF connection and frequency settings.';\n    }\n}\n\n// Determine if an error is retryable\nfunction isRetryableError(errorType) {\n    const nonRetryableErrors = [\n        'hackrf_not_found',\n        'invalid_frequency',\n        'configuration_error'\n    ];\n    return !nonRetryableErrors.includes(errorType);\n}\n\n// Enhanced error logging with comprehensive context tracking\nfunction logError(context, error, additionalInfo = {}) {\n    const callStack = getCallStack();\n    const errorInfo = {\n        timestamp: new Date().toISOString(),\n        context: context,\n        error: {\n            message: error.message,\n            name: error.name,\n            stack: error.stack\n        },\n        applicationState: {\n            isScanning,\n            isCycling,\n            connectionStatus,\n            sseConnectionActive,\n            currentFrequencyIndex\n        },\n        callStack: callStack.slice(0, 10),\n        recentOperations: window.recentOperations?.slice(0, 5) || [],\n        lastSyncTime: window.lastStateSyncTime || 'Never',\n        ...additionalInfo\n    };\n    \n    console.error('Enhanced error log:', errorInfo);\n    \n    // Track error in recent operations with enhanced context\n    trackOperation(`ERROR in ${context}: ${error.message}`, {\n        source: 'error_log',\n        errorType: error.name,\n        callStack: callStack.slice(0, 3),\n        recovery: additionalInfo.recovery || 'No recovery info provided'\n    });\n    \n    // Store last error context for debugging\n    window.lastErrorContext = {\n        context,\n        timestamp: new Date().toISOString(),\n        errorInfo\n    };\n    \n    // Store error history for debugging\n    if (!window.errorHistory) window.errorHistory = [];\n    window.errorHistory.unshift({\n        timestamp: new Date().toISOString(),\n        context,\n        error: error.message,\n        stack: callStack.slice(0, 5)\n    });\n    if (window.errorHistory.length > 20) {\n        window.errorHistory.pop();\n    }\n}\n\n// Handle page unload\nwindow.addEventListener('beforeunload', () => {\n    if (isScanning) {\n        stopSweep();\n    }\n});\n\n// Handle online/offline events\nwindow.addEventListener('online', () => {\n    showStatus('Internet connection restored', 'success');\n    if (!isScanning) {\n        performHealthCheck();\n    }\n});\n\nwindow.addEventListener('offline', () => {\n    showStatus('Internet connection lost', 'warning');\n    connectionStatus = 'disconnected';\n    updateConnectionStatus();\n});\n\n\n// Keyboard shortcuts\ndocument.addEventListener('keydown', (event) => {\n    // Escape key to stop sweep (regular stop)\n    if (event.key === 'Escape' && isScanning) {\n        event.preventDefault();\n        stopSweep(false);\n    }\n});\n\n// Toggle debug mode - removed\nfunction toggleDebugMode() {\n    // Debug mode toggle removed\n}\n\n// Proactive State Validation and Health Check Functions\n\n/**\n * Perform startup health check to verify clean initial state\n */\nasync function performStartupHealthCheck() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/api/startup-health`, {\n            method: 'GET',\n            timeout: 5000\n        });\n        \n        if (response.ok) {\n            const data = await response.json();\n            \n            if (data.startupCheck.cleanState) {\n                console.log('✅ Startup health check passed - clean state verified');\n            } else {\n                console.warn('⚠️ Startup health check detected issues:', data.startupCheck.issues);\n                showStatus('Startup health check detected issues - see console for details', 'warning');\n            }\n            \n            return data.startupCheck;\n        } else {\n            console.warn('⚠️ Startup health check endpoint failed');\n            return { cleanState: false, issues: ['Health check endpoint failed'] };\n        }\n    } catch (error) {\n        console.warn('⚠️ Startup health check error:', error.message);\n        return { cleanState: false, issues: [`Health check error: ${error.message}`] };\n    }\n}\n\n/**\n * Start proactive state validation monitoring\n */\nfunction startProactiveStateValidation() {\n    // Run state validation every 2 minutes for proactive monitoring\n    setInterval(async () => {\n        if (connectionStatus === 'connected') {\n            await performProactiveStateValidation();\n        }\n    }, 120000); // 2 minutes\n    \n    // Run a quick validation check every 30 seconds during active operations\n    setInterval(async () => {\n        if (connectionStatus === 'connected' && isScanning) {\n            await performQuickStateValidation();\n        }\n    }, 30000); // 30 seconds\n}\n\n/**\n * Perform comprehensive proactive state validation\n */\nasync function performProactiveStateValidation() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/api/state-validation`, {\n            method: 'GET',\n            timeout: 5000\n        });\n        \n        if (response.ok) {\n            const data = await response.json();\n            \n            // Check validation results\n            if (!data.validation.valid) {\n                console.warn('⚠️ Proactive state validation detected issues:', data.validation.issues);\n                \n                // Show user-friendly warning for serious issues\n                const seriousIssues = data.validation.issues.filter(issue => \n                    issue.includes('State incoherence') || \n                    issue.includes('orphaned') ||\n                    issue.includes('stale')\n                );\n                \n                if (seriousIssues.length > 0) {\n                    showStatus('System health check detected issues - automatic cleanup in progress', 'warning');\n                }\n            }\n            \n            // Check split-brain detection\n            if (data.splitBrainCheck.detected) {\n                console.warn('⚠️ Split-brain condition detected:', data.splitBrainCheck.issues);\n                showStatus('Split-brain condition detected - attempting automatic resolution', 'warning');\n                \n                // Trigger synchronization to help resolve split-brain\n                setTimeout(() => {\n                    synchronizeWithServerState('split_brain_resolution');\n                }, 2000);\n            }\n            \n            return data;\n        } else {\n            console.warn('⚠️ State validation endpoint failed');\n            return null;\n        }\n    } catch (error) {\n        // Don't show errors to user for proactive checks - they're background operations\n        console.debug('State validation check failed (non-critical):', error.message);\n        return null;\n    }\n}\n\n/**\n * Perform quick state validation during active operations\n */\nasync function performQuickStateValidation() {\n    try {\n        // Quick check: verify current server state matches UI state\n        const response = await fetch(`${API_BASE_URL}/cycle-status`, {\n            method: 'GET',\n            timeout: 3000\n        });\n        \n        if (response.ok) {\n            const serverState = await response.json();\n            \n            // Check for obvious mismatches\n            const serverIsActive = Boolean(serverState.isRunning || serverState.isActive);\n            \n            if (serverIsActive !== isScanning) {\n                console.warn('⚠️ Quick validation detected state mismatch - triggering sync');\n                \n                // Trigger immediate synchronization\n                synchronizeWithServerState('quick_validation_mismatch');\n            }\n        }\n    } catch (error) {\n        // Silent failure for quick checks - don't disturb user experience\n        console.debug('Quick state validation failed (non-critical):', error.message);\n    }\n}\n\n/**\n * Enhanced health check with validation reporting\n */\nasync function performEnhancedHealthCheck() {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`, {\n            method: 'GET',\n            timeout: 5000\n        });\n        \n        if (response.ok) {\n            const data = await response.json();\n            \n            // Update connection status based on health check\n            connectionStatus = data.status === 'ok' ? 'connected' : 'warning';\n            updateConnectionStatus();\n            \n            // Report any state validation issues\n            if (data.stateValidation && !data.stateValidation.valid) {\n                console.warn('🔍 Health check detected state validation issues:', data.stateValidation.issues);\n            }\n            \n            // Report split-brain detection\n            if (data.splitBrainCheck && data.splitBrainCheck.detected) {\n                console.warn('🔍 Health check detected split-brain conditions:', data.splitBrainCheck.issues);\n            }\n            \n            // Report hardware issues\n            if (data.hardware && data.hardware.hackrfError) {\n                console.warn('🔍 Hardware issue detected:', data.hardware.hackrfError);\n            }\n            \n            return data;\n        } else {\n            connectionStatus = 'error';\n            updateConnectionStatus();\n            return null;\n        }\n    } catch (error) {\n        connectionStatus = 'disconnected';\n        updateConnectionStatus();\n        return null;\n    }\n}\n\n// Note: performHealthCheck function is defined earlier in the file\n\n\n\n/**\n * Format duration in milliseconds to a human-readable string\n */\nfunction formatDuration(ms) {\n    if (ms < 1000) {\n        return `${Math.round(ms)}ms`;\n    } else if (ms < 60000) {\n        return `${(ms / 1000).toFixed(1)}s`;\n    } else {\n        const minutes = Math.floor(ms / 60000);\n        const seconds = Math.floor((ms % 60000) / 1000);\n        return `${minutes}m ${seconds}s`;\n    }\n}\n\n/**\n * Format frequency object to display string\n */\nfunction formatFrequency(frequency) {\n    if (!frequency) return '--';\n    \n    if (typeof frequency === 'object') {\n        return `${frequency.frequency} ${frequency.unit || 'MHz'}`;\n    } else {\n        return `${frequency} MHz`;\n    }\n}\n\n/**\n * Capitalize first letter of a string\n */\nfunction capitalizeFirst(str) {\n    if (!str) return '';\n    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();\n}\n\n",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/static/workers/gridProcessor.js",
		"messages": [
			{
				"ruleId": "no-unused-vars",
				"severity": 2,
				"message": "'bounds' is defined but never used.",
				"line": 259,
				"column": 52,
				"nodeType": "Identifier",
				"messageId": "unusedVar",
				"endLine": 259,
				"endColumn": 58,
				"suggestions": [
					{
						"messageId": "removeVar",
						"data": { "varName": "bounds" },
						"fix": { "range": [9647, 9655], "text": "" },
						"desc": "Remove unused variable 'bounds'."
					}
				]
			}
		],
		"suppressedMessages": [],
		"errorCount": 1,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "/**\n * Web Worker for heavy grid analysis calculations\n * Processes signal data into grid cells for visualization\n */\n\n// Grid calculation utilities\nfunction getGridKey(lat, lon, gridSize) {\n  const latMetersPerDegree = 111320;\n  const lonMetersPerDegree = 111320 * Math.cos(lat * Math.PI / 180);\n  \n  const gridLat = Math.floor(lat * latMetersPerDegree / gridSize) * gridSize / latMetersPerDegree;\n  const gridLon = Math.floor(lon * lonMetersPerDegree / gridSize) * gridSize / lonMetersPerDegree;\n  \n  return `${gridLat.toFixed(6)},${gridLon.toFixed(6)}`;\n}\n\nfunction calculateGridBounds(lat, lon, gridSize) {\n  const latMetersPerDegree = 111320;\n  const lonMetersPerDegree = 111320 * Math.cos(lat * Math.PI / 180);\n  \n  const latDelta = gridSize / latMetersPerDegree;\n  const lonDelta = gridSize / lonMetersPerDegree;\n  \n  return {\n    minLat: lat,\n    maxLat: lat + latDelta,\n    minLon: lon,\n    maxLon: lon + lonDelta\n  };\n}\n\nfunction processSignalsToGrid(signals, gridSize, bounds) {\n  const gridData = new Map();\n  const startTime = performance.now();\n  \n  // Filter signals within bounds if provided\n  const validSignals = bounds ? signals.filter(signal => {\n    return signal.lat >= bounds.minLat && \n           signal.lat <= bounds.maxLat &&\n           signal.lon >= bounds.minLon && \n           signal.lon <= bounds.maxLon;\n  }) : signals;\n  \n  // Process each signal\n  validSignals.forEach(signal => {\n    const gridKey = getGridKey(signal.lat, signal.lon, gridSize);\n    \n    if (gridData.has(gridKey)) {\n      const cell = gridData.get(gridKey);\n      cell.signals.push(signal);\n      cell.totalPower += signal.power;\n      cell.maxPower = Math.max(cell.maxPower, signal.power);\n      cell.minPower = Math.min(cell.minPower, signal.power);\n      \n      // Track frequency bands with more detail\n      const freqBand = getFrequencyBand(signal.freq);\n      const bandCategory = getBandCategory(freqBand);\n      \n      // Track both specific and category bands\n      cell.freqBands[freqBand] = (cell.freqBands[freqBand] || 0) + 1;\n      if (!cell.bandCategories) cell.bandCategories = {};\n      cell.bandCategories[bandCategory] = (cell.bandCategories[bandCategory] || 0) + 1;\n      \n      // Enhanced frequency tracking with 1MHz precision for better aggregation\n      const freqKey = Math.round(signal.freq); // Round to nearest MHz\n      if (!cell.freqDetails[freqKey]) {\n        cell.freqDetails[freqKey] = { \n          count: 0, \n          maxPower: signal.power, \n          avgPower: 0, \n          totalPower: 0,\n          band: freqBand,\n          category: bandCategory,\n          timestamps: []\n        };\n      }\n      cell.freqDetails[freqKey].count++;\n      cell.freqDetails[freqKey].totalPower += signal.power;\n      cell.freqDetails[freqKey].avgPower = cell.freqDetails[freqKey].totalPower / cell.freqDetails[freqKey].count;\n      cell.freqDetails[freqKey].maxPower = Math.max(cell.freqDetails[freqKey].maxPower, signal.power);\n      cell.freqDetails[freqKey].timestamps.push(signal.timestamp);\n      \n      // Update time range\n      cell.timeRange.start = Math.min(cell.timeRange.start, signal.timestamp);\n      cell.timeRange.end = Math.max(cell.timeRange.end, signal.timestamp);\n    } else {\n      const [lat, lon] = gridKey.split(',').map(Number);\n      const bounds = calculateGridBounds(lat, lon, gridSize);\n      const freqBand = getFrequencyBand(signal.freq);\n      const bandCategory = getBandCategory(freqBand);\n      const freqKey = Math.round(signal.freq);\n      \n      gridData.set(gridKey, {\n        key: gridKey,\n        bounds,\n        signals: [signal],\n        totalPower: signal.power,\n        maxPower: signal.power,\n        minPower: signal.power,\n        freqBands: { [freqBand]: 1 },\n        bandCategories: { [bandCategory]: 1 },\n        freqDetails: { \n          [freqKey]: { \n            count: 1, \n            maxPower: signal.power, \n            avgPower: signal.power, \n            totalPower: signal.power,\n            band: freqBand,\n            category: bandCategory,\n            timestamps: [signal.timestamp]\n          } \n        },\n        timeRange: {\n          start: signal.timestamp,\n          end: signal.timestamp\n        }\n      });\n    }\n  });\n  \n  // Calculate statistics for each cell\n  const processedCells = [];\n  gridData.forEach((cell, key) => {\n    const avgPower = cell.totalPower / cell.signals.length;\n    const dominantBand = Object.entries(cell.freqBands)\n      .sort((a, b) => b[1] - a[1])[0][0];\n    \n    // Calculate signal density (signals per square meter)\n    const areaM2 = gridSize * gridSize;\n    const density = cell.signals.length / areaM2;\n    \n    // Standard deviation of power\n    const variance = cell.signals.reduce((acc, signal) => {\n      return acc + Math.pow(signal.power - avgPower, 2);\n    }, 0) / cell.signals.length;\n    const stdDev = Math.sqrt(variance);\n    \n    // Enhanced signal aggregation algorithm\n    // Combines peak power with signal density for better representation\n    const signalDensity = cell.signals.length / (gridSize * gridSize / 10000); // signals per 100m²\n    const densityFactor = Math.min(1, signalDensity / 0.5); // Max at 0.5 signals/100m²\n    \n    // Calculate confidence based on multiple factors\n    const countConfidence = Math.min(1, cell.signals.length / 10); // Max confidence at 10+ signals\n    const timeSpanMinutes = (cell.timeRange.end - cell.timeRange.start) / 60000;\n    const temporalConfidence = Math.min(1, timeSpanMinutes / 5); // Max confidence at 5+ minutes\n    const confidenceFactor = (countConfidence * 0.7 + temporalConfidence * 0.3);\n    \n    // Enhanced aggregation formula\n    // Uses weighted combination of peak and high percentile values\n    const sortedPowers = cell.signals.map(s => s.power).sort((a, b) => b - a);\n    const p95Index = Math.floor(sortedPowers.length * 0.05); // 95th percentile\n    const p95Power = sortedPowers[p95Index] || cell.maxPower;\n    \n    // Final aggregated power calculation\n    const aggregatedPower = (cell.maxPower * 0.6 + p95Power * 0.4) * (0.8 + 0.2 * densityFactor);\n    \n    // Find the strongest frequencies by category\n    const strongestByCategory = {};\n    const topFrequencies = [];\n    \n    Object.entries(cell.freqDetails).forEach(([freq, data]) => {\n      const category = data.category;\n      if (!strongestByCategory[category] || data.maxPower > strongestByCategory[category].power) {\n        strongestByCategory[category] = {\n          freq: parseInt(freq),\n          power: data.maxPower,\n          band: data.band,\n          count: data.count\n        };\n      }\n      \n      // Keep track of top 5 frequencies overall\n      topFrequencies.push({\n        freq: parseInt(freq),\n        power: data.maxPower,\n        band: data.band,\n        count: data.count\n      });\n    });\n    \n    // Sort and keep top 5\n    topFrequencies.sort((a, b) => b.power - a.power);\n    const top5Frequencies = topFrequencies.slice(0, 5);\n    \n    // Get overall strongest\n    const strongestFreq = topFrequencies[0] || { freq: 0, power: -120 };\n    \n    processedCells.push({\n      key,\n      bounds: cell.bounds,\n      stats: {\n        count: cell.signals.length,\n        avgPower,\n        maxPower: cell.maxPower,\n        minPower: cell.minPower,\n        aggregatedPower,\n        stdDev,\n        density,\n        densityFactor,\n        dominantBand,\n        freqBands: cell.freqBands,\n        bandCategories: cell.bandCategories,\n        strongestFreq: strongestFreq.freq,\n        strongestFreqPower: strongestFreq.power,\n        strongestByCategory,\n        topFrequencies: top5Frequencies,\n        timeRange: cell.timeRange,\n        confidenceFactor,\n        temporalSpanMinutes: (cell.timeRange.end - cell.timeRange.start) / 60000\n      }\n    });\n  });\n  \n  const processingTime = performance.now() - startTime;\n  \n  return {\n    cells: processedCells,\n    totalSignals: validSignals.length,\n    totalCells: processedCells.length,\n    processingTime,\n    gridSize\n  };\n}\n\n// Enhanced frequency band categorization with sub-bands\nfunction getFrequencyBand(freq) {\n  // More granular frequency band detection\n  if (freq >= 88 && freq <= 108) return 'FM Radio';\n  else if (freq >= 118 && freq <= 137) return 'Aircraft VHF';\n  else if (freq >= 144 && freq <= 148) return '2m Amateur';\n  else if (freq >= 400 && freq <= 470) return 'UHF';\n  else if (freq >= 420 && freq <= 450) return '70cm Amateur';\n  else if (freq >= 850 && freq <= 950) return 'GSM/LTE-850';\n  else if (freq >= 1710 && freq <= 1785) return 'LTE-1700';\n  else if (freq >= 1850 && freq <= 1990) return 'LTE-1900';\n  else if (freq >= 2110 && freq <= 2170) return 'LTE-2100';\n  else if (freq >= 2400 && freq <= 2484) return '2.4GHz WiFi';\n  else if (freq >= 2500 && freq <= 2690) return 'LTE-2600';\n  else if (freq >= 3400 && freq <= 3800) return '5G-3500';\n  else if (freq >= 5150 && freq <= 5350) return '5GHz WiFi-Low';\n  else if (freq >= 5470 && freq <= 5850) return '5GHz WiFi-High';\n  else if (freq >= 5850 && freq <= 5925) return '5.8GHz ISM';\n  else if (freq < 1000) return 'Sub-1GHz';\n  else return 'Other';\n}\n\n// Get simplified band category for grouping\nfunction getBandCategory(band) {\n  if (band.includes('WiFi')) return 'WiFi';\n  else if (band.includes('LTE') || band.includes('GSM') || band.includes('5G')) return 'Cellular';\n  else if (band.includes('Amateur')) return 'Amateur Radio';\n  else if (band === 'FM Radio' || band === 'Aircraft VHF') return 'Public Service';\n  else if (band.includes('ISM') || band === 'UHF') return 'ISM/Industrial';\n  else return 'Other';\n}\n\n// Hexagonal grid processing (future enhancement)\nfunction processSignalsToHexGrid(signals, hexSize, bounds) {\n  // Placeholder for hexagonal grid implementation\n  // This would use a different coordinate system (axial or cubic)\n  // For now, return empty result\n  return {\n    cells: [],\n    totalSignals: signals.length,\n    totalCells: 0,\n    processingTime: 0,\n    hexSize\n  };\n}\n\n// Message handler\nself.addEventListener('message', (event) => {\n  const { type, data, requestId } = event.data;\n  \n  switch (type) {\n    case 'processGrid':\n      try {\n        const result = processSignalsToGrid(\n          data.signals,\n          data.gridSize,\n          data.bounds\n        );\n        self.postMessage({\n          type: 'gridProcessed',\n          data: result,\n          requestId\n        });\n      } catch (error) {\n        self.postMessage({\n          type: 'error',\n          error: error.message,\n          requestId\n        });\n      }\n      break;\n      \n    case 'processHexGrid':\n      try {\n        const result = processSignalsToHexGrid(\n          data.signals,\n          data.hexSize,\n          data.bounds\n        );\n        self.postMessage({\n          type: 'hexGridProcessed',\n          data: result,\n          requestId\n        });\n      } catch (error) {\n        self.postMessage({\n          type: 'error',\n          error: error.message,\n          requestId\n        });\n      }\n      break;\n      \n    case 'calculateStats':\n      // Calculate overall statistics for a set of signals\n      try {\n        const signals = data.signals;\n        const stats = {\n          totalSignals: signals.length,\n          powerRange: {\n            min: Math.min(...signals.map(s => s.power)),\n            max: Math.max(...signals.map(s => s.power)),\n            avg: signals.reduce((acc, s) => acc + s.power, 0) / signals.length\n          },\n          freqRange: {\n            min: Math.min(...signals.map(s => s.freq)),\n            max: Math.max(...signals.map(s => s.freq))\n          },\n          timeRange: {\n            start: Math.min(...signals.map(s => s.timestamp)),\n            end: Math.max(...signals.map(s => s.timestamp))\n          },\n          signalDensity: signals.length / ((data.bounds.maxLat - data.bounds.minLat) * \n                                           (data.bounds.maxLon - data.bounds.minLon) * \n                                           111320 * 111320) // Convert to square meters\n        };\n        \n        self.postMessage({\n          type: 'statsCalculated',\n          data: stats,\n          requestId\n        });\n      } catch (error) {\n        self.postMessage({\n          type: 'error',\n          error: error.message,\n          requestId\n        });\n      }\n      break;\n      \n    default:\n      self.postMessage({\n        type: 'error',\n        error: 'Unknown message type: ' + type,\n        requestId\n      });\n  }\n});",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/static/workers/interpolationWorker.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/svelte.config.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/tailwind.config.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/test-hackrf-direct.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/test-hackrf-sweep.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/test-sweep-direct.js",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/tests/e2e/user-flows.test.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/tests/fixtures/mock-data.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/tests/helpers/setup.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/tests/helpers/test-server.ts",
		"messages": [],
		"suppressedMessages": [
			{
				"ruleId": "@typescript-eslint/no-base-to-string",
				"severity": 2,
				"message": "'data' may use Object's default stringification format ('[object Object]') when stringified.",
				"line": 121,
				"column": 38,
				"nodeType": "Identifier",
				"messageId": "baseToString",
				"endLine": 121,
				"endColumn": 42,
				"suppressions": [{ "kind": "directive", "justification": "" }]
			}
		],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/tests/helpers/visual-helpers.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/tests/integration/api.test.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/tests/integration/app.test.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/tests/integration/websocket.test.ts",
		"messages": [],
		"suppressedMessages": [
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 27,
				"column": 9,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 27,
				"endColumn": 12,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [877, 878], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				],
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 46,
				"column": 9,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 46,
				"endColumn": 12,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [1542, 1543], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				],
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 88,
				"column": 9,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 88,
				"endColumn": 12,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [2830, 2831], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				],
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 113,
				"column": 9,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 113,
				"endColumn": 12,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [3691, 3692], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				],
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 174,
				"column": 9,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 174,
				"endColumn": 12,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [5507, 5508], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				],
				"suppressions": [{ "kind": "directive", "justification": "" }]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 205,
				"column": 9,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 205,
				"endColumn": 12,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [6552, 6553], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				],
				"suppressions": [{ "kind": "directive", "justification": "" }]
			}
		],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/tests/load/dataVolumes.test.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/tests/performance/benchmarks.test.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/tests/services/map/signalClustering.test.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 38,
				"column": 14,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 38,
				"endColumn": 26,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [1259, 1260], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 39,
				"column": 14,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 39,
				"endColumn": 26,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [1322, 1323], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 40,
				"column": 14,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 40,
				"endColumn": 26,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [1375, 1376], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 45,
				"column": 14,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 45,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "suggestOptionalChain",
						"fix": { "range": [1588, 1589], "text": "?" },
						"desc": "Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .lat on an `error` typed value.",
				"line": 70,
				"column": 31,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 70,
				"endColumn": 34
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .lon on an `error` typed value.",
				"line": 71,
				"column": 31,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 71,
				"endColumn": 34
			}
		],
		"suppressedMessages": [],
		"errorCount": 2,
		"fatalErrorCount": 0,
		"warningCount": 4,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { describe, it, expect } from 'vitest';\nimport { clusterSignals, createClusterPopupContent, getClusterIcon } from '$lib/services/map/signalClustering';\nimport type { SignalMarker } from '$lib/stores/map/signals';\n\ndescribe('signalClustering', () => {\n  const createMockSignal = (\n    id: string, \n    lat: number, \n    lon: number, \n    power: number = -70,\n    frequency: number = 2400\n  ): SignalMarker => ({\n    id,\n    position: { lat, lon },\n    power,\n    frequency,\n    timestamp: Date.now(),\n    source: 'hackrf',\n    metadata: { type: 'wifi' }\n  });\n\n  describe('clusterSignals', () => {\n    it('should cluster signals within radius', () => {\n      const signals: SignalMarker[] = [\n        createMockSignal('1', 40.7128, -74.0060, -60),\n        createMockSignal('2', 40.7129, -74.0061, -65), // ~15m away\n        createMockSignal('3', 40.7130, -74.0062, -70), // ~30m away\n        createMockSignal('4', 40.7200, -74.0100, -55), // ~8km away\n      ];\n\n      const clusters = clusterSignals(signals, 50); // 50m radius\n\n      expect(clusters).toHaveLength(2);\n      \n      // First cluster should have 3 signals\n      const mainCluster = clusters.find(c => c.stats.count === 3);\n      expect(mainCluster).toBeDefined();\n      expect(mainCluster!.stats.avgPower).toBeCloseTo(-65, 1);\n      expect(mainCluster!.stats.minPower).toBe(-70);\n      expect(mainCluster!.stats.maxPower).toBe(-60);\n\n      // Second cluster should have 1 signal\n      const singleCluster = clusters.find(c => c.stats.count === 1);\n      expect(singleCluster).toBeDefined();\n      expect(singleCluster!.stats.avgPower).toBe(-55);\n    });\n\n    it('should not cluster if below minimum cluster size', () => {\n      const signals: SignalMarker[] = [\n        createMockSignal('1', 40.7128, -74.0060),\n        createMockSignal('2', 40.7200, -74.0100), // Far away\n      ];\n\n      const clusters = clusterSignals(signals, 50, 3); // Min size 3\n\n      expect(clusters).toHaveLength(2);\n      expect(clusters.every(c => c.stats.count === 1)).toBe(true);\n    });\n\n    it('should calculate weighted center position', () => {\n      const signals: SignalMarker[] = [\n        createMockSignal('1', 40.7128, -74.0060, -50), // Strong signal\n        createMockSignal('2', 40.7129, -74.0061, -90), // Weak signal\n      ];\n\n      const clusters = clusterSignals(signals, 100);\n      const cluster = clusters[0];\n\n      // Center should be weighted towards stronger signal\n      expect(cluster.position.lat).toBeCloseTo(40.7128, 4);\n      expect(cluster.position.lon).toBeCloseTo(-74.0060, 4);\n    });\n\n    it('should track signal types and frequencies', () => {\n      const signals: SignalMarker[] = [\n        createMockSignal('1', 40.7128, -74.0060, -60, 2412),\n        createMockSignal('2', 40.7128, -74.0060, -65, 2437),\n        createMockSignal('3', 40.7128, -74.0060, -70, 5180),\n      ];\n      signals[2].metadata = { type: 'bluetooth' };\n\n      const clusters = clusterSignals(signals, 100);\n      const cluster = clusters[0];\n\n      expect(cluster.stats.signalTypes.get('wifi')).toBe(2);\n      expect(cluster.stats.signalTypes.get('bluetooth')).toBe(1);\n      expect(cluster.stats.dominantFreq).toBe(2400); // 2.4GHz band\n    });\n  });\n\n  describe('createClusterPopupContent', () => {\n    it('should generate proper HTML content', () => {\n      const cluster = {\n        id: 'test-cluster',\n        position: { lat: 40.7128, lon: -74.0060 },\n        signals: [],\n        bounds: [40.7128, -74.0060, 40.7129, -74.0061],\n        stats: {\n          count: 5,\n          avgPower: -65,\n          maxPower: -50,\n          minPower: -80,\n          dominantFreq: 2400,\n          signalTypes: new Map([['wifi', 3], ['bluetooth', 2]]),\n          timeRange: { start: Date.now() - 30000, end: Date.now() }\n        }\n      };\n\n      const html = createClusterPopupContent(cluster);\n\n      expect(html).toContain('Signal Cluster');\n      expect(html).toContain('Signals:</strong></div>');\n      expect(html).toContain('<div>5</div>');\n      expect(html).toContain('-65.0 dBm');\n      expect(html).toContain('2.4 GHz');\n      expect(html).toContain('wifi: 3, bluetooth: 2');\n      expect(html).toContain('30s');\n    });\n  });\n\n  describe('getClusterIcon', () => {\n    it('should return appropriate icon based on signal strength', () => {\n      const strongCluster = {\n        id: 'strong',\n        position: { lat: 0, lon: 0 },\n        signals: [],\n        bounds: [0, 0, 0, 0],\n        stats: {\n          count: 10,\n          avgPower: -45,\n          maxPower: -40,\n          minPower: -50,\n          dominantFreq: 2400,\n          signalTypes: new Map([['wifi', 10]]),\n          timeRange: { start: 0, end: 0 }\n        }\n      };\n\n      const icon = getClusterIcon(strongCluster);\n      \n      expect(icon.html).toContain('#ff0000'); // Red for strong\n      expect(icon.html).toContain('10'); // Count\n      expect(icon.html).toContain('📶'); // WiFi icon\n      expect(icon.iconSize[0]).toBeGreaterThan(40);\n    });\n\n    it('should scale icon size with signal count', () => {\n      const smallCluster = {\n        id: 'small',\n        position: { lat: 0, lon: 0 },\n        signals: [],\n        bounds: [0, 0, 0, 0],\n        stats: {\n          count: 2,\n          avgPower: -70,\n          maxPower: -65,\n          minPower: -75,\n          dominantFreq: 2400,\n          signalTypes: new Map([['unknown', 2]]),\n          timeRange: { start: 0, end: 0 }\n        }\n      };\n\n      const largeCluster = { ...smallCluster, stats: { ...smallCluster.stats, count: 100 } };\n\n      const smallIcon = getClusterIcon(smallCluster);\n      const largeIcon = getClusterIcon(largeCluster);\n\n      expect(largeIcon.iconSize[0]).toBeGreaterThan(smallIcon.iconSize[0]);\n      expect(largeIcon.iconSize[0]).toBeLessThanOrEqual(80); // Max size\n    });\n  });\n});",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/tests/setup.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/tests/simulation/droneSimulator.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/require-await",
				"severity": 2,
				"message": "Async method 'simulate' has no 'await' expression.",
				"line": 51,
				"column": 3,
				"nodeType": "FunctionExpression",
				"messageId": "missingAwait",
				"endLine": 51,
				"endColumn": 17,
				"suggestions": [
					{
						"messageId": "removeAsync",
						"fix": { "range": [1365, 1409], "text": "simulate(): SimulatedSignal[]" },
						"desc": "Remove 'async'."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'latChange' is assigned a value but never used. Allowed unused vars must match /^_/u.",
				"line": 103,
				"column": 11,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 103,
				"endColumn": 20
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'deltaTime' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 120,
				"column": 30,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 120,
				"endColumn": 39
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'deltaTime' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 140,
				"column": 37,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 140,
				"endColumn": 46
			},
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'deltaTime' is defined but never used. Allowed unused args must match /^_/u.",
				"line": 149,
				"column": 31,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 149,
				"endColumn": 40
			}
		],
		"suppressedMessages": [],
		"errorCount": 5,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "export interface DroneSimulatorConfig {\n  startPosition: { lat: number; lon: number };\n  flightPattern: 'grid' | 'orbit' | 'linear' | 'random' | 'surveillance';\n  speed: number; // m/s\n  altitude: number; // meters\n  duration: number; // seconds\n  signalStrength?: number; // dBm\n  frequency?: number; // Hz\n  environmentFactors?: {\n    windSpeed?: number; // m/s\n    windDirection?: number; // degrees\n    signalNoise?: number; // dB\n    urbanDensity?: number; // 0-1\n  };\n}\n\nexport interface SimulatedSignal {\n  timestamp: number;\n  latitude: number;\n  longitude: number;\n  altitude: number;\n  strength: number;\n  frequency: number;\n  velocity: { x: number; y: number; z: number };\n  metadata: {\n    droneId: string;\n    pattern: string;\n    batteryLevel: number;\n    gpsAccuracy: number;\n  };\n}\n\nexport class DroneSimulator {\n  private config: DroneSimulatorConfig;\n  private currentPosition: { lat: number; lon: number; alt: number };\n  private currentTime: number;\n  private signals: SimulatedSignal[] = [];\n  private droneId: string;\n  \n  constructor(config: DroneSimulatorConfig) {\n    this.config = config;\n    this.currentPosition = {\n      lat: config.startPosition.lat,\n      lon: config.startPosition.lon,\n      alt: config.altitude\n    };\n    this.currentTime = Date.now();\n    this.droneId = `drone_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  async simulate(): Promise<SimulatedSignal[]> {\n    const timeStep = 1000; // 1 second intervals\n    const steps = Math.floor(this.config.duration * 1000 / timeStep);\n    \n    for (let i = 0; i < steps; i++) {\n      this.updatePosition(timeStep / 1000);\n      this.generateSignal();\n      this.currentTime += timeStep;\n      \n      // Add some randomness for realism\n      if (Math.random() < 0.1) {\n        // 10% chance of missing signal\n        continue;\n      }\n    }\n    \n    return this.signals;\n  }\n\n  private updatePosition(deltaTime: number): void {\n    switch (this.config.flightPattern) {\n      case 'grid':\n        this.updateGridPattern(deltaTime);\n        break;\n      case 'orbit':\n        this.updateOrbitPattern(deltaTime);\n        break;\n      case 'linear':\n        this.updateLinearPattern(deltaTime);\n        break;\n      case 'surveillance':\n        this.updateSurveillancePattern(deltaTime);\n        break;\n      case 'random':\n        this.updateRandomPattern(deltaTime);\n        break;\n    }\n    \n    // Apply environmental factors\n    if (this.config.environmentFactors) {\n      this.applyWind(deltaTime);\n      this.applyGPSDrift();\n    }\n  }\n\n  private updateGridPattern(deltaTime: number): void {\n    // Implement lawn mower pattern\n    const gridSize = 0.001; // ~100m in latitude\n    const speed = this.config.speed;\n    const distance = speed * deltaTime;\n    \n    // Convert to approximate lat/lon change\n    const latChange = (distance / 111320) * Math.cos(this.currentPosition.lat * Math.PI / 180);\n    const lonChange = distance / 111320;\n    \n    // Simple back-and-forth pattern\n    const row = Math.floor((this.currentTime - Date.now()) / 10000) % 10;\n    if (row % 2 === 0) {\n      this.currentPosition.lon += lonChange;\n    } else {\n      this.currentPosition.lon -= lonChange;\n    }\n    \n    // Move to next row at boundaries\n    if (Math.abs(this.currentPosition.lon - this.config.startPosition.lon) > gridSize * 5) {\n      this.currentPosition.lat += gridSize;\n    }\n  }\n\n  private updateOrbitPattern(deltaTime: number): void {\n    const radius = 0.0005; // ~50m radius\n    const angularSpeed = this.config.speed / (radius * 111320);\n    const angle = (this.currentTime - Date.now()) * angularSpeed / 1000;\n    \n    this.currentPosition.lat = this.config.startPosition.lat + radius * Math.cos(angle);\n    this.currentPosition.lon = this.config.startPosition.lon + radius * Math.sin(angle);\n  }\n\n  private updateLinearPattern(deltaTime: number): void {\n    const bearing = 45; // degrees\n    const distance = this.config.speed * deltaTime;\n    \n    const latChange = (distance / 111320) * Math.cos(bearing * Math.PI / 180);\n    const lonChange = (distance / 111320) * Math.sin(bearing * Math.PI / 180);\n    \n    this.currentPosition.lat += latChange;\n    this.currentPosition.lon += lonChange;\n  }\n\n  private updateSurveillancePattern(deltaTime: number): void {\n    // Figure-8 pattern for surveillance\n    const t = (this.currentTime - Date.now()) / 10000;\n    const scale = 0.001;\n    \n    this.currentPosition.lat = this.config.startPosition.lat + scale * Math.sin(t);\n    this.currentPosition.lon = this.config.startPosition.lon + scale * Math.sin(2 * t) / 2;\n  }\n\n  private updateRandomPattern(deltaTime: number): void {\n    const maxChange = 0.0001;\n    this.currentPosition.lat += (Math.random() - 0.5) * maxChange;\n    this.currentPosition.lon += (Math.random() - 0.5) * maxChange;\n    this.currentPosition.alt += (Math.random() - 0.5) * 5;\n    \n    // Keep altitude in bounds\n    this.currentPosition.alt = Math.max(10, Math.min(400, this.currentPosition.alt));\n  }\n\n  private applyWind(deltaTime: number): void {\n    if (!this.config.environmentFactors?.windSpeed) return;\n    \n    const windSpeed = this.config.environmentFactors.windSpeed;\n    const windDirection = this.config.environmentFactors.windDirection || 0;\n    \n    const windEffect = windSpeed * deltaTime / 111320;\n    this.currentPosition.lat += windEffect * Math.cos(windDirection * Math.PI / 180);\n    this.currentPosition.lon += windEffect * Math.sin(windDirection * Math.PI / 180);\n  }\n\n  private applyGPSDrift(): void {\n    const drift = 0.00001; // ~1m drift\n    this.currentPosition.lat += (Math.random() - 0.5) * drift;\n    this.currentPosition.lon += (Math.random() - 0.5) * drift;\n  }\n\n  private generateSignal(): void {\n    const baseStrength = this.config.signalStrength || -40;\n    const noise = this.config.environmentFactors?.signalNoise || 5;\n    \n    // Calculate velocity\n    const lastSignal = this.signals[this.signals.length - 1];\n    let velocity = { x: 0, y: 0, z: 0 };\n    \n    if (lastSignal) {\n      const dt = (this.currentTime - lastSignal.timestamp) / 1000;\n      velocity = {\n        x: (this.currentPosition.lon - lastSignal.longitude) * 111320 / dt,\n        y: (this.currentPosition.lat - lastSignal.latitude) * 111320 / dt,\n        z: (this.currentPosition.alt - lastSignal.altitude) / dt\n      };\n    }\n    \n    const signal: SimulatedSignal = {\n      timestamp: this.currentTime,\n      latitude: this.currentPosition.lat,\n      longitude: this.currentPosition.lon,\n      altitude: this.currentPosition.alt,\n      strength: baseStrength + (Math.random() - 0.5) * noise,\n      frequency: this.config.frequency || 2437000000, // 2.437 GHz\n      velocity,\n      metadata: {\n        droneId: this.droneId,\n        pattern: this.config.flightPattern,\n        batteryLevel: 100 - (this.signals.length / 10), // Simulate battery drain\n        gpsAccuracy: 5 + Math.random() * 10 // 5-15m accuracy\n      }\n    };\n    \n    this.signals.push(signal);\n  }\n\n  // Utility methods for testing\n  getFlightPath(): Array<{ lat: number; lon: number; alt: number }> {\n    return this.signals.map(s => ({\n      lat: s.latitude,\n      lon: s.longitude,\n      alt: s.altitude\n    }));\n  }\n\n  getAverageSpeed(): number {\n    if (this.signals.length < 2) return 0;\n    \n    let totalDistance = 0;\n    for (let i = 1; i < this.signals.length; i++) {\n      const prev = this.signals[i - 1];\n      const curr = this.signals[i];\n      const distance = this.calculateDistance(\n        prev.latitude, prev.longitude,\n        curr.latitude, curr.longitude\n      );\n      totalDistance += distance;\n    }\n    \n    const totalTime = (this.signals[this.signals.length - 1].timestamp - this.signals[0].timestamp) / 1000;\n    return totalDistance / totalTime;\n  }\n\n  private calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n    const R = 6371000; // Earth radius in meters\n    const φ1 = lat1 * Math.PI / 180;\n    const φ2 = lat2 * Math.PI / 180;\n    const Δφ = (lat2 - lat1) * Math.PI / 180;\n    const Δλ = (lon2 - lon1) * Math.PI / 180;\n\n    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +\n              Math.cos(φ1) * Math.cos(φ2) *\n              Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n    return R * c;\n  }\n}",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/tests/unit/components.test.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'beforeEach' is defined but never used. Allowed unused vars must match /^_/u.",
				"line": 1,
				"column": 32,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 1,
				"endColumn": 42
			},
			{
				"ruleId": "@typescript-eslint/no-non-null-assertion",
				"severity": 1,
				"message": "Forbidden non-null assertion.",
				"line": 108,
				"column": 29,
				"nodeType": "TSNonNullExpression",
				"messageId": "noNonNull",
				"endLine": 108,
				"endColumn": 34
			},
			{
				"ruleId": "@typescript-eslint/require-await",
				"severity": 2,
				"message": "Async arrow function has no 'await' expression.",
				"line": 115,
				"column": 57,
				"nodeType": "ArrowFunctionExpression",
				"messageId": "missingAwait",
				"endLine": 115,
				"endColumn": 59,
				"suggestions": [
					{
						"messageId": "removeAsync",
						"fix": { "range": [3834, 3840], "text": "" },
						"desc": "Remove 'async'."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .length on an `any` value.",
				"line": 207,
				"column": 32,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 207,
				"endColumn": 38
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access [0] on an `any` value.",
				"line": 223,
				"column": 32,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 223,
				"endColumn": 33
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .signal on an `error` typed value.",
				"line": 289,
				"column": 26,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 289,
				"endColumn": 32
			}
		],
		"suppressedMessages": [],
		"errorCount": 5,
		"fatalErrorCount": 0,
		"warningCount": 1,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { describe, it, expect, beforeEach, vi } from 'vitest';\nimport { render, fireEvent, waitFor } from '@testing-library/svelte';\nimport { tick } from 'svelte';\n\n// Mock component imports (these would be actual imports in a real test)\n// import SpectrumAnalyzer from '$lib/components/SpectrumAnalyzer.svelte';\n// import DeviceCard from '$lib/components/DeviceCard.svelte';\n// import FrequencySweeper from '$lib/components/FrequencySweeper.svelte';\n\ndescribe('Component Functionality Tests', () => {\n  describe('SpectrumAnalyzer Component', () => {\n    it('should render canvas element', () => {\n      const { container } = render(MockSpectrumAnalyzer);\n      const canvas = container.querySelector('canvas');\n      expect(canvas).toBeTruthy();\n      expect(canvas?.classList.contains('spectrum-canvas')).toBe(true);\n    });\n\n    it('should update on frequency change', async () => {\n      const { container, component } = render(MockSpectrumAnalyzer, {\n        centerFrequency: 100000000,\n      });\n\n      // Update frequency\n      component.$set({ centerFrequency: 105000000 });\n      await tick();\n\n      const canvas = container.querySelector('canvas');\n      expect(canvas).toBeTruthy();\n      // Would check actual canvas content in real test\n    });\n\n    it('should handle WebSocket data updates', async () => {\n      const { component } = render(MockSpectrumAnalyzer);\n      \n      const mockData = {\n        frequencies: new Float32Array([100, 101, 102]),\n        amplitudes: new Float32Array([-50, -60, -55]),\n      };\n\n      // Simulate WebSocket update\n      component.$set({ spectrumData: mockData });\n      await tick();\n\n      // Would verify canvas rendering in real test\n      expect(component.spectrumData).toEqual(mockData);\n    });\n\n    it('should apply correct scaling for different view modes', async () => {\n      const { component } = render(MockSpectrumAnalyzer);\n      \n      // Test different scales\n      const scales = ['linear', 'log'];\n      for (const scale of scales) {\n        component.$set({ scale });\n        await tick();\n        expect(component.scale).toBe(scale);\n      }\n    });\n  });\n\n  describe('DeviceCard Component', () => {\n    const mockDevice = {\n      id: 'test-123',\n      name: 'Test Device',\n      mac: '00:11:22:33:44:55',\n      signal: -65,\n      lastSeen: new Date().toISOString(),\n      vendor: 'Test Vendor',\n    };\n\n    it('should display device information correctly', () => {\n      const { getByText, getByTestId } = render(MockDeviceCard, {\n        device: mockDevice,\n      });\n\n      expect(getByText(mockDevice.name)).toBeTruthy();\n      expect(getByText(mockDevice.mac)).toBeTruthy();\n      expect(getByTestId('signal-strength')).toHaveTextContent('-65 dBm');\n    });\n\n    it('should update signal strength indicator', async () => {\n      const { getByTestId, component } = render(MockDeviceCard, {\n        device: mockDevice,\n      });\n\n      const signalBar = getByTestId('signal-bar');\n      \n      // Strong signal\n      component.$set({ device: { ...mockDevice, signal: -50 } });\n      await tick();\n      expect(signalBar.classList.contains('signal-strong')).toBe(true);\n\n      // Weak signal\n      component.$set({ device: { ...mockDevice, signal: -85 } });\n      await tick();\n      expect(signalBar.classList.contains('signal-weak')).toBe(true);\n    });\n\n    it('should emit click event when selected', async () => {\n      const handleClick = vi.fn();\n      const { container } = render(MockDeviceCard, {\n        device: mockDevice,\n        onclick: handleClick,\n      });\n\n      const card = container.querySelector('.device-card');\n      await fireEvent.click(card!);\n      \n      expect(handleClick).toHaveBeenCalledWith(expect.objectContaining({\n        detail: { device: mockDevice },\n      }));\n    });\n\n    it('should show last seen time correctly', async () => {\n      const { getByTestId } = render(MockDeviceCard, {\n        device: {\n          ...mockDevice,\n          lastSeen: new Date(Date.now() - 60000).toISOString(), // 1 minute ago\n        },\n      });\n\n      const lastSeen = getByTestId('last-seen');\n      expect(lastSeen.textContent).toMatch(/1 minute ago/);\n    });\n  });\n\n  describe('FrequencySweeper Component', () => {\n    it('should validate frequency inputs', async () => {\n      const { getByLabelText, getByText } = render(MockFrequencySweeper);\n      \n      const startFreqInput = getByLabelText('Start Frequency') as HTMLInputElement;\n      const endFreqInput = getByLabelText('End Frequency') as HTMLInputElement;\n\n      // Valid input\n      await fireEvent.input(startFreqInput, { target: { value: '88000000' } });\n      await fireEvent.input(endFreqInput, { target: { value: '108000000' } });\n      \n      expect(startFreqInput.validity.valid).toBe(true);\n      expect(endFreqInput.validity.valid).toBe(true);\n\n      // Invalid input (start > end)\n      await fireEvent.input(startFreqInput, { target: { value: '108000000' } });\n      await fireEvent.input(endFreqInput, { target: { value: '88000000' } });\n      \n      await waitFor(() => {\n        expect(getByText(/Start frequency must be less than end frequency/)).toBeTruthy();\n      });\n    });\n\n    it('should update progress during sweep', async () => {\n      const { getByTestId, component } = render(MockFrequencySweeper, {\n        isSweping: true,\n        progress: 0,\n      });\n\n      const progressBar = getByTestId('progress-bar');\n      \n      // Update progress\n      for (let progress = 0; progress <= 100; progress += 25) {\n        component.$set({ progress });\n        await tick();\n        expect(progressBar.style.width).toBe(`${progress}%`);\n      }\n    });\n\n    it('should disable controls during sweep', async () => {\n      const { getByText, component } = render(MockFrequencySweeper, {\n        isSweping: false,\n      });\n\n      const startButton = getByText('Start Sweep') as HTMLButtonElement;\n      expect(startButton.disabled).toBe(false);\n\n      // Start sweep\n      component.$set({ isSweping: true });\n      await tick();\n\n      expect(startButton.disabled).toBe(true);\n      expect(getByText('Stop Sweep')).toBeTruthy();\n    });\n  });\n\n  describe('Map Component', () => {\n    it('should initialize with correct center coordinates', () => {\n      const { container } = render(MockMapComponent, {\n        center: { lat: 40.7128, lng: -74.0060 },\n        zoom: 12,\n      });\n\n      const mapContainer = container.querySelector('.map-container');\n      expect(mapContainer).toBeTruthy();\n    });\n\n    it('should add device markers to map', async () => {\n      const { component } = render(MockMapComponent);\n      \n      const devices = [\n        { id: '1', lat: 40.7128, lng: -74.0060, name: 'Device 1' },\n        { id: '2', lat: 40.7580, lng: -73.9855, name: 'Device 2' },\n      ];\n\n      component.$set({ devices });\n      await tick();\n\n      // Would verify marker creation in real test\n      expect(component.devices.length).toBe(2);\n    });\n\n    it('should update device positions in real-time', async () => {\n      const { component } = render(MockMapComponent);\n      \n      const device = { id: '1', lat: 40.7128, lng: -74.0060, name: 'Device 1' };\n      component.$set({ devices: [device] });\n      await tick();\n\n      // Update position\n      const updatedDevice = { ...device, lat: 40.7580, lng: -73.9855 };\n      component.$set({ devices: [updatedDevice] });\n      await tick();\n\n      // Would verify marker position update in real test\n      expect(component.devices[0].lat).toBe(40.7580);\n    });\n  });\n\n  describe('Control Panel Component', () => {\n    it('should toggle between different modes', async () => {\n      const { getByText, component } = render(MockControlPanel);\n      \n      const modes = ['Spectrum', 'Sweep', 'Devices'];\n      for (const mode of modes) {\n        const button = getByText(mode);\n        await fireEvent.click(button);\n        expect(component.activeMode).toBe(mode.toLowerCase());\n      }\n    });\n\n    it('should save and load presets', async () => {\n      const { getByText, getByLabelText } = render(MockControlPanel);\n      \n      // Save preset\n      const saveButton = getByText('Save Preset');\n      const nameInput = getByLabelText('Preset Name') as HTMLInputElement;\n      \n      await fireEvent.input(nameInput, { target: { value: 'My Preset' } });\n      await fireEvent.click(saveButton);\n      \n      // Would verify preset saved in real test\n      expect(nameInput.value).toBe('');\n    });\n\n    it('should validate gain settings', async () => {\n      const { getByLabelText } = render(MockControlPanel);\n      \n      const gainSlider = getByLabelText('Gain') as HTMLInputElement;\n      \n      // Valid range\n      await fireEvent.input(gainSlider, { target: { value: '30' } });\n      expect(gainSlider.validity.valid).toBe(true);\n      \n      // Out of range\n      gainSlider.setAttribute('max', '50');\n      await fireEvent.input(gainSlider, { target: { value: '60' } });\n      expect(Number(gainSlider.value)).toBeLessThanOrEqual(50);\n    });\n  });\n});\n\n// Mock components for testing\nconst MockSpectrumAnalyzer = {\n  props: ['centerFrequency', 'spectrumData', 'scale'],\n  template: '<canvas class=\"spectrum-canvas\"></canvas>',\n};\n\nconst MockDeviceCard = {\n  props: ['device', 'onclick'],\n  template: `\n    <div class=\"device-card\">\n      <div>{{ device.name }}</div>\n      <div>{{ device.mac }}</div>\n      <div data-testid=\"signal-strength\">{{ device.signal }} dBm</div>\n      <div data-testid=\"signal-bar\" :class=\"signalClass\"></div>\n      <div data-testid=\"last-seen\">{{ lastSeenText }}</div>\n    </div>\n  `,\n  computed: {\n    signalClass() {\n      return this.device.signal > -70 ? 'signal-strong' : 'signal-weak';\n    },\n    lastSeenText() {\n      return '1 minute ago'; // Simplified for test\n    },\n  },\n};\n\nconst MockFrequencySweeper = {\n  props: ['isSweping', 'progress'],\n  template: `\n    <div>\n      <input type=\"number\" aria-label=\"Start Frequency\" />\n      <input type=\"number\" aria-label=\"End Frequency\" />\n      <button :disabled=\"isSweping\">\n        {{ isSweping ? 'Stop Sweep' : 'Start Sweep' }}\n      </button>\n      <div data-testid=\"progress-bar\" :style=\"{ width: progress + '%' }\"></div>\n    </div>\n  `,\n};\n\nconst MockMapComponent = {\n  props: ['center', 'zoom', 'devices'],\n  template: '<div class=\"map-container\"></div>',\n};\n\nconst MockControlPanel = {\n  data() {\n    return { activeMode: 'spectrum' };\n  },\n  template: `\n    <div>\n      <button @click=\"activeMode = 'spectrum'\">Spectrum</button>\n      <button @click=\"activeMode = 'sweep'\">Sweep</button>\n      <button @click=\"activeMode = 'devices'\">Devices</button>\n      <input aria-label=\"Preset Name\" />\n      <button>Save Preset</button>\n      <input type=\"range\" aria-label=\"Gain\" min=\"0\" max=\"50\" />\n    </div>\n  `,\n};",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/tests/unit/services/map/signalClustering.test.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 9,
				"column": 5,
				"nodeType": "AssignmentExpression",
				"messageId": "anyAssignment",
				"endLine": 13,
				"endColumn": 7
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe construction of a(n) `error` type typed value.",
				"line": 9,
				"column": 25,
				"nodeType": "NewExpression",
				"messageId": "unsafeNew",
				"endLine": 13,
				"endColumn": 7
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 48,
				"column": 13,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 48,
				"endColumn": 65
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 48,
				"column": 24,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 48,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .clusterSignals on an `error` typed value.",
				"line": 48,
				"column": 42,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 48,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access [0] on an `error` typed value.",
				"line": 51,
				"column": 23,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 51,
				"endColumn": 24
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access [1] on an `error` typed value.",
				"line": 52,
				"column": 23,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 52,
				"endColumn": 24
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 66,
				"column": 13,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 66,
				"endColumn": 65
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 66,
				"column": 24,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 66,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .clusterSignals on an `error` typed value.",
				"line": 66,
				"column": 42,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 66,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access [0] on an `error` typed value.",
				"line": 69,
				"column": 23,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 69,
				"endColumn": 24
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access [0] on an `error` typed value.",
				"line": 70,
				"column": 23,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 70,
				"endColumn": 24
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 74,
				"column": 13,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 74,
				"endColumn": 60
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 74,
				"column": 24,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 74,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .clusterSignals on an `error` typed value.",
				"line": 74,
				"column": 42,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 74,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 79,
				"column": 7,
				"nodeType": "AssignmentExpression",
				"messageId": "anyAssignment",
				"endLine": 83,
				"endColumn": 9
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe construction of a(n) `error` type typed value.",
				"line": 79,
				"column": 27,
				"nodeType": "NewExpression",
				"messageId": "unsafeNew",
				"endLine": 83,
				"endColumn": 9
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 106,
				"column": 13,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 106,
				"endColumn": 65
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 106,
				"column": 24,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 106,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .clusterSignals on an `error` typed value.",
				"line": 106,
				"column": 42,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 106,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 110,
				"column": 14,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 110,
				"endColumn": 28
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .every on an `error` typed value.",
				"line": 110,
				"column": 23,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 110,
				"endColumn": 28
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-return",
				"severity": 2,
				"message": "Unsafe return of a value of type `any`.",
				"line": 110,
				"column": 34,
				"nodeType": "MemberExpression",
				"messageId": "unsafeReturn",
				"endLine": 110,
				"endColumn": 50
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .isSingleSignal on an `any` value.",
				"line": 110,
				"column": 36,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 110,
				"endColumn": 50
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 124,
				"column": 13,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 124,
				"endColumn": 65
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 124,
				"column": 24,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 124,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .clusterSignals on an `error` typed value.",
				"line": 124,
				"column": 42,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 124,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access [0] on an `error` typed value.",
				"line": 128,
				"column": 23,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 128,
				"endColumn": 24
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 134,
				"column": 13,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 137,
				"endColumn": 8
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 134,
				"column": 24,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 134,
				"endColumn": 59
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .calculateDistance on an `error` typed value.",
				"line": 134,
				"column": 42,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 134,
				"endColumn": 59
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 145,
				"column": 13,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 148,
				"endColumn": 8
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 145,
				"column": 24,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 145,
				"endColumn": 59
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .calculateDistance on an `error` typed value.",
				"line": 145,
				"column": 42,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 145,
				"endColumn": 59
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 154,
				"column": 13,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 157,
				"endColumn": 8
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 154,
				"column": 24,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 154,
				"endColumn": 59
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .calculateDistance on an `error` typed value.",
				"line": 154,
				"column": 42,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 154,
				"endColumn": 59
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 164,
				"column": 13,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 167,
				"endColumn": 8
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 164,
				"column": 24,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 164,
				"endColumn": 59
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .calculateDistance on an `error` typed value.",
				"line": 164,
				"column": 42,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 164,
				"endColumn": 59
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 214,
				"column": 13,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 214,
				"endColumn": 75
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 214,
				"column": 22,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 214,
				"endColumn": 53
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .mergeClusters on an `error` typed value.",
				"line": 214,
				"column": 40,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 214,
				"endColumn": 53
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access [0] on an `error` typed value.",
				"line": 217,
				"column": 21,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 217,
				"endColumn": 22
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access [0] on an `error` typed value.",
				"line": 218,
				"column": 21,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 218,
				"endColumn": 22
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 259,
				"column": 13,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 259,
				"endColumn": 75
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 259,
				"column": 22,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 259,
				"endColumn": 53
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .mergeClusters on an `error` typed value.",
				"line": 259,
				"column": 40,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 259,
				"endColumn": 53
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access [0] on an `error` typed value.",
				"line": 261,
				"column": 21,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 261,
				"endColumn": 22
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access [0] on an `error` typed value.",
				"line": 262,
				"column": 21,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 262,
				"endColumn": 22
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 287,
				"column": 13,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 287,
				"endColumn": 65
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 287,
				"column": 24,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 287,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .clusterSignals on an `error` typed value.",
				"line": 287,
				"column": 42,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 287,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access [0] on an `error` typed value.",
				"line": 290,
				"column": 23,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 290,
				"endColumn": 24
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access [0] on an `error` typed value.",
				"line": 291,
				"column": 23,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 291,
				"endColumn": 24
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 325,
				"column": 13,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 325,
				"endColumn": 65
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 325,
				"column": 24,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 325,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .clusterSignals on an `error` typed value.",
				"line": 325,
				"column": 42,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 325,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access [0] on an `error` typed value.",
				"line": 329,
				"column": 23,
				"nodeType": "Literal",
				"messageId": "unsafeMemberExpression",
				"endLine": 329,
				"endColumn": 24
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 346,
				"column": 13,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 346,
				"endColumn": 65
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 346,
				"column": 24,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 346,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .clusterSignals on an `error` typed value.",
				"line": 346,
				"column": 42,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 346,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .length on an `error` typed value.",
				"line": 350,
				"column": 23,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 350,
				"endColumn": 29
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 353,
				"column": 13,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 353,
				"endColumn": 82
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 353,
				"column": 28,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 353,
				"endColumn": 43
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .reduce on an `error` typed value.",
				"line": 353,
				"column": 37,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 353,
				"endColumn": 43
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-return",
				"severity": 2,
				"message": "Unsafe return of a value of type `any`.",
				"line": 353,
				"column": 56,
				"nodeType": "BinaryExpression",
				"messageId": "unsafeReturn",
				"endLine": 353,
				"endColumn": 78
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .signals on an `any` value.",
				"line": 353,
				"column": 64,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 353,
				"endColumn": 71
			}
		],
		"suppressedMessages": [],
		"errorCount": 68,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { describe, it, expect, beforeEach } from 'vitest';\nimport { SignalClusteringService } from '$lib/services/map/signalClustering';\nimport type { Signal, SignalCluster } from '$lib/types/signal';\n\ndescribe('SignalClusteringService', () => {\n  let clusteringService: SignalClusteringService;\n  \n  beforeEach(() => {\n    clusteringService = new SignalClusteringService({\n      proximityThreshold: 50, // meters\n      minClusterSize: 2,\n      mergeThreshold: 100 // meters\n    });\n  });\n\n  describe('Cluster Creation', () => {\n    it('should create clusters from signals within proximity threshold', () => {\n      const signals: Signal[] = [\n        {\n          id: '1',\n          timestamp: Date.now(),\n          latitude: 40.7128,\n          longitude: -74.0060,\n          strength: -50,\n          frequency: 2400000000,\n          metadata: {}\n        },\n        {\n          id: '2',\n          timestamp: Date.now(),\n          latitude: 40.7130,\n          longitude: -74.0062,\n          strength: -55,\n          frequency: 2400000000,\n          metadata: {}\n        },\n        {\n          id: '3',\n          timestamp: Date.now(),\n          latitude: 40.7500,\n          longitude: -74.0100,\n          strength: -60,\n          frequency: 2400000000,\n          metadata: {}\n        }\n      ];\n\n      const clusters = clusteringService.clusterSignals(signals);\n      \n      expect(clusters).toHaveLength(2);\n      expect(clusters[0].signals).toHaveLength(2);\n      expect(clusters[1].signals).toHaveLength(1);\n    });\n\n    it('should handle single signal (no clustering)', () => {\n      const signals: Signal[] = [{\n        id: '1',\n        timestamp: Date.now(),\n        latitude: 40.7128,\n        longitude: -74.0060,\n        strength: -50,\n        frequency: 2400000000,\n        metadata: {}\n      }];\n\n      const clusters = clusteringService.clusterSignals(signals);\n      \n      expect(clusters).toHaveLength(1);\n      expect(clusters[0].signals).toHaveLength(1);\n      expect(clusters[0].isSingleSignal).toBe(true);\n    });\n\n    it('should handle empty signal array', () => {\n      const clusters = clusteringService.clusterSignals([]);\n      expect(clusters).toHaveLength(0);\n    });\n\n    it('should respect minimum cluster size', () => {\n      clusteringService = new SignalClusteringService({\n        proximityThreshold: 50,\n        minClusterSize: 3,\n        mergeThreshold: 100\n      });\n\n      const signals: Signal[] = [\n        {\n          id: '1',\n          timestamp: Date.now(),\n          latitude: 40.7128,\n          longitude: -74.0060,\n          strength: -50,\n          frequency: 2400000000,\n          metadata: {}\n        },\n        {\n          id: '2',\n          timestamp: Date.now(),\n          latitude: 40.7130,\n          longitude: -74.0062,\n          strength: -55,\n          frequency: 2400000000,\n          metadata: {}\n        }\n      ];\n\n      const clusters = clusteringService.clusterSignals(signals);\n      \n      // Should not cluster because min size is 3\n      expect(clusters).toHaveLength(2);\n      expect(clusters.every(c => c.isSingleSignal)).toBe(true);\n    });\n\n    it('should handle overlapping clusters correctly', () => {\n      const signals: Signal[] = Array.from({ length: 10 }, (_, i) => ({\n        id: `${i}`,\n        timestamp: Date.now(),\n        latitude: 40.7128 + (i * 0.0001),\n        longitude: -74.0060 + (i * 0.0001),\n        strength: -50 - i,\n        frequency: 2400000000,\n        metadata: {}\n      }));\n\n      const clusters = clusteringService.clusterSignals(signals);\n      \n      // All signals should be in one cluster due to chain proximity\n      expect(clusters).toHaveLength(1);\n      expect(clusters[0].signals).toHaveLength(10);\n    });\n  });\n\n  describe('Distance Calculations', () => {\n    it('should calculate haversine distance accurately', () => {\n      const distance = clusteringService.calculateDistance(\n        40.7128, -74.0060, // NYC\n        40.7130, -74.0062  // Nearby point\n      );\n      \n      // Should be approximately 31 meters\n      expect(distance).toBeGreaterThan(30);\n      expect(distance).toBeLessThan(32);\n    });\n\n    it('should handle identical coordinates', () => {\n      const distance = clusteringService.calculateDistance(\n        40.7128, -74.0060,\n        40.7128, -74.0060\n      );\n      \n      expect(distance).toBe(0);\n    });\n\n    it('should handle date line crossing', () => {\n      const distance = clusteringService.calculateDistance(\n        0, 179.9,\n        0, -179.9\n      );\n      \n      // Should be very small distance, not half earth circumference\n      expect(distance).toBeLessThan(25000); // 25km\n    });\n\n    it('should handle pole calculations', () => {\n      const distance = clusteringService.calculateDistance(\n        89.9, 0,\n        90, 0\n      );\n      \n      expect(distance).toBeGreaterThan(0);\n      expect(distance).toBeLessThan(20000); // 20km\n    });\n  });\n\n  describe('Cluster Merging', () => {\n    it('should merge overlapping clusters', () => {\n      const cluster1: SignalCluster = {\n        id: 'cluster1',\n        center: { lat: 40.7128, lon: -74.0060 },\n        radius: 50,\n        signals: [\n          {\n            id: '1',\n            timestamp: Date.now(),\n            latitude: 40.7128,\n            longitude: -74.0060,\n            strength: -50,\n            frequency: 2400000000,\n            metadata: {}\n          }\n        ],\n        avgStrength: -50,\n        isSingleSignal: false\n      };\n\n      const cluster2: SignalCluster = {\n        id: 'cluster2',\n        center: { lat: 40.7130, lon: -74.0062 },\n        radius: 50,\n        signals: [\n          {\n            id: '2',\n            timestamp: Date.now(),\n            latitude: 40.7130,\n            longitude: -74.0062,\n            strength: -55,\n            frequency: 2400000000,\n            metadata: {}\n          }\n        ],\n        avgStrength: -55,\n        isSingleSignal: false\n      };\n\n      const merged = clusteringService.mergeClusters([cluster1, cluster2]);\n      \n      expect(merged).toHaveLength(1);\n      expect(merged[0].signals).toHaveLength(2);\n      expect(merged[0].avgStrength).toBe(-52.5);\n    });\n\n    it('should preserve signal metadata during merge', () => {\n      const metadata1 = { device: 'HackRF', antenna: 'Omni' };\n      const metadata2 = { device: 'RTL-SDR', antenna: 'Yagi' };\n\n      const cluster1: SignalCluster = {\n        id: 'cluster1',\n        center: { lat: 40.7128, lon: -74.0060 },\n        radius: 50,\n        signals: [{\n          id: '1',\n          timestamp: Date.now(),\n          latitude: 40.7128,\n          longitude: -74.0060,\n          strength: -50,\n          frequency: 2400000000,\n          metadata: metadata1\n        }],\n        avgStrength: -50,\n        isSingleSignal: false\n      };\n\n      const cluster2: SignalCluster = {\n        id: 'cluster2',\n        center: { lat: 40.7130, lon: -74.0062 },\n        radius: 50,\n        signals: [{\n          id: '2',\n          timestamp: Date.now(),\n          latitude: 40.7130,\n          longitude: -74.0062,\n          strength: -55,\n          frequency: 2400000000,\n          metadata: metadata2\n        }],\n        avgStrength: -55,\n        isSingleSignal: false\n      };\n\n      const merged = clusteringService.mergeClusters([cluster1, cluster2]);\n      \n      expect(merged[0].signals[0].metadata).toEqual(metadata1);\n      expect(merged[0].signals[1].metadata).toEqual(metadata2);\n    });\n\n    it('should update cluster center correctly', () => {\n      const signals: Signal[] = [\n        {\n          id: '1',\n          timestamp: Date.now(),\n          latitude: 40.0,\n          longitude: -74.0,\n          strength: -50,\n          frequency: 2400000000,\n          metadata: {}\n        },\n        {\n          id: '2',\n          timestamp: Date.now(),\n          latitude: 41.0,\n          longitude: -74.0,\n          strength: -50,\n          frequency: 2400000000,\n          metadata: {}\n        }\n      ];\n\n      const clusters = clusteringService.clusterSignals(signals);\n      \n      // Center should be midpoint\n      expect(clusters[0].center.lat).toBeCloseTo(40.5, 5);\n      expect(clusters[0].center.lon).toBeCloseTo(-74.0, 5);\n    });\n\n    it('should handle chain merging (A→B→C)', () => {\n      const signals: Signal[] = [\n        {\n          id: '1',\n          timestamp: Date.now(),\n          latitude: 40.7128,\n          longitude: -74.0060,\n          strength: -50,\n          frequency: 2400000000,\n          metadata: {}\n        },\n        {\n          id: '2',\n          timestamp: Date.now(),\n          latitude: 40.7133,\n          longitude: -74.0065,\n          strength: -55,\n          frequency: 2400000000,\n          metadata: {}\n        },\n        {\n          id: '3',\n          timestamp: Date.now(),\n          latitude: 40.7138,\n          longitude: -74.0070,\n          strength: -60,\n          frequency: 2400000000,\n          metadata: {}\n        }\n      ];\n\n      const clusters = clusteringService.clusterSignals(signals);\n      \n      // All should be in one cluster due to chain proximity\n      expect(clusters).toHaveLength(1);\n      expect(clusters[0].signals).toHaveLength(3);\n    });\n  });\n\n  describe('Performance', () => {\n    it('should cluster 1000 signals in reasonable time', () => {\n      const signals: Signal[] = Array.from({ length: 1000 }, (_, i) => ({\n        id: `${i}`,\n        timestamp: Date.now(),\n        latitude: 40.7128 + (Math.random() - 0.5) * 0.1,\n        longitude: -74.0060 + (Math.random() - 0.5) * 0.1,\n        strength: -50 - Math.random() * 30,\n        frequency: 2400000000,\n        metadata: {}\n      }));\n\n      const startTime = performance.now();\n      const clusters = clusteringService.clusterSignals(signals);\n      const endTime = performance.now();\n\n      expect(endTime - startTime).toBeLessThan(100); // 100ms\n      expect(clusters.length).toBeGreaterThan(0);\n      \n      // Verify no signals lost\n      const totalSignals = clusters.reduce((sum, c) => sum + c.signals.length, 0);\n      expect(totalSignals).toBe(1000);\n    });\n  });\n});",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/tests/utils/performanceMonitor.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/tests/utils/testDataGenerator.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/tests/visual/visual-regression.test.ts",
		"messages": [
			{
				"ruleId": "@typescript-eslint/no-unused-vars",
				"severity": 2,
				"message": "'path' is defined but never used. Allowed unused vars must match /^_/u.",
				"line": 6,
				"column": 8,
				"nodeType": null,
				"messageId": "unusedVar",
				"endLine": 6,
				"endColumn": 12
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 55,
				"column": 15,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 55,
				"endColumn": 34
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 66,
				"column": 17,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 66,
				"endColumn": 74
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 66,
				"column": 28,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 66,
				"endColumn": 41
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .sync on an `error` typed value.",
				"line": 66,
				"column": 32,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 66,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 67,
				"column": 17,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 67,
				"endColumn": 78
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 67,
				"column": 30,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 67,
				"endColumn": 43
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .sync on an `error` typed value.",
				"line": 67,
				"column": 34,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 67,
				"endColumn": 38
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 69,
				"column": 17,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 69,
				"endColumn": 51
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 70,
				"column": 17,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 70,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe construction of a(n) `error` type typed value.",
				"line": 70,
				"column": 24,
				"nodeType": "NewExpression",
				"messageId": "unsafeNew",
				"endLine": 70,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 70,
				"column": 34,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 70,
				"endColumn": 42
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 70,
				"column": 44,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 70,
				"endColumn": 53
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 72,
				"column": 17,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 79,
				"endColumn": 12
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 72,
				"column": 33,
				"nodeType": "Identifier",
				"messageId": "unsafeCall",
				"endLine": 72,
				"endColumn": 43
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .data on an `error` typed value.",
				"line": 73,
				"column": 22,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 73,
				"endColumn": 26
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .data on an `error` typed value.",
				"line": 74,
				"column": 24,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 74,
				"endColumn": 28
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .data on an `error` typed value.",
				"line": 75,
				"column": 18,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 75,
				"endColumn": 22
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-argument",
				"severity": 2,
				"message": "Unsafe argument of type error typed assigned to a parameter of type `string | Stream | ArrayBufferView<ArrayBufferLike> | Iterable<string | ArrayBufferView<ArrayBufferLike>> | AsyncIterable<...>`.",
				"line": 82,
				"column": 42,
				"nodeType": "CallExpression",
				"messageId": "unsafeArgument",
				"endLine": 82,
				"endColumn": 62
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 82,
				"column": 42,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 82,
				"endColumn": 56
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .sync on an `error` typed value.",
				"line": 82,
				"column": 46,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 82,
				"endColumn": 50
			},
			{
				"ruleId": "@typescript-eslint/no-explicit-any",
				"severity": 1,
				"message": "Unexpected any. Specify a different type.",
				"line": 88,
				"column": 25,
				"nodeType": "TSAnyKeyword",
				"messageId": "unexpectedAny",
				"endLine": 88,
				"endColumn": 28,
				"suggestions": [
					{
						"messageId": "suggestUnknown",
						"fix": { "range": [3175, 3178], "text": "unknown" },
						"desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
					},
					{
						"messageId": "suggestNever",
						"fix": { "range": [3175, 3178], "text": "never" },
						"desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .code on an `any` value.",
				"line": 88,
				"column": 30,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 88,
				"endColumn": 34
			},
			{
				"ruleId": "no-console",
				"severity": 1,
				"message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
				"line": 90,
				"column": 13,
				"nodeType": "MemberExpression",
				"messageId": "limited",
				"endLine": 90,
				"endColumn": 24,
				"suggestions": [
					{
						"fix": { "range": [3274, 3338], "text": "" },
						"messageId": "removeConsole",
						"data": { "propertyName": "log" },
						"desc": "Remove the console.log()."
					}
				]
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 156,
				"column": 15,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 156,
				"endColumn": 34
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 160,
				"column": 15,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 160,
				"endColumn": 50
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 160,
				"column": 24,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 160,
				"endColumn": 37
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .sync on an `error` typed value.",
				"line": 160,
				"column": 28,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 160,
				"endColumn": 32
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 161,
				"column": 15,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 161,
				"endColumn": 48
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 161,
				"column": 23,
				"nodeType": "MemberExpression",
				"messageId": "unsafeCall",
				"endLine": 161,
				"endColumn": 36
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .sync on an `error` typed value.",
				"line": 161,
				"column": 27,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 161,
				"endColumn": 31
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 163,
				"column": 15,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 163,
				"endColumn": 77
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe construction of a(n) `error` type typed value.",
				"line": 163,
				"column": 22,
				"nodeType": "NewExpression",
				"messageId": "unsafeNew",
				"endLine": 163,
				"endColumn": 77
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 163,
				"column": 32,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 163,
				"endColumn": 51
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .width on an `error` typed value.",
				"line": 163,
				"column": 46,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 163,
				"endColumn": 51
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 163,
				"column": 53,
				"nodeType": "Property",
				"messageId": "anyAssignment",
				"endLine": 163,
				"endColumn": 74
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .height on an `error` typed value.",
				"line": 163,
				"column": 68,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 163,
				"endColumn": 74
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-assignment",
				"severity": 2,
				"message": "Unsafe assignment of an error typed value.",
				"line": 164,
				"column": 15,
				"nodeType": "VariableDeclarator",
				"messageId": "anyAssignment",
				"endLine": 171,
				"endColumn": 10
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-call",
				"severity": 2,
				"message": "Unsafe call of a(n) `error` type typed value.",
				"line": 164,
				"column": 31,
				"nodeType": "Identifier",
				"messageId": "unsafeCall",
				"endLine": 164,
				"endColumn": 41
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .data on an `error` typed value.",
				"line": 165,
				"column": 18,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 165,
				"endColumn": 22
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .data on an `error` typed value.",
				"line": 166,
				"column": 17,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 166,
				"endColumn": 21
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .data on an `error` typed value.",
				"line": 167,
				"column": 16,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 167,
				"endColumn": 20
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .width on an `error` typed value.",
				"line": 168,
				"column": 18,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 168,
				"endColumn": 23
			},
			{
				"ruleId": "@typescript-eslint/no-unsafe-member-access",
				"severity": 2,
				"message": "Unsafe member access .height on an `error` typed value.",
				"line": 169,
				"column": 18,
				"nodeType": "Identifier",
				"messageId": "unsafeMemberExpression",
				"endLine": 169,
				"endColumn": 24
			}
		],
		"suppressedMessages": [],
		"errorCount": 42,
		"fatalErrorCount": 0,
		"warningCount": 2,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"source": "import { describe, it, expect, beforeAll, afterAll } from 'vitest';\nimport puppeteer, { Browser, Page } from 'puppeteer';\nimport pixelmatch from 'pixelmatch';\nimport { PNG } from 'pngjs';\nimport fs from 'fs/promises';\nimport path from 'path';\n\nconst VISUAL_REGRESSION_CONFIG = {\n  threshold: 0.1, // 0.1% difference allowed for pixel-perfect validation\n  baseUrl: process.env.TEST_URL || 'http://localhost:5173',\n  viewports: [\n    { name: 'mobile', width: 375, height: 667 },\n    { name: 'tablet', width: 768, height: 1024 },\n    { name: 'desktop', width: 1920, height: 1080 },\n  ],\n  pages: [\n    { name: 'home', path: '/' },\n    { name: 'spectrum', path: '/spectrum' },\n    { name: 'sweep', path: '/sweep' },\n    { name: 'devices', path: '/devices' },\n    { name: 'map', path: '/map' },\n  ],\n};\n\ndescribe('Visual Regression Tests', () => {\n  let browser: Browser;\n  let page: Page;\n\n  beforeAll(async () => {\n    browser = await puppeteer.launch({\n      headless: true,\n      args: ['--no-sandbox', '--disable-setuid-sandbox'],\n    });\n    page = await browser.newPage();\n    \n    // Ensure baseline directory exists\n    await fs.mkdir('tests/visual/baselines', { recursive: true });\n    await fs.mkdir('tests/visual/screenshots', { recursive: true });\n    await fs.mkdir('tests/visual/diffs', { recursive: true });\n  });\n\n  afterAll(async () => {\n    await browser.close();\n  });\n\n  VISUAL_REGRESSION_CONFIG.pages.forEach(({ name: pageName, path: pagePath }) => {\n    VISUAL_REGRESSION_CONFIG.viewports.forEach(({ name: viewportName, width, height }) => {\n      it(`should match baseline for ${pageName} page on ${viewportName}`, async () => {\n        await page.setViewport({ width, height });\n        await page.goto(`${VISUAL_REGRESSION_CONFIG.baseUrl}${pagePath}`, {\n          waitUntil: 'networkidle0',\n        });\n\n        // Wait for any animations to complete\n        await page.waitForTimeout(1000);\n\n        // Take screenshot\n        const screenshotPath = `tests/visual/screenshots/${pageName}-${viewportName}.png`;\n        await page.screenshot({ path: screenshotPath, fullPage: true });\n\n        // Compare with baseline\n        const baselinePath = `tests/visual/baselines/${pageName}-${viewportName}.png`;\n        const diffPath = `tests/visual/diffs/${pageName}-${viewportName}-diff.png`;\n\n        try {\n          const baseline = PNG.sync.read(await fs.readFile(baselinePath));\n          const screenshot = PNG.sync.read(await fs.readFile(screenshotPath));\n\n          const { width: w, height: h } = baseline;\n          const diff = new PNG({ width: w, height: h });\n\n          const numDiffPixels = pixelmatch(\n            baseline.data,\n            screenshot.data,\n            diff.data,\n            w,\n            h,\n            { threshold: VISUAL_REGRESSION_CONFIG.threshold }\n          );\n\n          if (numDiffPixels > 0) {\n            await fs.writeFile(diffPath, PNG.sync.write(diff));\n            const percentDiff = (numDiffPixels / (w * h)) * 100;\n            expect(percentDiff).toBeLessThan(0.1); // Less than 0.1% difference\n          }\n        } catch (error) {\n          // If baseline doesn't exist, create it\n          if ((error as any).code === 'ENOENT') {\n            await fs.copyFile(screenshotPath, baselinePath);\n            console.log(`Created baseline for ${pageName}-${viewportName}`);\n          } else {\n            throw error;\n          }\n        }\n      });\n    });\n  });\n\n  describe('Component Visual Tests', () => {\n    it('should render spectrum analyzer correctly', async () => {\n      await page.goto(`${VISUAL_REGRESSION_CONFIG.baseUrl}/spectrum`);\n      await page.waitForSelector('.spectrum-canvas', { timeout: 5000 });\n      \n      const spectrumElement = await page.$('.spectrum-canvas');\n      if (spectrumElement) {\n        const screenshot = await spectrumElement.screenshot();\n        const screenshotPath = 'tests/visual/screenshots/spectrum-component.png';\n        await fs.writeFile(screenshotPath, screenshot);\n\n        // Verify canvas dimensions\n        const dimensions = await page.evaluate(() => {\n          const canvas = document.querySelector('.spectrum-canvas') as HTMLCanvasElement;\n          return {\n            width: canvas?.width,\n            height: canvas?.height,\n          };\n        });\n\n        expect(dimensions.width).toBeGreaterThan(0);\n        expect(dimensions.height).toBeGreaterThan(0);\n      }\n    });\n\n    it('should render device cards with correct styling', async () => {\n      await page.goto(`${VISUAL_REGRESSION_CONFIG.baseUrl}/devices`);\n      await page.waitForSelector('.device-card', { timeout: 5000 });\n      \n      const styles = await page.evaluate(() => {\n        const card = document.querySelector('.device-card');\n        if (!card) return null;\n        \n        const computedStyle = window.getComputedStyle(card);\n        return {\n          borderRadius: computedStyle.borderRadius,\n          boxShadow: computedStyle.boxShadow,\n          padding: computedStyle.padding,\n          backgroundColor: computedStyle.backgroundColor,\n        };\n      });\n\n      expect(styles).toBeTruthy();\n      expect(styles?.borderRadius).toBe('0.5rem');\n      expect(styles?.backgroundColor).toBeTruthy();\n    });\n  });\n\n  describe('Animation and Transition Tests', () => {\n    it('should capture hover states correctly', async () => {\n      await page.goto(`${VISUAL_REGRESSION_CONFIG.baseUrl}`);\n      \n      // Find a button to hover\n      const button = await page.$('button');\n      if (button) {\n        const beforeHover = await button.screenshot();\n        await button.hover();\n        await page.waitForTimeout(300); // Wait for transition\n        const afterHover = await button.screenshot();\n\n        // Compare screenshots\n        const before = PNG.sync.read(beforeHover);\n        const after = PNG.sync.read(afterHover);\n        \n        const diff = new PNG({ width: before.width, height: before.height });\n        const numDiffPixels = pixelmatch(\n          before.data,\n          after.data,\n          diff.data,\n          before.width,\n          before.height,\n          { threshold: 0.5 }\n        );\n\n        // There should be some difference due to hover effect\n        expect(numDiffPixels).toBeGreaterThan(0);\n      }\n    });\n  });\n});",
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/tests/vitest.config.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/vite.config.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	},
	{
		"filePath": "/home/pi/projects/ArgosFinal/vitest.config.ts",
		"messages": [],
		"suppressedMessages": [],
		"errorCount": 0,
		"fatalErrorCount": 0,
		"warningCount": 0,
		"fixableErrorCount": 0,
		"fixableWarningCount": 0,
		"usedDeprecatedRules": []
	}
]
